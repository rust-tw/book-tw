<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 程式設計語言</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust 程式設計語言</a></li><li class="chapter-item expanded affix "><a href="foreword.html">前言</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">介紹</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 開始入門</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安裝教學</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 設計猜謎遊戲程式</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 常見程式設計概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 變數與可變性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 資料型別</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函式</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 註解</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流程</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 理解所有權</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什麼是所有權？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 參考與借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 切片型別</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 透過結構體組織相關資料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定義與實例化結構體</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 使用結構體的程式範例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 枚舉與模式配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定義枚舉</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流建構子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 透過 if let 簡化控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 透過套件、Crate 與模組管理成長中的專案</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 套件與 Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 定義模組來控制作用域與隱私權</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 參考模組項目的路徑</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> 透過 use 關鍵字引入路徑</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 將模組拆成不同檔案</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 常見集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 透過向量儲存列表</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 透過字串儲存 UTF-8 編碼的文字</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 透過雜湊映射儲存鍵值配對</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 與無法復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 與可復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 要 panic! 還是不要 panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型型別、特徵與生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型資料型別</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 特徵：定義共同行為</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 透過生命週期驗證參考</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 編寫自動化測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 如何寫測試</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 控制程式如何執行</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 測試組織架構</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 專案：建立一個命令列程式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 接受命令列引數</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 讀取檔案</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 透過重構來改善模組性與錯誤處理</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 透過測試驅動開發完善函式庫功能</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 處理環境變數</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 將錯誤訊息寫入標準錯誤而非標準輸出</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 函式語言功能：疊代器與閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 閉包：獲取其環境的匿名函式</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用疊代器來處理一系列的項目</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改善我們的 I/O 專案</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 比較效能：迴圈 vs. 疊代器</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多關於 Cargo 與 Crates.io 的內容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 透過發佈設定檔自訂建構</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 發佈 Crate 到 Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空間</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 透過 cargo install 安裝執行檔</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 透過自訂命命來擴展 Cargo 的功能</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智慧指標</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 使用 Box&lt;T&gt; 指向堆積上的資料</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 透過 Deref 特徵將智慧指標視為一般參考</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 透過 Drop 特徵執行清除程式碼</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt; 參考計數智慧指標</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; 與內部可變性模式</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 參考循環會導致記憶體泄漏</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 無懼並行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 使用執行緒同時執行程式碼</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 使用訊息傳遞在執行緒間傳送資料</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享狀態並行</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 透過 Sync 與 Send 特徵擴展並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的物件導向程式設計特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 物件導向語言的特色</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 允許不同型別數值的特徵物件</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 實作物件導向設計模式</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式與配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有能使用模式的地方</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 可反駁性：何時模式可能會配對失敗</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 模式語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 進階特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 進階特徵</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 進階型別</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 進階函式與閉包</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> 巨集</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最終專案：建立多執行緒網頁伺服器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 建立單一執行緒的網頁伺服器</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 將單一執行緒伺服器轉換為多執行緒伺服器</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常關機與清理</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 附錄</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 關鍵字</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 運算子與符號</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可推導的特徵</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 實用開發工具</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 版號</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 本書的翻譯本</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust 的開發流程與「每夜版 Rust」</a></li><li class="chapter-item expanded "><a href="appendix-08-terminology.html"><strong aria-hidden="true">21.8.</strong> H - 中英術語對照表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 程式設計語言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tw/book-tw" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-程式設計語言"><a class="header" href="#rust-程式設計語言">Rust 程式設計語言</a></h1>
<p><em>由 Steve Klabnik 與 Carol Nichols，以及 Rust 社群的貢獻撰寫而成</em></p>
<p>此版本假設你使用的是 Rust 1.65（於 2022-11-03 發布）或更高的版本，並在所有專案中的 <em>Cargo.toml</em> 都有 <code>edition=&quot;2021&quot;</code> 來使用 Rust 2021 版號。請查看<a href="ch01-01-installation.html">第一章的「安裝」段落</a><!-- ignore -->來安裝或更新 Rust。</p>
<p>本書的 HTML 格式可以在線上閱讀：<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>（<a href="https://rust-lang.tw/book-tw/">正體中文版</a>）。而離線版則包含在 <code>rustup</code> 安裝的 Rust 中，輸入 <code>rustup docs --book</code> 就能開啟。</p>
<p>社群中也有提供本書的各種[譯本]。</p>
<p>本書也有由 <a href="https://nostarch.com/rust">No Starch Press 出版平裝與電子版格式</a>。</p>
<blockquote>
<p><strong>🚨 想要更有互動的學習體驗？來嘗試不同的 Rust Book，賣點有：隨堂測驗、重點提示、視覺化呈現，更多都在</strong> <a href="https://rust-book.cs.brown.edu">https://rust-book.cs.brown.edu</a></p>
</blockquote>
<blockquote>
<ul>
<li>commit: <a href="https://github.com/rust-lang/book/commit/3f64052c048c6def93b94a2b514ee88bba918744">3f64052</a></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>雖然不是那麼明確，但 Rust 程式設計語言旨在<strong>賦權（empowerment）</strong>：無論你現在寫的是何種程式碼，Rust 都能賦予你更多能力，在更廣泛的領域中帶有自信地向前邁進。</p>
<p>比方說，「系統層級」的工作會需要處理低階的記憶體管理、資料呈現與程序並行的細節。對以往來說，這塊程式領域被視為巫術般的存在，只有投入好幾年時間學習的選中之人才有辦法駕馭，也才能懂得如何避開其惡名昭彰的陷阱。而且就算是這個領域的實作者也謹慎行事，也生怕他們的程式碼會出現漏洞、崩潰或損壞。</p>
<p>Rust 破除了這些障礙，消除了以往的陷阱並提供友善全面的工具來協助你。想要「深入」底層控制的程式設計師可以使用 Rust，無需冒著常見的崩潰或安全漏洞風險，也無需學習得經常改變的工具鏈其中的細節。更好地是，這個語言本身就是設計成能引導你自然而然地寫出可靠且在速度與記憶體使用都十分高效的程式碼。</p>
<p>已經在處理底層程式碼的程式設計師可以使用 Rust 來擴展他們的野心。舉例來說，在 Rust 中進行平行化是相對低風險的動作，編譯器會幫你抓到典型的錯誤。而且你也能更有自信且更積極地進行最佳化，不必擔心會意外造成崩潰或漏洞。</p>
<p>但 Rust 並不只限於底層的系統程式設計。其表現力與易用易讀的程度能令人愉快地寫出 CLI 應用程式、網頁伺服器與許多其他種程式碼。你會在本書中看到這兩種簡單的範例。使用 Rust 能這讓你將一個領域所學到的技能延伸到另一個領域，你可以透過寫網頁應用程式來學習 Rust，然後應用同樣的技能到你的樹莓派（Raspberry Pi）上。</p>
<p>本書充分體現了 Rust 賦予其使用者更多能力的潛力。其內容平易近人，不止致力於協助你提升 Rust 的知識，還能提升讓你身為程式設計師的整體信心。所以讓我們準備開始學習吧，歡迎加入 Rust 的社群！</p>
<p>— Nicholas Matsakis 與 Aaron Turon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介紹"><a class="header" href="#介紹">介紹</a></h1>
<blockquote>
<p>注意：本書的（英文）版本與出版的 <a href="https://nostarch.com/rust">The Rust Programming Language</a> 以及電子書版本的 <a href="https://nostarch.com/">No Starch Press</a> 一致。</p>
</blockquote>
<p>歡迎閱讀 <strong>Rust 程式設計語言</strong>，這是一本 Rust 的入門書籍。Rust 程式設計語言能幫助你寫出更快更可靠的軟體。在設計程式語言時，「上層的易讀易用性」與「底層的掌控性」經常難以取捨。Rust 直接挑戰這個矛盾。Rust 在強大的技術能力與良好的開發者體驗之間取得平衡，讓你能控制底層的實作細節（比如記憶體使用），但免於以往這樣的控制所帶來的相關麻煩。</p>
<h2 id="rust-適用於誰"><a class="header" href="#rust-適用於誰">Rust 適用於誰</a></h2>
<p>Rust 的各種特長讓它適用於很多人，我們來討論一些最重要的客群。</p>
<h3 id="開發團隊"><a class="header" href="#開發團隊">開發團隊</a></h3>
<p>Rust 被認定是一個有生產力的工具，讓能力不均的大型系統程式設計團隊能夠協同開發。底層程式碼容易產生難以察覺的錯誤，在多數其他語言中，只能靠大量的測試、以及經驗豐富的開發者小心翼翼地審核程式碼，才能找出它們。而在 Rust 中，編譯器扮演著守門員的角色阻擋這些難以捉摸的程式錯誤，包含並行（concurrency）的錯誤。透過與編譯器一同合作，開發團隊可以將他們的時間專注在程式邏輯，而不是成天追著錯誤跑。</p>
<p>Rust 也將一些現代化的開發工具帶入系統程式設計的世界中：</p>
<ul>
<li>Cargo 是個管理依賴函式庫與建構的工具，讓新增、編譯與管理依賴函式庫變得十分輕鬆，並在 Rust 生態系統維持一致性。</li>
<li>Rustfmt 工具確保開發者遵循統一的程式碼風格。</li>
<li>Rust Language Server 為整合開發環境（IDE）提供了程式碼補全與行內錯誤訊息。</li>
</ul>
<p>透過使用這些工具、以及其他 Rust 生態系統中的工具，開發者在寫系統層級的程式時更有生產力。</p>
<h3 id="學生"><a class="header" href="#學生">學生</a></h3>
<p>Rust 適合學生以及那些對學習系統概念有興趣的人。許多人透過 Rust 學會相關主題，例如作業系統開發。社群的人都非常友善，且樂於解答學習者的問題。如同對本書的投入，Rust 團隊致力於讓系統概念深入人心，尤其是剛開始學習程式設計的人。</p>
<h3 id="公司"><a class="header" href="#公司">公司</a></h3>
<p>已有大大小小數以百計的公司，在正式生產環境中使用 Rust 來處理各種任務，包含命令列工具、網路服務、DevOps 工具、嵌入式裝置、影音分析與轉碼、加密貨幣、生物資訊、搜尋引擎、物聯網應用、機器學習，甚至是 Firefox 瀏覽器的主要部分。</p>
<h3 id="開源開發者"><a class="header" href="#開源開發者">開源開發者</a></h3>
<p>Rust 適用於想要建構 Rust 程式設計語言、社群、開發工具與函式庫的開發者。我們很樂於看到你願意對 Rust 語言貢獻。</p>
<h3 id="重視速度與穩定性的開發者"><a class="header" href="#重視速度與穩定性的開發者">重視速度與穩定性的開發者</a></h3>
<p>Rust 適用於追求語言速度與穩定性的開發者。所謂的速度，我們指的是 Rust 程式碼的執行速度以及 Rust 讓你能開始撰寫程式碼的速度。Rust 編譯器的檢查能確保新增功能與重構時的穩定性。這與沒有這些檢查的語言形成對比，開發者通常不敢修改其脆弱的遺留程式碼。Rust 還力求無成本抽象化（zero-cost abstractions），高階的特性編譯成底層程式碼後，執行的速度能像手刻一樣快。Rust 致力於讓安全的程式碼同時也能是執行迅速的程式碼。</p>
<p>這裡提及的僅是一部分的最大受益者，Rust 語言期許能支援更多其他使用者。總體來說，Rust 最大的野心是消除數十年來開發者不得不作出的取捨，像是提供安全性<strong>與</strong>生產力、具有速度<strong>又</strong>易讀易用。歡迎嘗試 Rust，看看這門語言適不適合你。</p>
<h2 id="本書寫給誰看"><a class="header" href="#本書寫給誰看">本書寫給誰看</a></h2>
<p>本書假設你已經使用其他程式語言寫過程式碼，無論哪種語言。我們會試著讓不同背景的開發者能理解內容，但我們不會花費很多篇幅談論<strong>什麼是</strong>程式設計或教你怎麼寫程式。如果你剛開始學習程式語言，一本專門介紹程式設計的書籍會更適合你。</p>
<h2 id="如何閱讀本書"><a class="header" href="#如何閱讀本書">如何閱讀本書</a></h2>
<p>一般來說，本書預設你會從前往後依序閱讀。後面的章節建立在前面提到的概念上，並且前面的章節不會深入某特定主題，而於後面的章節再議。</p>
<p>你會發現本書有兩種類型的章節：概念章節與專案章節。在概念章節中，你會學到 Rust 的某些概念。在專案章節中，我們會一起應用當前所學來做小專案。第二、十二和二十章是專案章節，其餘是概念章節。</p>
<p>第一章會解釋如何安裝 Rust、如何寫支「Hello, world!」程式以及如何使用 Cargo－－Rust 的套件管理與建構工具。第二章透過實作一款猜數字遊戲的程式來介紹 Rust。我們在此提及大概的觀念，並在之後的章節提供更詳細的介紹。如果你想馬上動手實作看看的話，第二章會很適合你。第三章會涵蓋 Rust 與其他程式設計語言類似的功能。第四章則會學習 Rust 的所有權系統。如果你是嚴謹派的讀者、傾向先學習所有細節再進入實作，你可能會想跳過第二章直接前往第三章。當你想要應用學到的細節時，再回到第二章練習。</p>
<p>第五章討論結構體與方法，而第六章涵蓋枚舉、<code>match</code> 表達式與 <code>if let</code> 控制流程的語法。你會在 Rust 中用結構體與枚舉來自訂型別。</p>
<p>在第七章中，你會學到 Rust 的模組系統與隱私規則，讓你可以組織程式碼以及其公開應用程式介面（Application Programming Interface, API）。第八章會討論標準函式庫提供的一些常見集合資料結構，像是向量、字串與雜湊映射。第九章會探討 Rust 的錯誤處理哲學與技巧。</p>
<p>第十章將深入探討泛型、特徵（traits）與生命週期，讓你能定義出能套用多種型別的程式碼。第十一章都在討論測試，就算有 Rust 的安全性保障，還是必須透過測試來確保你的程式邏輯正確。在第十二章中，我們會動手實作 <code>grep</code> 命令列工具的部分功能，可以搜尋檔案中的文字。我們將會應用前幾章討論過的許多概念。</p>
<p>第十三章會探索閉包與疊代器，這是 Rust 借鑒函式程式設計語言的功能。在第十四章中，我們要更深入研究 Cargo 並討論分享函式庫給其他人的最佳方式。第十五章會討論標準函式庫提供的智慧指標以及能啟用它們功能的特徵（traits）。</p>
<p>在第十六章中，我們會介紹各種不同的並行程式設計模型，並談論 Rust 如何幫助你無懼地開發多執行緒的程式。第十七章會拿 Rust 的慣用風格與你可能較熟悉的物件導向程式設計原則作比較。</p>
<p>第十八章涉及模式與模式配對，它們的強大力量讓你能用 Rust 表達更多概念。第十九章是進階主題的大雜燴，其中包含：不安全（unsafe）的 Rust、巨集、以及更多關於生命週期、特徵、型別、函式與閉包的介紹。</p>
<p>在第二十章中，我們會完整實作一個底層跑多執行緒的網頁伺服器！</p>
<p>最後，以參照的方式收錄本語言的一些實用資訊。附錄 A 涵蓋 Rust 的關鍵字、附錄 B 涵蓋 Rust 的運算子與符號、附錄 C 涵蓋標準函式庫提供的可推導的特徵（derivable traits）、附錄 D 涵蓋一些實用開發工具，然後附錄 E 會解釋 Rust 的版號。在附錄 F 中你可以找到本書籍的各種翻譯版本，然後在附錄 G 我們會講解 Rust 的開發流程以及什麼是每夜版（Nightly）Rust。</p>
<p>本書沒有錯誤的閱讀方式－－如果你想要跳過一些章節，儘管跳過吧！後面也許會遇到不懂的地方而需要回頭去看。總之用最適合自己的方式閱讀。</p>
<p><span id="ferris"></span></p>
<p>學習 Rust 的過程中有個重要的部分－－學習如何閱讀編譯器顯示的錯誤訊息，讓訊息引導你寫出正確的程式碼。因此，我們特意提供很多無法編譯的範例，以及編譯器對應顯示的錯誤訊息。如果你隨意挑一則範例執行的話，它可能無法編譯喔！請務必看看範例旁的文字來瞭解該範例是不是故意出錯。可愛的吉祥物 Ferris 也能幫助你分辨哪些程式碼本來就無法運作：</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>意思</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris 有疑問"/></td><td>此程式碼無法編譯！</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris 兩鉗一攤"/></td><td>此程式碼會恐慌！</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris 舉鉗聳肩"/></td><td>此程式碼不會產生預期的行為。</td></tr>
</tbody></table>
</div>
<p>在大多數的情況下，我們會引導你將無法編譯的程式碼寫成正確的版本。</p>
<h2 id="原始碼"><a class="header" href="#原始碼">原始碼</a></h2>
<p>產生本書的原始檔案可以在 <a href="https://github.com/rust-tw/book-tw">GitHub</a> 上找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="開始入門"><a class="header" href="#開始入門">開始入門</a></h1>
<p>讓我們開始你的 Rust 旅途吧！千里之行始於足下，在此章節我們將討論：</p>
<ul>
<li>在 Linux、macOS 和 Windows 上安裝 Rust</li>
<li>寫一支印出 <code>Hello, world!</code> 的程式</li>
<li>使用 Rust 的套件管理工具暨建構系統 <code>cargo</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安裝教學"><a class="header" href="#安裝教學">安裝教學</a></h2>
<p>第一步是安裝 Rust，我們將會透過 <code>rustup</code> 安裝 Rust，這是個管理 Rust 版本及相關工具的命令列工具。你將會需要網路連線才能下載。</p>
<blockquote>
<p>注意：如果你基於某些原因不想使用 <code>rustup</code> 的話，請前往 <a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Rust 其他安裝方法的頁面</a>尋求其他選項。</p>
</blockquote>
<p>以下步驟將會安裝最新的穩定版 Rust 編譯器。Rust 的穩定性能確保本書的所有範例在更新的 Rust 版本仍然能繼續編譯出來。輸出的結果可能會在不同版本間而有些微的差異，因為 Rust 時常會改善錯誤與警告訊息。換句話說，任何你所安裝的最新穩定版 Rust 都應該能夠正常運行本書的內容。</p>
<blockquote>
<h3 id="命令列標記"><a class="header" href="#命令列標記">命令列標記</a></h3>
<p>在本章節到整本書為止，我們將會顯示一些終端機會用到的命令。任一你會用到的命令都會始於 <code>$</code>。但你不需要去輸入 <code>$</code>，因為這通常代表每一命令列的起始位置。而沒有出現 <code>$</code> 的行數，通常則代表前一行命列輸出的結果。除此之外，針對 PowerShell 的範例則將會使用 <code>&gt;</code> 而不是 <code>$</code>。</p>
</blockquote>
<h3 id="在-linux-或-macos-上安裝-rustup"><a class="header" href="#在-linux-或-macos-上安裝-rustup">在 Linux 或 macOS 上安裝 <code>rustup</code></a></h3>
<p>如果你使用的是 Linux 或 macOS，請開啟終端機然後輸入以下命令：</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>這道命令會下載一支腳本然後開始安裝 <code>rustup</code> 工具，接著安裝最新的穩定版 Rust。下載過程中可能會要求你輸入你的密碼。如果下載成功的話，將會出現以下內容：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>你還會需要一個<strong>連結器（linker）</strong> 來讓 Rust 將編譯好的輸出資料整理到一個檔案內。通常你很可能已經有安裝了，但如果你遇到連結器相關的錯誤時，這代表你需要安裝一個 C 編譯器，因爲它通常都會帶有一個的連結器。有個 C 編譯器通常也很實用，因爲一些常見的 Rust 套件也會依賴於 C 而需要一個 C 編譯器。</p>
<p>在 macOS 上，你可以輸入以下命令來安裝 C 編譯器：</p>
<pre><code class="language-console">$ xcode-select --install
</code></pre>
<p>Linux 使用者的話則需要依據他們的發行版文件來安裝 GCC 或 Clang。舉例來說，如果你使用 Ubuntu 的話，你可以安裝 <code>build-essential</code> 套件。</p>
<h3 id="在-windows-上安裝-rustup"><a class="header" href="#在-windows-上安裝-rustup">在 Windows 上安裝 <code>rustup</code></a></h3>
<p>在 Windows 上請前往[下載頁面][install-windows]並依照指示安裝 Rust。在安裝的某個過程中，你將會看到一個訊息要求說你還需要 C++ build tools for Visual Studio 2013 或更新的版本。</p>
<p>要取得 build tools 的話，你需要安裝 <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>。當你被問到要安裝哪些時，請記得包含：</p>
<ul>
<li>“Desktop Development with C++”</li>
<li>The Windows 10 or 11 SDK</li>
<li>The English language pack component（以及其他你想選擇的語言包）</li>
</ul>
<p>本書接下來使用的命令都相容於 <em>cmd.exe</em> 和 PowerShell。如果有特別不同的地方，我們會解釋該怎麼使用。</p>
<h3 id="疑難排除"><a class="header" href="#疑難排除">疑難排除</a></h3>
<p>想簡單確認你是否有正確安裝 Rust 的話，請開啟 shell 然後輸入此命令：</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>你應該會看到已發佈的最新穩定版本號、提交雜湊（hash）以及提交日期如以下格式所示：</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>如果你看到這則訊息代表你成功安裝 Rust 了！如果你沒有看到的話，請如下檢查 Rust 是否在你的 <code>%PATH%</code> 系統變數裡。</p>
<p>在 Windows CMD 中請使用：</p>
<pre><code class="language-console">&gt; echo %PATH%
</code></pre>
<p>在 PowerShell 中請使用：</p>
<pre><code class="language-powershell">&gt; echo $env:Path
</code></pre>
<p>在 Linux 和 macOS 的話請使用：</p>
<pre><code class="language-console">$ echo $PATH
</code></pre>
<p>如果以上步驟皆正確無誤，但還是無法執行 Rust 的話，你可以前往一些地方尋求協助。例如您可以前往<a href="https://www.rust-lang.org/community">社群頁面</a>聯絡其他 Rustaceans（這是我們常用稱呼自己取的暱稱）交談並取得協助。</p>
<h3 id="更新與解除安裝"><a class="header" href="#更新與解除安裝">更新與解除安裝</a></h3>
<p>當你透過 <code>rustup</code> 安裝完 Rust 後，要更新到最新版本的方法非常簡單。在你的 shell 中執行以下更新腳本即可：</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>要解除安裝 Rust 與 <code>rustup</code> 的話，則在 shell 輸入以下解除安裝腳本：</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3 id="本地端技術文件"><a class="header" href="#本地端技術文件">本地端技術文件</a></h3>
<p>安裝 Rust 的同時也會包含一份本地的技術文件副本，讓你可以離線閱讀。執行 <code>rustup doc</code> 就可以用你的瀏覽器開啟本地文件。</p>
<p>每當有任何型別或函式出現而你卻不清楚如何使用時，你就可以閱讀應用程式介面（API）技術文件來理解！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>現在你已經安裝好 Rust，是時候開始寫你的第一支 Rust 程式。當我們學習一門新的語言時，有一個習慣是寫一支印出「Hello, world!」到螢幕上的小程式，此章節將教你做一樣的事！</p>
<blockquote>
<p>注意：本書將假設你已經知道命令列最基本的使用方法。Rust 對於你的編輯器、工具以及程式碼位於何處沒有特殊的要求，所以如果你更傾向於使用整合開發環境（IDE）的話，請儘管使用你最愛的 IDE。許多 IDE 都已經針對 Rust 提供某種程度的支援，請查看你所使用的 IDE 技術文件以瞭解詳情。Rust 團隊正透過 <code>rust-analyzer</code> 積極提升 IDE 的支援，請查 <a href="appendix-04-useful-development-tools.html">附錄 D</a><!-- ignore --> 來了解更多細節。</p>
</blockquote>
<h3 id="建立專案目錄"><a class="header" href="#建立專案目錄">建立專案目錄</a></h3>
<p>你將先建立一個目錄來儲存你的 Rust 程式碼。程式碼位於何處並不重要，但為了能好好練習書中的範例和專案，我們建議你可以在你的 home 目錄建立一個 <em>projects</em> 目錄然後將你所有的專案保存在此。</p>
<p>請開啟終端機然後輸入以下命令來建立 <em>projects</em> 目錄和另一個在 <em>projects</em> 目錄底下的真正要寫「Hello, world!」專案的目錄。</p>
<p>對於 Linux、macOS 和 Windows 的 PowerShell，請輸入：</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>對於 Windows CMD，請輸入：</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3 id="編寫並執行-rust-程式"><a class="header" href="#編寫並執行-rust-程式">編寫並執行 Rust 程式</a></h3>
<p>接著，請產生一個全新原始碼檔案並命名為 <em>main.rs</em>。Rust 的文件檔案都會以 <em>.rs</em> 副檔名稱作為結尾。如果你用到不只一個單字的話，慣例上是用底線區隔開來。比方說，請使用 <em>hello_world.rs</em> 而不是 <em>helloworld.rs</em>。</p>
<p>現在請開啟 <em>main.rs</em> 檔案然而後輸入範例 1-1 中的程式碼。</p>
<p><span class="filename">檔案名稱：main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 1-1：印出「Hello, world!」的程式</span></p>
<p>儲存檔案然後回到你的專案目錄底下 <em>~/projects/hello_world</em>。在 Linux 或 macOS 上，請輸入以下命令來編譯並執行檔案：</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>在 Windows 上則輸入 <code>.\main.exe</code> 而非 <code>./main</code>：</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>不管你的作業系統為何，終端機上應該都會出現 <code>Hello, world!</code>。如果你沒有看到，可以回到安裝章節中的<a href="ch01-01-installation.html#%E7%96%91%E9%9B%A3%E6%8E%92%E9%99%A4">「疑難排除」</a><!-- ignore -->尋求協助。</p>
<p>如果 <code>Hello, world!</code> 有印出來，那麼恭喜你！你正式寫了一支 Rust 程式，所以你也正式成為 Rust 開發者了——歡迎加入！</p>
<h3 id="分析這支-rust-程式"><a class="header" href="#分析這支-rust-程式">分析這支 Rust 程式</a></h3>
<p>讓我們來仔細瞧瞧你的「Hello, world!」程式。這是第一塊拼圖：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>這幾行定義了一個 <code>main</code> 函式。<code>main</code> 是一個特別的函式：它是每個可執行的 Rust 程式永遠第一個執行的程式碼。第一行宣告了一個函式 <code>main</code>，它沒有參數也不回傳任何東西。如果有參數的話，它們會被加進括號 <code>()</code> 內。</p>
<p>函式本體被囊括在大括號 <code>{}</code> 內，Rust 要求所有函式都用大括號包起來。一般來說，良好的程式碼風格會要求將前大括號置於宣告函式的同一行，並用一個空格區隔開來。</p>
<blockquote>
<p>如果你想要在不同 Rust 專案之間統一標準風格的話，<code>rustfmt</code> 可以格式化你的程式成特定的風格（更多 <code>rustfmt</code> 資訊請詳見<a href="appendix-04-useful-development-tools.html">附錄 D</a><!-- ignore -->）。Rust 團隊已經將此工具納入標準 Rust 發行版中，就像 <code>rustc</code> 一樣，它應該已經安裝到你的電腦上了！</p>
</blockquote>
<p>在 <code>main</code> 函式本體中有以下程式碼：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>此行負責了整支程式要做的事：它將文字顯示在螢幕上。這邊有四個細節要注意。</p>
<p>首先，Rust 的排版風格是 4 個空格而非一個 tab。</p>
<p>第二，<code>println!</code> 會呼叫一支 Rust 巨集（macro）。如果是呼叫函式的話，那則會是 <code>println</code>（去掉 <code>!</code>）。我們會在第十九章討論更多巨集的細節。現在你只需要知道使用 <code>!</code> 代表呼叫一支巨集而非一個正常的函式，且該巨集遵守的規則不全都和函式一樣。</p>
<p>第三，<code>&quot;Hello, world!&quot;</code> 是一個字串，我們將此字串作為引數傳遞給 <code>println!</code>，然後該字串就會被顯示到螢幕上。</p>
<p>第四，我們用分號（<code>;</code>）作為該行結尾，代表此表達式的結束和下一個表達式的開始。多數的 Rust 程式碼都以分號做結尾。</p>
<h3 id="編譯和執行是不同的步驟"><a class="header" href="#編譯和執行是不同的步驟">編譯和執行是不同的步驟</a></h3>
<p>你剛剛執行了一個新建立的程式，讓我們來檢查過程中的每一個步驟吧。</p>
<p>在你執行一支 Rust 程式前，你必須用 Rust 編譯器來編譯它，也就是輸入 <code>rustc</code> 命令然後加上你的原始檔案，像這樣子：</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>如果你已經有 C 或 C++ 的背景，你應該就會發現這和 <code>gcc</code> 或 <code>clang</code> 非常相似。編譯成功後，Rust 編譯器會輸出一個二進制執行檔（binary executable）。</p>
<p>在 Linux、macOS 和 Windows 上的 PowerShell，你可以在你的 shell 輸入 <code>ls</code> 來查看你的執行檔：</p>
<pre><code class="language-console">$ ls
main  main.rs
</code></pre>
<p>在 Linux 和 macOS，你會看到兩個檔案。而在 Windows 上的 PowerShell，你會和使用 CMD 一樣看到三個檔案。在 Windows 上的 CMD，你需要輸入：</p>
<pre><code class="language-cmd">&gt; dir /B %= /B 選項代表只顯示檔案名稱 =%
main.exe
main.pdb
main.rs
</code></pre>
<p>這顯示了副檔名為 <em>.rs</em>  的原始碼檔案、執行檔（在 Windows 上為 <em>main.exe</em>；其他則為 <em>main</em>），然後在 Windows 上會再出現一個副檔名為 <em>.pdb</em> 的除錯資訊文件。在這裡，你就可以像這樣執行 <em>main</em> 或 <em>main.exe</em> 檔案：</p>
<pre><code class="language-console">$ ./main # 在 Windows 上則是 .\main.exe
</code></pre>
<p>如果你的 <em>main.rs</em> 正是你的「Hello, world!」程式，這命令就會顯示 <code>Hello, world!</code> 到你的終端機。</p>
<p>如果你比較熟悉動態語言，像是 Ruby、Python 或 JavaScript，你可能會比較不習慣將編譯與執行程式分為兩個不同的步驟。Rust 是一門<strong>預先編譯</strong>（ahead-of-time compiled）的語言，代表你可以編譯完成後將執行檔送到其他地方，然後他們就算沒有安裝 Rust 一樣可以執行起來。但如果你給某個人 <em>.rb</em>、<em>.py</em> 或 <em>.js</em> 檔案，他們就需要 Ruby、Python 或 Javascript 分別都有安裝好。當然你在這些語言只需要一行命令就可以執行，在語言設計中這一切都只是取捨。</p>
<p>在簡單的程式使用 <code>rustc</code> 來編譯不會有什麼問題，但當你的專案成長時，你將會需要管理所有選擇並讓程式碼易於分享。接下來我們將介紹 Cargo 這項工具給你，它將協助你寫出真正的 Rust 程式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo 是 Rust 的建構系統與套件管理工具。大部分的 Rustaceans 都會用此工具來管理他們的專案，因為 Cargo 能幫你處理很多任務，像是建構你的程式碼、下載你程式碼所需要的依賴函式庫並建構它們。我們常簡稱程式碼所需要用到的函式庫為<strong>依賴（dependencies）</strong>。</p>
<p>簡單的 Rust 程式像是我們目前所寫的不會有任何依賴。當我們用 Cargo 建構「Hello, world!」專案時，Cargo 只會用到建構程式碼的那部分。隨著你寫的 Rust 程式越來越複雜，你將會加入一些依賴函式庫來幫助你。而如果你使用 Cargo 的話，加入這些依賴就會簡單很多。</p>
<p>既然大多數的 Rust 專案都是用 Cargo，所以接下來本書也將假設你也使用 Cargo。Cargo 在你使用<a href="ch01-01-installation.html#installation">「安裝教學」</a><!-- ignore -->的官方安裝連結來安裝 Rust 時就已經連同安裝好了。如果你是用其他方式下載 Rust 的話，想要檢查 Cargo 有沒有下載好可以透過你的終端機輸入：</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>如果你有看到版本號，那就代表你有安裝了！如果你看到錯誤訊息，像是 <code>command not found</code>，請查看你的安裝辦法的技術文件，尋找如何額外下載 Cargo。</p>
<h3 id="使用-cargo-建立專案"><a class="header" href="#使用-cargo-建立專案">使用 Cargo 建立專案</a></h3>
<p>讓我們來用 Cargo 建立一個專案，並來比較它和我們原本的「Hello, world!」專案有什麼差別。請回到你的 <em>projects</em>  目錄（或者任何你決定存放程式碼的地方），然後在任何作業系統上輸入：</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>第一道命令會建立一個新的目錄與專案叫做 <em>hello_cargo</em>。我們將我們的專案命名為 <em>hello_cargo</em>，然後 Cargo 就會產生相同名稱的目錄並產生所需的檔案。</p>
<p>進入 <em>hello_cargo</em> 然後顯示檔案的話，你會看到 Cargo 產生了兩個檔案和一個目錄： <em>Cargo.toml</em> 檔案以及一個 <em>src</em> 目錄，其內包含一個 <em>main.rs</em> 檔案。</p>
<p>它還會初始化成一個新的 Git repository 並附上 <em>.gitignore</em> 檔案。如果已經在 Git repository 內的話，執行 <code>cargo new</code> 則不會產生 Git 的檔案。你可以用 <code>cargo new --vcs=git</code> 覆寫這項行為。</p>
<blockquote>
<p>注意：Git 是一個常見的版本控制系統。你可以加上 <code>--vcs</code> 來變更 <code>cargo new</code> 去使用不同的版本控制系統，或是不用任何版本控制系統。請執行 <code>cargo new --help</code> 來查看更多可使用的選項。</p>
</blockquote>
<p>請用任何你喜歡的編輯器開啟 <em>Cargo.toml</em>，它應該會看起來和範例 1-2 差不多。</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><span class="caption">範例 1-2：用 <code>cargo new</code> 產生的 <em>Cargo.toml</em></span></p>
<p>此檔案用的是 <a href="https://toml.io"><em>TOML</em></a><!-- ignore -->（<em>Tom’s Obvious, Minimal Language</em>）格式，這是 Cargo 配置文件的格式。</p>
<p>第一行的 <code>[package]</code> 是一個段落（section）標題，說明以下的陳述式（statement）會配置這個套件。隨著我們加入更多資訊到此文件，我們也會加上更多段落。</p>
<p>接下來三行就是 Cargo 編譯你的程式所需的配置資訊：名稱、版本、誰寫的以及哪個 Rust <code>edition</code> 會用到。我們會在<a href="appendix-05-editions.html">附錄 E</a><!-- ignore --> 介紹什麼是 <code>edition</code>。</p>
<p>最後一行 <code>[dependencies]</code> 是用來列出你的專案會用到哪些依賴的段落。在 Rust 中，程式碼套件會被稱為 <em>crates</em>。我們在此專案還不需要任何其他 crate。但是我們會在第二章開始用到，屆時我們會再來介紹。</p>
<p>現在請開啟 <em>src/main.rs</em> 來看看：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 預設會為你產生一個「Hello, world!」程式，就像我們範例 1-1 寫的一樣！目前我們寫的專案與 Cargo 產生的程式碼不同的地方在於 Cargo 將程式碼放在 <em>src</em> 目錄底下，而且我們還有一個 <em>Cargo.toml</em> 配置文件在根目錄。</p>
<p>Cargo 預期你的原始檔案都會放在 <em>src</em> 目錄底下。專案的根目錄是用來放 README 檔案、授權條款、配置檔案以及其他與你的程式碼不相關的檔案。使用 Cargo 能夠幫助你組織你的專案，讓一切井然有序。</p>
<p>如果你的專案還沒開始使用 Cargo 的話，像是我們剛剛寫的「Hello, world!」專案，你只要將程式碼移入 <em>src</em> 然後產生正確的 <em>Cargo.toml</em> 檔案，就可以將它轉換成能夠使用 Cargo 的專案。</p>
<h3 id="建構並執行-cargo-專案"><a class="header" href="#建構並執行-cargo-專案">建構並執行 Cargo 專案</a></h3>
<p>現在讓我們看看用 Cargo 產生的「Hello, world!」程式在建構和執行時有什麼差別！請在你的 <em>hello_cargo</em> 目錄下輸入以下命令來建構專案：</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>此命令會產生一個執行檔 <em>target/debug/hello_cargo</em>（在 Windows 上則是 <em>target\debug\hello_cargo.exe</em>），而不是在你目前的目錄。因為預設的建構會是 debug build，Cargo 會將執行檔放進名為 <em>debug</em> 的目錄。你可以用以下命令運行執行檔：</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # 在 Windows 上的話則是 .\target\debug\hello_cargo.exe
Hello, world!
</code></pre>
<p>如果一切順利，<code>Hello, world!</code> 就會顯示在終端機上。第一次執行 <code>cargo build</code> 的話，還會在根目錄產生另一個新檔案：<em>Cargo.lock</em>。此檔案是用來追蹤依賴函式庫的確切版本。不過此專案沒有任何依賴，所以目前這個檔案看起來內容會有點少。你不會需要去手動更改此檔案，Cargo 會幫你管理這個檔案的內容。</p>
<p>我們剛用 <code>cargo build</code> 建構完專案並用 <code>./target/debug/hello_cargo</code> 執行它。不過我們其實也可以只用一道命令 <code>cargo run</code> 來編譯程式碼並接著運行產生的執行檔：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>使用 <code>cargo run</code> 通常比執行 <code>cargo build</code> 然後使用執行檔的完整路徑還要方便，所以多數開發者通常都直接使用 <code>cargo run</code>。</p>
<p>請注意到這次輸出的結果我們沒有看到 Cargo 有在編譯 <code>hello_cargo</code> 的跡象，這是因為 Cargo 可以知道檔案完全沒被更改過，所以它不用重新建構可以選擇直接執行執行檔。如果你有變更你的原始碼的話，Cargo 才會在執行前重新建構專案，你才會看到這樣的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo 還提供一道命令 <code>cargo check</code>，此命令會快速檢查你的程式碼，確保它能編譯通過但不會產生執行檔：</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>為何你會不想要產生執行檔呢？這是因為 <code>cargo check</code> 省略了產生執行檔的步驟，所以它執行的速度比 <code>cargo build</code> 還來的快。如果你在寫程式時需要持續檢查的話，使用 <code>cargo check</code> 可以加快整體過程，讓你知道你的專案是否能編譯！所以許多 Rustaceans 都會在寫程式的過程中時不時執行 <code>cargo check</code> 來確保它能編譯。最後當他們準備好要使用執行檔時，才會用 <code>cargo build</code>。</p>
<p>讓我們來回顧我們目前學到的 Cargo 內容：</p>
<ul>
<li>我們可以用 <code>cargo new</code> 產生專案。</li>
<li>我們可以用 <code>cargo build</code> 建構專案。</li>
<li>我們可以用 <code>cargo run</code> 同時建構並執行專案。</li>
<li>我們可以用 <code>cargo check</code> 建構專案來檢查錯誤，但不會產生執行檔。</li>
<li>Cargo 會儲存建構結果在 <em>target/debug</em> 目錄底下，而不是放在與我們程式碼相同的目錄。</li>
</ul>
<p>使用 Cargo 還有一項好處是在任何作業系統所使用的命令都是相同的，所以到這邊開始我們不再需要特別提供 Linux 和 macOS 相對於 Windows 不同的特殊命令。</p>
<h3 id="建構發佈版本release"><a class="header" href="#建構發佈版本release">建構發佈版本（Release）</a></h3>
<p>當你的專案正式準備好要發佈的話，你可以使用 <code>cargo build --release</code> 來最佳化編譯結果。此命令會產生執行檔到 <em>target/release</em> 而不是 <em>target/debug</em>。最佳化可以讓你的 Rust 程式碼跑得更快，不過也會讓編譯的時間變得更久。這也是為何 Cargo 提供兩種不同的設定檔（profile）：一個用來作為開發使用，讓你可以快速並經常重新建構；另一個用來最終產生你要給使用者運行的程式用，它通常不會需要重新建構且能盡所能地跑得越快越好。如果你要做基準化分析（benchmarking）來檢測程式運行時間的話，請確認執行的是 <code>cargo build --release</code> 並使用 <em>target/release</em> 底下的執行檔做檢測。</p>
<h3 id="將-cargo-視為常規"><a class="header" href="#將-cargo-視為常規">將 Cargo 視為常規</a></h3>
<p>雖然在簡單的專案下，Cargo 比起只使用 <code>rustc</code> 的確沒辦法突顯出什麼價值。但是當你的程式變得越來越複雜時，它將證明它的用途。當程式成長到好幾個檔案或需要依賴項目時，讓 Cargo 來協調你的專案會來的簡單許多。</p>
<p>儘管 <code>hello_cargo</code> 是個小專案，但它使用了你未來的 Rust 生涯中真實情況下會用到的工具。事實上，所有存在的專案，你幾乎都可以用以下命令完成：使用 Git 下載專案、移至專案目錄然後建構完成。</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>有關 Cargo 的更多資訊，請查看它的<a href="https://doc.rust-lang.org/cargo/">技術文件</a>。</p>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>你已經完成你的 Rust 旅途的第一步了！在本章節你學到了：</p>
<ul>
<li>使用 <code>rustup</code> 安裝最新穩定版 Rust</li>
<li>更新到最新 Rust 版本</li>
<li>開啟本地端安裝的技術文件</li>
<li>直接使用 <code>rustup</code> 編寫並執行一支「Hello, world!」程式</li>
<li>使用 Cargo 建立並執行一個新專案</li>
</ul>
<p>接下來是時候來建立一個更實際的程式來熟悉 Rust 程式碼的讀寫了。所以在第二章我們將寫出一支猜謎遊戲的程式。如果你想直接學習 Rust 的常見程式設計概念的話，你可直接閱讀第三章，之後再回來看第二章。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="設計猜謎遊戲程式"><a class="header" href="#設計猜謎遊戲程式">設計猜謎遊戲程式</a></h1>
<p>讓我們親自動手一同完成一項專案來開始上手 Rust 吧！本章節會介紹一些常見 Rust 概念，展示如何在實際程式中使用它們。你會學到 <code>let</code>、<code>match</code>、方法、關聯函式、外部 crate 以及更多等等！我們會在之後的章節更詳細地探討這些概念。在本章中，你會練習到基礎概念。</p>
<p>我們會實作個經典新手程式問題：猜謎遊戲。它的運作方式如下：程式會產生 1 到 100 之間的隨機整數。接著它會通知玩家猜一個數字。在輸入猜測數字之後，程式會回應猜測的數字太低或太高。如果猜對的話，遊戲就會顯示祝賀訊息並關閉。</p>
<h2 id="設置新專案"><a class="header" href="#設置新專案">設置新專案</a></h2>
<p>要設置新專案的話，前往你在第一章建立的 <em>projects</em> 目錄並使用 Cargo 建立一個新的專案，如下所示：</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>第一道命令 <code>cargo new</code> 會接收專案名稱（<code>guessing_game</code>）作為引數（argument）。第二道命令會將目錄移至新專案中。</p>
<p>檢查看看產生的 <em>Cargo.toml</em> 檔案：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>如同你在第一章看到的，<code>cargo new</code> 會產生一支「Hello, world!」程式。請檢查 <em>src/main.rs</em> 檔案：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>現在讓我們用 <code>cargo run</code> 命令同時完成編譯與執行「Hello, world!」程式：</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p><code>run</code> 命令在你需要對專案快速疊代時會很有用，我們要寫的遊戲也是如此，在繼續下一步之前可以快速測試每一步。</p>
<p>請重新開啟 <em>src/main.rs</em> 檔案。你要寫的程式碼全都會位於此檔案中。</p>
<h2 id="處理猜測"><a class="header" href="#處理猜測">處理猜測</a></h2>
<p>猜謎遊戲的第一個部分會要求使用者輸入數字、處理該輸入，並檢查該輸入是否符合格式。所以我們要先讓玩家能夠輸入猜測數字，請輸入範例 2-1 的程式碼至 <em>src/main.rs</em>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;請猜測一個數字！&quot;);

    println!(&quot;請輸入你的猜測數字。&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;讀取該行失敗&quot;);

    println!(&quot;你的猜測數字：{guess}&quot;);
}
</code></pre>
<p><span class="caption">範例 2-1：取得使用者的猜測數字並顯示出來的程式</span></p>
<p>這段程式碼包含大量的資訊，所以讓我們一行一行來慢慢看吧。要取得使用者輸入並印出為輸出結果，我們需要將 <code>io</code> 輸入／輸出（input/output）函式庫引入作用域中。 <code>io</code> 函式庫來自標準函式庫（常稱為 <code>std</code>）：</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>在預設情況下，Rust 會將一些在標準函式庫定義的型別引入每個程式的作用域中。這樣的集合稱為 <strong>prelude</strong>，你可以在<a href="https://doc.rust-lang.org/std/prelude/index.html">標準函式庫的技術文件中</a>看到這包含了那些型別。</p>
<p>如果你想使用的型別不在 prelude 的話，你需要顯式（explicit）地使用 <code>use</code> 陳述式（statement）將該型別引入作用域。<code>std::io</code> 函式庫能提供一系列實用的功能，這包含接收使用者輸入的能力。</p>
<p>如同你在第一章所見的，<code>main</code> 函式是程式的入口點（entry point）：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p><code>fn</code> 語法用來宣告新的函式（function），其中括號 <code>()</code> 說明此函式沒有任何參數，然後大括號 <code>{</code> 會作為函式本體的開頭。</p>
<p>同樣如第一章所學的，<code>println!</code> 是個能將字串顯示到螢幕上的巨集：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;請猜測一個數字！&quot;);

    println!(&quot;請輸入你的猜測數字。&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>此程式碼會顯式提示訊息向使用者說明此遊戲該輸入什麼。</p>
<h3 id="透過變數儲存數值"><a class="header" href="#透過變數儲存數值">透過變數儲存數值</a></h3>
<p>接著我們要建立一個<strong>變數</strong>來儲存使用者輸入，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>現在程式變得越來越有趣了！在短短的這行當中有許多事情發生。先注意到我們使用了 <code>let</code> 陳述式建立了一個<strong>變數</strong>（variable）。以下是另一個例子：</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<p>這行建立了一個新的變數叫做 <code>apple</code> 並將數值 5 綁定給它。在 Rust 中，變數預設是不可變的（immutable），也就是一旦我們給予變數一個數值，該數值就不會被改變。我們會在第三章的<a href="ch03-01-variables-and-mutability.html#variables-and-mutability">「變數與可變性」</a><!-- ignore -->段落討論此概念。要讓變數成為可變的話，我們可以在變數名稱前面加上 <code>mut</code>：</p>
<pre><code class="language-rust ignore">let apple = 5; // 不可變的
let mut banana = 5; // 可變的
</code></pre>
<blockquote>
<p>注意：<code>//</code> 語法用來產生註解（comment）直到該行結束。Rust 會忽略註解中所有內容，我們會在<a href="ch03-04-comments.html">第三章</a><!-- ignore -->進一步討論到。</p>
</blockquote>
<p>讓我們回到猜謎遊戲程式，你現在就知道 <code>let mut guess</code> 會產生一個可變變數叫做 <code>guess</code>。等號（<code>=</code>）告訴 Rust 我們現在想綁定某個值給變數，而等號的另一邊就是要綁定給 <code>guess</code> 的數值，也就是呼叫 <code>String::new</code> 的結果，這是一個回傳新的 <code>String</code> 實例（instance）的函式。<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore --> 是個標準函式庫提供的字串型別，這是可增長的 UTF-8 編碼文字。</p>
<p><code>::new</code> 中的 <code>::</code> 語法代表 <code>new</code> 是 <code>String</code> 型別的關聯函式。<strong>關聯函式（associated function）</strong> 是針對型別實作的函式，在此例中就是 <code>String</code>。此 <code>new</code> 函式建立一個新的空字串。你會在許多型別中找到 <code>new</code> 函式，因為這是函式建立某種新數值的常見名稱。</p>
<p>總結來說， <code>let mut guess = String::new();</code> 這行會建立一個可變變數，且目前會得到一個新的空 <code>String</code> 實例。</p>
<h3 id="取得使用者輸入"><a class="header" href="#取得使用者輸入">取得使用者輸入</a></h3>
<p>回想一下我們在程式第一行透過 <code>use std::io;</code> 來包含標準函式庫中的輸入／輸出功能。現在我們要從 <code>io</code> 模組（module）呼叫 <code>stdin</code> 函式，讓我們能處理使用者的輸入：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>如果我們沒有匯入 <code>io</code> 函式庫，也就是將 <code>use std::io</code> 這行置於程式最一開始的位置的話，我們還是能直接寫出 <code>std::io::stdin</code> 來呼叫函式。<code>stdin</code> 函式會回傳一個 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore --> 實例，這是代表終端機標準輸入控制代碼（handle）的型別。</p>
<p>接下來 <code>.read_line(&amp;mut guess)</code> 這行會對標準輸入控制代碼呼叫 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> 方法（method）來取得使用者的輸入。我們還傳遞了 <code>&amp;mut guess</code> 作為引數（argument）給 <code>read_line</code>，來告訴它使用者輸入時該儲存什麼字串。整個 <code>read_line</code> 的任務就是取得使用者在標準輸入寫入的任何內容，並加入到字串中（不會覆寫原有內容），使得我們可以傳遞該字串作為引數。字串引數需要是可變的，這樣該方法才能變更字串的內容。</p>
<p><code>&amp;</code> 說明此引數是個<strong>參考（reference）</strong>，這讓程式中的多個部分可以取得此資料內容，但不需要每次都得複製資料到記憶體中。參考是個複雜的概念，而 Rust 其中一項主要優勢就是能夠輕鬆又安全地使用參考。你現在還不用知道一堆細節才能完成程式。現在你只需要知道參考和變數一樣，預設都是不可變的。因此你必須寫 <code>&amp;mut guess</code> 而不是 <code>&amp;guess</code> 才能讓它成為可變的。（第四章會再全面詳細解釋參考。）</p>
<h3 id="使用-result-處理可能的錯誤"><a class="header" href="#使用-result-處理可能的錯誤">使用 <code>Result</code> 處理可能的錯誤</a></h3>
<p>我們要繼續處理這段程式碼。我們已經討論到第三行了，不過這仍然是這段單一邏輯程式碼中的一部分。接下來的部分是此方法：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;讀取該行失敗&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">}
</span></code></pre>
<p>我們可以將程式碼寫成這樣：</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;讀取行數失敗&quot;);
</code></pre>
<p>但是這麼長通常會很難閱讀，最好還是能夠分段。當你透過 <code>.method_name()</code> 語法呼叫方法時，通常換行來寫並加上縮排，來拆開一串很長的程式碼會比較好閱讀。現在讓我們來討論這行在做什麼。</p>
<p>如稍早提過的，<code>read_line</code> 會將使用者任何輸入轉換至我們傳入的字串，但它還回傳了一個 <code>Result</code> 數值。<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore --> 是種<a href="ch06-00-enums.html"><strong>枚舉（enumerations）</strong></a><!-- ignore -->，常稱為 <em>enums</em>。枚舉是種可能有數種狀態其中之一的型別，而每種可能的狀態我們稱之為枚舉的<strong>變體（variants）</strong>。</p>
<p><a href="ch06-00-enums.html">第六章</a><!-- ignore -->會更詳細地介紹枚舉，這些 <code>Result</code> 型別的目的是要編碼錯誤處理資訊。</p>
<p><code>Result</code> 的變體有 <code>Ok</code> 和 <code>Err</code>。<code>Ok</code> 變體指的是該動作成功完成，且 <code>Ok</code> 內部會包含成功產生的數值。而 <code>Err</code> 變體代表動作失敗，且 <code>Err</code> 會包含該動作如何與為何會失敗的資訊。</p>
<p><code>Result</code> 型別的數值與任何型別的數值一樣，它們都有定義些方法。<code>Result</code> 的實例有 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code> 方法</a><!-- ignore --> 讓你能呼叫。如果此 <code>Result</code> 實例數值為 <code>Err</code> 的話，<code>expect</code> 會讓程式崩潰並顯示作為引數傳給 <code>expect</code> 的訊息。如果 <code>read_line</code> 回傳 <code>Err</code> 的話，這可能就是從底層作業系統傳來的錯誤結果。如果此 <code>io::Result</code> 實例數值為 <code>Ok</code> 的話，<code>expect</code> 會接收 <code>Ok</code> 的回傳值並只回傳該數值，讓你可以使用。在此例中，數值將為使用者輸入進標準輸入介面的位元組數字。</p>
<p>如果你沒有呼叫 <code>expect</code>，程式仍能編譯，但你會收到一個警告：</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust 警告你沒有使用 <code>read_line</code> 回傳的 <code>Result</code> 數值，這意味著程式沒有處理可能發生的錯誤。</p>
<p>要解決此警告的正確方式是實際進行錯誤處理，但因為我們只想要當問題發生時直接讓程式當掉，所以你可以先使用 <code>expect</code> 就好。你會在<a href="ch09-02-recoverable-errors-with-result.html">第九章</a><!-- ignore -->學到如何從錯誤中恢復。</p>
<h3 id="透過-println-佔位符印出數值"><a class="header" href="#透過-println-佔位符印出數值">透過 <code>println!</code> 佔位符印出數值</a></h3>
<p>在結束大括號之前，目前程式碼中還有一行要來討論：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span>    println!(&quot;你的猜測數字：{guess}&quot;);
<span class="boring">}
</span></code></pre>
<p>此行會印出存有使用者輸入的字串。其中的大括號 <code>{}</code> 是個佔位符（placeholder）：將 <code>{}</code> 想成是個小蟹鉗會夾住某個數值。當要印出變數的數值時，變數名稱可以放進括號內。當要印出表達式運算出的結果時，則先將空括號放進要格式化的字串，然後在字串後用逗號以相同的順序列出要印出的表達式列表。用 <code>println!</code> 同時印出變數與表達式結果的話會如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {x} 而且 y + 2 = {}&quot;, y + 2);
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出 <code>x = 5 而且 y = 12</code>。</p>
<h3 id="測試第一個部分"><a class="header" href="#測試第一個部分">測試第一個部分</a></h3>
<p>讓我們來測試猜謎遊戲中的第一個部分。請使用 <code>cargo run</code> 來執行它：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
請猜測一個數字！
請輸入你的猜測數字。
6
你的猜測數字：6
</code></pre>
<p>到目前為止，遊戲的第一個部分就完成了：我們取得了鍵盤的輸入然後顯示出來。</p>
<h2 id="產生祕密數字"><a class="header" href="#產生祕密數字">產生祕密數字</a></h2>
<p>接下來，我們要產生一個能讓使用者猜看看的祕密數字。祕密數字每次都要不同，這樣遊戲才值得多玩幾次。讓我們使用 1 到 100 之間的隨機數字，這樣遊戲才不會太困難。Rust 的標準函式庫並不包含產生隨機數字的功能。然而，Rust 團隊有提供個 <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>。</p>
<h3 id="使用-crate-來取得更多功能"><a class="header" href="#使用-crate-來取得更多功能">使用 Crate 來取得更多功能</a></h3>
<p>所謂的 crate 是一個 Rust 原始碼檔案的集合。我們正在寫的專案屬於<strong>執行檔（binary）crate</strong>，也就會是個執行檔。而 <code>rand</code> crate 屬於<strong>函式庫（library）crate</strong>，這會包含讓其他程式能夠使用的程式碼。</p>
<p>Cargo 協調外部 crate 的功能正是它的亮點。在我們可以使用 <code>rand</code> 來寫程式碼前，我們需要修改 <em>Cargo.toml</em> 檔案來包含 <code>rand</code> crate 作為依賴函式庫（dependency）。開啟該檔案然後將以下行數加到 Cargo 自動產生的 <code>[dependencies]</code> 標頭（header）段落中最後一行下面。記得確認 <code>rand</code> 指定的版本數字與我們相同，不然此教學的範例程式碼可能不會運行成功：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.8.5&quot;
</code></pre>
<p>在 <em>Cargo.toml</em> 檔案中，標頭以下的所有內容都是該段落的一部分，一直到下個段落出現為止。<code>[dependencies]</code> 段落是告訴 Cargo 此專案要依賴哪些 crate，以及那些 crate 的版本為何。在此例中，我們透過語意化版本 <code>0.8.5</code> 來指定 <code>rand</code> crate。Cargo 能夠理解<a href="https://semver.org/lang/zh-TW/">語意化版本（Semantic Versioning）</a><!-- ignore -->，有時也被稱之為 <em>SemVer</em>，這是一種定義版本數字的標準。數字 <code>0.8.5</code> 其實是 <code>^0.8.5</code> 的縮寫，這代表任何至少爲 <code>0.8.5</code> 且低於 <code>0.9.0</code> 版本。</p>
<p>Cargo 將這些版本提供的公開 API 視爲是與版本 <code>0.8.5</code> 相容的，這樣的規格讓你能在本章節取得最新的 patch 發佈版本程式碼。任何 <code>0.9.0</code> 以上的版本就不會保證提供以下範例所使用的相同 API。</p>
<p>現在，在不改變任何程式碼的情況下，讓我們建構（build）專案吧，如範例 2-2 所示。</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">範例 2-2：在新增 rand crate 作為依賴後，執行 <code>cargo build</code> 的輸出</span></p>
<p>你可能會看到不同的版本數字（但多虧有 SemVer，它們都會與程式碼相容！）和不同的行數（依照作業系統可能會不同）以及每行順序可能會不相同。</p>
<p>當我們匯入了外部依賴，Cargo 會從 <em>registry</em> 取得所有 crate 的最新版本訊息，這是份 <a href="https://crates.io/">Crates.io</a> 的資料副本。Crates.io 是個讓 Rust 生態系統中的每個人都能發佈它們的開源 Rust 專案並讓其他人使用的地方。</p>
<p>在更新 registry 之後，Cargo 會檢查 <code>[dependencies]</code> 段落並下載你還沒有的 crate。在此例中，雖然我們只有列出 <code>rand</code> 作為依賴，但 Cargo 還得下載 <code>rand</code> 所依賴的其他 crate 才能運作。在下載完 crates 之後，Rust 會編譯依賴函式庫以及使用到它們的專案。</p>
<p>如果你立即再次執行 <code>cargo build</code> 且沒有作出任何改變的話，你除了 <code>Finished</code> 這行以外不會在收到任何輸出。Cargo 知道它已經下載並編譯依賴函式庫了，而且你沒有在 <em>Cargo.toml</em> 檔案中再做任何改變。Cargo 也知道你沒有修改任何程式碼，所以也不會再重新編譯它。既然沒事可做，它就只好馬上結束。</p>
<p>如果你開啟 <em>src/main.rs</em> 檔案，加些瑣碎的修改，然後儲存並再次建構的話，你會只看到兩行輸出：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>這幾行表示 Cargo 只更新你對 <em>src/main.rs</em> 檔案的瑣碎修改進行建構。你的依賴沒變，所以 Cargo 知道它可以重複使用已經下載並編譯過的程式碼。</p>
<h4 id="透過-cargolock-檔案確保建構可以重現"><a class="header" href="#透過-cargolock-檔案確保建構可以重現">透過 <em>Cargo.lock</em> 檔案確保建構可以重現</a></h4>
<p>Cargo 有個機制能確保任何人或你在任何時候重新建構程式碼時，都能產生相同結果。舉例來說，要是下一週 <code>rand</code> crate 發佈了版本 0.8.6 且該版本包含重大程式錯誤更新，卻也有個會破壞你的程式碼的迴歸錯誤（regression），這時會發生什麼事呢？為了處理這樣的狀況，Rust 會在你第一次執行 <code>cargo build</code> 時建立個 <em>Cargo.lock</em> 檔案，它會位於 <em>guessing_game</em> 目錄中。</p>
<p>當你第一次建構專案時，Cargo 會決定出符合情境的依賴函式庫版本，然後將它們寫入 <em>Cargo.lock</em> 檔案中。當你在未來建構專案時，Cargo 會看到 <em>Cargo.lock</em> 的存在並使用其指定的版本，而非重新再次決定該用哪些版本。這讓你有個能自動重現的建構方案。換句話說，你的專案仍會繼續使用 0.8.5 直到你顯式升級為止，這都多虧了 <em>Cargo.lock</em> 檔案。由於 <em>Cargo.lock</em> 對於重現建構非常重要，所以通常它會和其他程式碼一同上傳到專案的版本控制源頭。</p>
<h4 id="升級-crate-來取得新版本"><a class="header" href="#升級-crate-來取得新版本">升級 Crate 來取得新版本</a></h4>
<p>當你<strong>真的</strong>想升級 crate 時，Cargo 有提供個命令 <code>update</code>，這會忽略 <em>Cargo.lock</em> 檔案並依據 <em>Cargo.toml</em> 指定的規格決定所有合適的最新版本。如果成功的話，Cargo 會將這些版本寫入 <em>Cargo.lock</em> 檔案中。不然的話，Cargo 預設只會尋找大於 0.8.5 且小於 0.9.0 的版本。如果 <code>rand</code> 有發佈兩個新版本 0.8.6 和 0.9.0，當你輸入 <code>cargo update</code> 時，你會看到以下結果：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -&gt; v0.8.6
</code></pre>
<p>Cargo 會忽略 0.9.0 的發布版本。此時你也會注意到 <em>Cargo.lock</em> 檔案中的變更，指出你現在使用的 <code>rand</code> crate 版本為 0.8.6。如果你想使用 <code>rand</code> 版本 0.9.0 或任何版本 0.9.<em>x</em> 系列更新 <em>Cargo.toml</em> 檔案，如以下所示：</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.9.0&quot;
</code></pre>
<p>下次你執行 <code>cargo build</code> 時，Cargo 將會更新 crate registry，並依據你指定的新版本來重新評估 <code>rand</code> 的確切版本。</p>
<p><a href="http://doc.crates.io">Cargo</a><!-- ignore --> 與<a href="http://doc.crates.io/crates-io.html">其生態系統</a><!-- ignore -->還有很多內容可以介紹，我們會在第十四章討論它們。但現在你只需要知道這些就好。Cargo 讓重複使用函式庫變得非常容易，讓 Rustaceans 可以組合許多套件寫出簡潔的專案。</p>
<h3 id="產生隨機數字"><a class="header" href="#產生隨機數字">產生隨機數字</a></h3>
<p>讓我們開始使用 <code>rand</code> 產生數字來猜吧！下一步是更新 <em>src/main.rs</em>，如範例 2-3 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;請猜測一個數字！&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!(&quot;祕密數字為：{secret_number}&quot;);

    println!(&quot;請輸入你的猜測數字。&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;讀取該行失敗&quot;);

    println!(&quot;你的猜測數字：{guess}&quot;);
}
</code></pre>
<p><span class="caption">範例 2-3：新增程式碼來產生隨機數字</span></p>
<p>首先我們加上 <code>use</code> 這行：<code>use rand::Rng;</code>。<code>Rng</code> 特徵（trait）定義了隨機數字產生器實作的方法，所以此特徵必須引入作用域，我們才能使用這些方法。第十章會詳細解釋特徵。</p>
<p>接著，我們在中間加上兩行。我們在第一行呼叫的 <code>rand::thread_rng</code> 函式會回傳我們要使用的特定隨機數字產生器：這會位於目前執行緒（thread）並由作業系統提供種子（seed）。然後我們對隨機數字產生器呼叫 <code>gen_range</code> 方法。此方法由 <code>Rng</code> 特徵所定義，而我們則是用 <code>use rand::Rng;</code> 陳述式將此特徵引入作用域中。<code>gen_range</code> 方法接收一個範圍表達式作為引數並產生一個在此範圍之間的隨機數字。我們所使用的範圍表達式的格式爲 <code>start..=end</code>。這個範圍會包含下限和上限，所以我們需要指定 <code>1..=100</code> 來索取 1 到 100 之間的數字。</p>
<blockquote>
<p>注意：你不可能憑空就知道該使用 crate 中的哪些特徵或是呼叫哪些方法與函式，所以每個 crate 都會提供技術文件解釋如何使用它。Cargo 另一大亮點就是執行 <code>cargo doc --open</code> 命令就能建構所有本地端依賴函式庫的技術文件，並在你的瀏覽器中開啟。舉例來說，如果你對 <code>rand</code> crate 的其他功能有興趣的話，你可以執行 <code>cargo doc --open</code> 然後點擊左側邊欄的 <code>rand</code>。</p>
</blockquote>
<p>第二行會印出祕密數字，這在開發程式時能用來作測試，不過在最終版本我們會刪除它。如果在遊戲一開始程式就印出答案的話跟本就沒有玩的必要了！</p>
<p>請嘗試執行程式幾次：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
請猜測一個數字！
祕密數字為：7
請輸入你的猜測數字。
4
你的猜測數字：4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
請猜測一個數字！
祕密數字為：83
請輸入你的猜測數字。
5
你的猜測數字：5
</code></pre>
<p>你應該會得到不同的隨機數字，而且它們都應該要在 1 到 100 的範圍內。做得好！</p>
<h2 id="將猜測的數字與祕密數字做比較"><a class="header" href="#將猜測的數字與祕密數字做比較">將猜測的數字與祕密數字做比較</a></h2>
<p>現在我們有使用者的輸入與隨機數字，我們可以來比較它們了。這步驟顯示在範例 2-4。注意此程式碼還無法編譯，我們會解釋為什麼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --省略--
<span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span>
    println!(&quot;你的猜測數字：{guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;太小了！&quot;),
        Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
        Ordering::Equal =&gt; println!(&quot;獲勝！&quot;),
    }
}
</code></pre>
<p><span class="caption">範例 2-4：處理比較兩個數字後的可能數值</span></p>
<p>首先我們加上另一個 <code>use</code> 陳述式，這將 <code>std::cmp::Ordering</code> 型別從標準函式庫引入作用域中。<code>Ordering</code> 是另一個枚舉，擁有的變體為 <code>Less</code>、<code>Greater</code> 與 <code>Equal</code>。這些是當你比較兩個數值時的三種可能結果。</p>
<p>然後我們在底下加上五行程式碼來使用 <code>Ordering</code> 型別。<code>cmp</code> 方法會比較兩個數值，並能在任何可以比較的數值中進行呼叫。其參考一個任何你想做比較的數值，在此例中就是將 <code>guess</code> 與 <code>secret_number</code> 做比較。然後它會回傳我們透過 <code>use</code> 陳述式引入作用域的 <code>Ordering</code> 枚舉其中一個變體。我們使用 <a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> 表達式來依據透過 <code>guess</code> 與 <code>secret_number</code> 呼叫 <code>cmp</code> 回傳的 <code>Ordering</code> 變體來決定下一步要做什麼。</p>
<p><code>match</code> 表達式由<strong>分支</strong>（arms）所組成。分支包含一個能被配對的<strong>模式</strong>（pattern）以及對應的程式碼，這在當 <code>match</code> 的數值能與該分支的模式配對時就能執行。Rust 會用 <code>match</code> 得到的數值依序遍歷每個分支中的模式。<code>match</code> 結構與模式是 Rust 中非常強大的特色，能讓你表達各種程式碼可能會遇上的情形，並確保你有將它們全部處理完。這些特色功能會在第六章與第十八章分別討論其細節。</p>
<p>讓我們看看在此例中使用的 <code>match</code> 表達式。假設使用者猜測的數字是 50 而這次隨機產生的祕密數字是 38。</p>
<p>當程式碼比較 50 與 38 時，<code>cmp</code> 方法會回傳 <code>Ordering::Greater</code>，因為 50 大於 38。<code>match</code> 表達式會取得 <code>Ordering::Greater</code> 數值並開始檢查每個分支的模式。它會先查看第一個分支的模式 <code>Ordering::Less</code> 並看出數值 <code>Ordering::Greater</code> 無法與 <code>Ordering::Less</code> 配對，所以它忽略該分支的程式碼，並移到下一個分支。而下個分支的模式 <code>Ordering::Greater</code> 能配對到 <code>Ordering::Greater</code>！所以該分支對應的程式碼就會執行並印出 <code>太大了！</code> 到螢幕上。最後 <code>match</code> 表達式就會在第一次成功配對就結束，所以在此情境中它不需要再查看最後一個分支。</p>
<p>然而範例 2-4 的程式碼還無法編譯，讓我們嘗試看看：</p>
<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
   --&gt; src/main.rs:26:21
    |
26  |     match guess.cmp(&amp;secret_number) {
    |                 --- ^^^^^^^^^^^^^^ expected struct `String`, found integer
    |                 |
    |                 arguments to this function are incorrect
    |
    = note: expected reference `&amp;String`
               found reference `&amp;{integer}`
note: associated function defined here

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game` due to previous error
</code></pre>
<p>錯誤的關鍵表示<strong>型別無法配對（mismatched types）</strong>。Rust 有個強力的靜態型別系統，但它也提供了型別推斷。當我們寫 <code>let mut guess = String::new()</code> 時，Rust 能夠推斷出 <code>guess</code> 應該要是 <code>String</code> 讓我們不必親自寫出型別。另一方面，<code>secret_number</code> 則是個數字型別。以下是一些在 Rust 中可以包含數字 1 到 100 的數字型別：32 位元數字 <code>i32</code>、非帶號（unsigned）32 位元數字 <code>u32</code>、64 位元數字 <code>i64</code>，以及更多等等。Rust 預設的數字型別為 <code>i32</code>，這就是 <code>secret_number</code> 的型別，除非你特地加上型別詮釋，Rust 才會推斷成不同的數字型別。此錯誤原因是因為 Rust 無法比較將字串與數字型別做比較。</p>
<p>所以我們要將程式從輸入讀取的 <code>String</code> 轉換成真正的數字型別，讓我們可以將其與祕密數字做比較。我們可以在 <code>main</code> 函式本體加上另一行程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span>    // --省略--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;讀取該行失敗&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;請輸入一個數字！&quot;);

    println!(&quot;你的猜測數字：{guess}&quot;);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;太小了！&quot;),
        Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
        Ordering::Equal =&gt; println!(&quot;獲勝！&quot;),
    }
<span class="boring">}
</span></code></pre>
<p>這行程式碼就是：</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;請輸入一個數字！&quot;);
</code></pre>
<p>我們建立了一個變數叫做 <code>guess</code>。小等一下，程式不是已經有個變數叫做 <code>guess</code>了嗎？的確是的，但 Rust 允許我們遮蔽之前的 <code>guess</code> 數值成新的數值。<strong>遮蔽</strong>（Shadowing）讓我們可以重複使用 <code>guess</code> 變數名稱，而不必強迫我們得建立兩個不同的變數，舉例來說像是 <code>guess_str</code> 和 <code>guess</code>。我們會在<a href="ch03-01-variables-and-mutability.html#shadowing">第三章</a><!-- ignore -->更詳細地解釋此概念，現在這邊只需要知道這常拿來將一個數值的型別轉換成另一個型別。</p>
<p>我們將此新的變數綁定給 <code>guess.trim().parse()</code> 表達式。表達式中的 <code>guess</code> 指的是原本儲存字串輸入的 <code>guess</code>。<code>String</code> 中的 <code>trim</code> 方法會去除開頭與結尾的任何空白字元，我們一定要這樣做才能將字串與 <code>u32</code> 作比較，因為它只會包含數字字元。使用者一定得按下 <span class="keystroke">enter</span> 才能滿足 <code>read_line</code> 並輸入他們的猜測數字，這樣會加上一個換行字元。當使用者按下 <span class="keystroke">enter</span> 時，字串結尾就會加上換行字元。舉例來說，如果使用者輸入 <span class="keystroke">5</span> 並按下 <span class="keystroke">enter</span> 的話，<code>guess</code> 看起來會像這樣：<code>5\n</code>。<code>\n</code> 指的是「換行（newline）」，這是按下 <span class="keystroke">enter</span> 的結果（在 Windows 按下 <span class="keystroke">enter</span> 的結果會是回車和換行 <code>\r\n</code>）。<code>trim</code> 方法能去除 <code>\n</code> 或 <code>\r\n</code>，讓結果只會是 <code>5</code>。</p>
<p>而<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">字串中的 <code>parse</code> 方法</a><!-- ignore -->會轉換字串成其他型別。我們在此用它將字串轉換成數字，我們需要使用 <code>let guess: u32</code> 來告訴 Rust 我們想使用的確切數字型別。<code>guess</code> 後面的分號（<code>:</code>）告訴 Rust 我們會詮釋此變數的型別。Rust 有些內建的數字型別，這裡的 <code>u32</code> 是個非帶號（unsigned）的 32 位元整數。對於不大的正整數來說，這是不錯的預設選擇。你會在<a href="ch03-02-data-types.html#integer-types">第三章</a><!-- ignore -->學到其他數字型別。</p>
<p>除此之外，在此範例程式中的 <code>u32</code> 詮釋與 <code>secret_number</code> 的比較意味著 Rust 也會將 <code>secret_number</code> 推斷成 <code>u32</code>。所以現在會有兩個相同型別的數值能做比較了！</p>
<p><code>parse</code> 的呼叫很容易造成錯誤，因為它只適用於邏輯上能轉換成數字的字元。舉例來說，如果字串包含 <code>A👍%</code> 的話，就不可能轉換成數字。因為它可能會失敗，<code>parse</code> 方法回傳的是 <code>Result</code> 型別，就和 <code>read_line</code> 方法一樣（在之前的<a href="ch02-00-guessing-game-tutorial.html#%E4%BD%BF%E7%94%A8-result-%E8%99%95%E7%90%86%E5%8F%AF%E8%83%BD%E7%9A%84%E9%8C%AF%E8%AA%A4">「使用 <code>Result</code> 處理可能的錯誤」</a><!-- ignore -->段落提及）。我們也會用相同的方式來處理此 <code>Result</code>，也就是呼叫 <code>expect</code> 方法。如果 <code>parse</code> 回傳 <code>Result</code> 的 <code>Err</code> 變體的話，由於它無法從字串建立數字，<code>expect</code> 的呼叫會讓遊戲當掉並顯示我們給予的訊息。如果 <code>parse</code> 能成功將字串轉成數字，它將會回傳 <code>Result</code> 的 <code>Ok</code> 變體，而 <code>expect</code> 將會回傳 <code>Ok</code> 的內部數值。</p>
<p>現在讓我們執行程式：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
請猜測一個數字！
祕密數字為：58
請輸入你的猜測數字。
  76
你的猜測數字：76
太大了！
</code></pre>
<p>不錯！儘管我們在猜測數字前加了一些空格，但程式仍能推斷出使用者猜測的是 76。多執行程式幾次來驗證不同種輸入產生的不同行為：像是正確猜出數字、猜測的數字太高或猜測的數字太低。</p>
<p>我們已經大致上將遊戲完成了，但使用者只能猜測一次。讓我們用迴圈來修改吧！</p>
<h2 id="透過迴圈來允許多次猜測"><a class="header" href="#透過迴圈來允許多次猜測">透過迴圈來允許多次猜測</a></h2>
<p><code>loop</code> 關鍵字會產生無限迴圈。我們加入此迴圈讓使用者可能有更多機會可以猜測：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    // --省略--

    println!(&quot;祕密數字為：{secret_number}&quot;);

    loop {
        println!(&quot;請輸入你的猜測數字。&quot;);

        // --省略--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;請輸入一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
            Ordering::Equal =&gt; println!(&quot;獲勝！&quot;),
        }
    }
}
</code></pre>
<p>如同你所見，我們將輸入猜測提示以下的程式碼都移入迴圈中。請確保迴圈中的每一行有用四個空格來做縮排，然後再次執行程式。現在程式會不停地尋問要猜測的數字了！但這樣帶來了新的問題，看來使用者無法離開遊戲！</p>
<p>使用者的確永遠可以使用快捷鍵 <span class="keystroke">ctrl-c</span> 來中斷程式。但還有其他辦法能逃離這個無限循環，如同在<a href="ch02-00-guessing-game-tutorial.html#%E5%B0%87%E7%8C%9C%E6%B8%AC%E7%9A%84%E6%95%B8%E5%AD%97%E8%88%87%E7%A5%95%E5%AF%86%E6%95%B8%E5%AD%97%E5%81%9A%E6%AF%94%E8%BC%83">「將猜測的數字與祕密數字做比較」</a><!-- ignore -->中討論 <code>parse</code> 時提到的，如果使用者輸入非數字答案的話，程式就會當掉。我們可以利用此特性來讓使用者離開，如以下所示：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
請猜測一個數字！
祕密數字為：59
請輸入你的猜測數字。
45
你的猜測數字：45
太小了！
請輸入你的猜測數字。
60
你的猜測數字：60
太大了！
請輸入你的猜測數字。
59
你的猜測數字：59
獲勝！
請輸入你的猜測數字。
quit
thread 'main' panicked at '請輸入一個數字！: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>輸入 <code>quit</code> 就能離開遊戲，但是你會看到其他非數字輸入也是如此。這並不是最理想的方案，我們想要在猜對數字時自動停止。</p>
<h3 id="猜對後離開"><a class="header" href="#猜對後離開">猜對後離開</a></h3>
<p>讓我們加上 <code>break</code> 陳述式來在使用者獲勝時離開遊戲：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;請輸入一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">
</span>        // --省略--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;獲勝！&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>在 <code>獲勝！</code> 之後加上 <code>break</code> 這行讓程式在使用者猜對祕密數字時可以離開迴圈。離開迴圈也意味著離開程式，因為此迴圈是 <code>main</code> 中的最後一個部分。</p>
<h3 id="處理無效輸入"><a class="header" href="#處理無效輸入">處理無效輸入</a></h3>
<p>為了進一步改善遊戲體驗，當使用者的輸入不是數字時，我們不該讓程式直接當掉。遊戲程式可以忽略非數字來讓使用者繼續猜測。我們可以修改 <code>guess</code> 這段將 <code>String</code> 轉換成 <code>u32</code> 的程式碼，如範例 2-5 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --省略--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;讀取該行失敗&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;你的猜測數字：{guess}&quot;);

        // --省略--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;獲勝！&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 2-5：忽略非數字的猜測並要求下一個猜測數字，而不是讓程式當掉</span></p>
<p>我們將 <code>expect</code> 的呼叫換成 <code>match</code> 表達式，從錯誤中當掉改成實際處理錯誤。你應該還記得 <code>parse</code> 回傳的是 <code>Result</code> 型別，且 <code>Result</code> 是個枚舉，其變體為 <code>Ok</code> 與 <code>Err</code>。我們在此使用 <code>match</code> 表達式，如同我們對 <code>cmp</code> 方法回傳的 <code>Ordering</code> 處理方式一樣。</p>
<p>如果 <code>parse</code> 能成功將字串轉換成數字，它會回傳 <code>Ok</code> 數值內包含的結果數字。該 <code>Ok</code> 數值就會配對到第一個分支的模式，然後 <code>match</code> 表達式就會回傳 <code>parse</code> 產生並填入 <code>Ok</code> 內的 <code>num</code> 數值。該數字最後就會如我們所願變成我們建立的 <code>guess</code> 變數。</p>
<p>如果 <code>parse</code> <strong>無法</strong>將字串轉換成數值的話，它會回傳包含與錯誤相關資訊的 <code>Err</code> 數值。該 <code>Err</code> 數值並不符合 <code>match</code> 的第一個分支模式 <code>Ok(num)</code>，但它能配對到第二個分支。底線 <code>_</code> 是個捕獲數值，在此例中，我們說我們想要配對到所有的 <code>Err</code> 數值，無論其中有什麼資訊在裡面。所以程式會執行第二條分支 <code>continue</code>，這告訴程式繼續 <code>loop</code> 下一個疊代並要求其他猜測數字。如此一來程式就能忽略所有 <code>parse</code> 可能會遇到的所有錯誤！</p>
<p>現在程式的每個部分都如我們所預期的了，讓我們試試看：</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
   Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
請猜測一個數字！
祕密數字為：61
請輸入你的猜測數字。
10
你的猜測數字：10
太小了！
請輸入你的猜測數字。
99
你的猜測數字：99
太大了！
請輸入你的猜測數字。
foo
請輸入你的猜測數字。
61
你的猜測數字：61
獲勝！
</code></pre>
<p>太棒了！有了最後一項小修改，我們終於完成了猜謎遊戲。回想一下程式仍然會印出祕密數字。這在測試很有用，但在實際遊戲時就毀了樂趣了。讓我們刪除會印出祕密數字的 <code>println!</code>。範例 2-6 就是最終的程式碼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;請猜測一個數字！&quot;);

    let secret_number = rand::thread_rng().gen_range(1..=100);

    loop {
        println!(&quot;請輸入你的猜測數字。&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;讀取該行失敗&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;你的猜測數字：{guess}&quot;);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;獲勝！&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">範例 2-6：完整的猜謎遊戲程式碼</span></p>
<p>此時此刻，你已經完成了猜謎遊戲。恭喜你！</p>
<h2 id="總結-1"><a class="header" href="#總結-1">總結</a></h2>
<p>此專案讓你能動手實踐並親自體驗許多 Rust 的新概念：<code>let</code>、<code>match</code>、函式、外部 crate 的使用以及更多等等。在接下來陸續的章節，你將深入學習這些概念。第三章會涵蓋多數程式設計語言都有的概念，像是變數、資料型別與函式，以及如何在 Rust 中使用它們。第四章會探索所有權（ownership），這是 Rust 與其他語言最不同的特色。第五章會討論結構體（structs）與方法語法，而第六章會解釋枚舉。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常見程式設計概念"><a class="header" href="#常見程式設計概念">常見程式設計概念</a></h1>
<p>此章節涵蓋了幾乎所有程式語言都會出現的概念，以及如何在 Rust 使用。許多程式語言的核心概念都是相同的，所以此章節所介紹的概念也不是 Rust 所特有的。不過我們會用 Rust 的程式碼來討論它們，並解釋使用這些概念的慣例。</p>
<p>更明確來說，你將會學習到變數、基本型別、註解以及控制流程。這些基本概念會出現在每個 Rust 程式中，所以提早學習這些概念可以為你打下穩健的基礎。</p>
<blockquote>
<h4 id="關鍵字keywords"><a class="header" href="#關鍵字keywords">關鍵字（Keywords）</a></h4>
<p>Rust 程式語言和其他語言一樣會保留一系列的<strong>關鍵字（keywords）</strong>。請注意你將無法用這些字作為變數或函式名稱。大多數關鍵字都有特別意義，而你將會在你的 Rust 程式使用它們來處理不同的任務；而有一些目前則還沒有任何用途，但是在未來可能會被 Rust 加入所以作為保留。你可以在<a href="appendix-01-keywords.html">附錄 A</a><!-- ignore --> 查看關鍵字列表。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="變數與可變性"><a class="header" href="#變數與可變性">變數與可變性</a></h2>
<p>如同<a href="ch02-00-guessing-game-tutorial.html#%E9%80%8F%E9%81%8E%E8%AE%8A%E6%95%B8%E5%84%B2%E5%AD%98%E6%95%B8%E5%80%BC">「透過變數儲存數值」</a><!-- ignore -->提到的，變數預設是不可變的。這是 Rust 推動你能充分利用 Rust 提供的安全性和簡易並行性來寫程式的許多方法之一。不過，你還是有辦法能讓你的變數成為可變的。讓我們來探討為何 Rust 鼓勵你多多使用不可變，以及何時你會想要改為可變的。</p>
<p>當一個變數是不可變的，只要有數值綁定在一個名字上，你就無法改變其值。為了方便說明，讓我們使用 <code>cargo new variables</code> 在 <em>projects</em> 目錄下產生一個新專案叫做 <em>variables</em>。</p>
<p>再來在你的 <em>variables</em> 目錄下開啟 <em>src/main.rs</em> 然後覆蓋程式碼為以下內容。這是段還無法編譯的程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;x 的數值為：{x}&quot;);
    x = 6;
    println!(&quot;x 的數值為：{x}&quot;);
}
</code></pre>
<p>儲存然後使用 <code>cargo run</code> 執行程式。你應該會收到一則有關於不可變的錯誤訊息，如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;x 的數值為：{x}&quot;);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<p>此範例顯示了編譯器如何協助你找到你程式碼的錯誤。雖然看到編譯器錯誤訊息總是令人感到沮喪，但這通常是為了讓你知道你的程式無法安全地完成你想讓它完成的任務。它們<strong>不代表</strong>你不是個優秀的程式設計師！有經驗的 Rustaceans 時常會與編譯器錯誤訊息打交道。</p>
<p>你得到的錯誤訊息說明「cannot assign twice to immutable variable <code>x</code>」，因為你嘗試第二次賦值給 <code>x</code> 變數。</p>
<p>當我們嘗試改變一個原先設計為不可變的變數時，能夠產生編譯時錯誤是很重要的。因為這樣的情況很容易導致程式錯誤。如果我們有一部分的程式碼在執行時認為某個數值絕對不會改變，但另一部分的程式碼卻更改了其值，那麼這就有可能讓前一部分的程式碼就可能以無法預測的方式運行。這樣的程式錯誤的起因是很難追蹤的，尤其是當第二部分的程式碼<strong>偶而</strong>才會改變其值。Rust 編譯器會保證當你宣告一個數值不會被改變時，它就絕對不會被改變。這樣你就不需要去追蹤該值可能會被改變，讓你的程式碼更容易推導。</p>
<p>但同時可變性也是非常有用的，能讓程式碼變得更好寫。雖然變數預設是不可變的，但就如同<a href="ch02-00-guessing-game-tutorial.html#%E9%80%8F%E9%81%8E%E8%AE%8A%E6%95%B8%E5%84%B2%E5%AD%98%E6%95%B8%E5%80%BC">第二章</a><!-- ignore -->一樣你可以在變數名稱前面加上 <code>mut</code> 讓它們可以成為可變的。加上 <code>mut</code> 也向未來的讀取者表明了其他部分的程式碼將會改變此變數的數值。</p>
<p>舉例來說，讓我們改變 <em>src/main.rs</em>  成以下程式碼：</p>
<p><span class="filename">檔案內容：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;x 的數值為：{x}&quot;);
    x = 6;
    println!(&quot;x 的數值為：{x}&quot;);
}
</code></pre></pre>
<p>當你執行程式的話，我們會得到：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
x 的數值為：5
x 的數值為：6
</code></pre>
<p>當使用 <code>mut</code> 時，我們可以將 <code>x</code> 的數值從 <code>5</code> 改變為 <code>6</code>。何時使用可變性的決定權在你手上，你可以依照特定場合做出你認為最佳的選擇。</p>
<h3 id="常數"><a class="header" href="#常數">常數</a></h3>
<p><strong>常數（constants）</strong>。和不可變變數一樣，常數會讓數值與名稱綁定且不允許被改變，但是不可變變數與常數還是有些差異。</p>
<p>首先，你無法在使用常數使用 <code>mut</code>，常數不是預設不可變，它們永遠都不可變。如果你使用 <code>const</code> 宣告而非 <code>let</code> 的話，你<strong>必須</strong>指明型別。我們會在下一章<a href="ch03-02-data-types.html#%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">「資料型別」</a><!-- ignore -->詳細解釋型別與型別詮釋，所以現在先別擔心細節。你只需要先知道你永遠必須先詮釋常數的型別。</p>
<p>常數可以被定義在任一有效範圍，包含全域有效範圍。這讓它們非常有用，讓許多部分的程式碼都能夠知道它們。</p>
<p>最後一個差別是常數只能被常數表達式設置，而不能用任一在運行時產生的其他數值設置。</p>
<p>以下為一個常數名稱的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
<span class="boring">}
</span></code></pre></pre>
<p>變數的名稱為 <code>THREE_HOURS_IN_SECONDS</code> ，且它的數值被設為 60（一分鐘有多少秒）乘上 60（一小時有多少分鐘）乘上 3（此程式想要計算的小時數量）。Rust 的常數命名規則為使用全部英文大寫並用底寫區隔每個單字。編譯器能夠在編譯時用特定限制集合內的操作進行運算，讓我們能用易於理解且驗證的方式寫出此數值，而不用將常數設爲 10,800。你可以查閱 Rust Reference 的 <a href="https://doc.rust-lang.org/stable/reference/const_eval.html">constant evaluation 段落</a>來瞭解哪些操作可以在宣告常數時使用。</p>
<p>在整支程式運行時，常數在它們的範圍內都是有效的。這樣的性質讓常數在處理應用程式中需要被許多程式碼部份所知道的數值的情況下是非常好的選擇，像是一款遊戲中玩家能夠得到的最高分數或者光速的數值。</p>
<p>將會擴散到所有程式碼的數值定義為常數，對於幫助未來程式碼的維護者理解是非常好的選擇。這也讓未來需要更新數值的話，你知道需要修改寫死的地方就好。</p>
<h3 id="遮蔽shadowing"><a class="header" href="#遮蔽shadowing">遮蔽（Shadowing）</a></h3>
<p>如同你在猜謎遊戲教學所看到的，在<a href="ch02-00-guessing-game-tutorial.html#%E5%B0%87%E7%8C%9C%E6%B8%AC%E7%9A%84%E6%95%B8%E5%AD%97%E8%88%87%E7%A5%95%E5%AF%86%E6%95%B8%E5%AD%97%E5%81%9A%E6%AF%94%E8%BC%83">第二章</a><!-- ignore -->你可以用之前的變數再次宣告新的變數。Rustaceans 會說第一個變數被第二個變數所<strong>遮蔽</strong>了，這代表當你使用該變數名稱時，編譯器會看到的是第二個變數的數值。第二個變數會遮蔽第一個變數，佔據變數名稱的使用權，直到它自己也被遮蔽或是離開作用域。我們可以用 <code>let</code> 關鍵字來重複宣告相同的變數名稱來遮蔽一個變數：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;x 在內部範圍的數值為：{x}&quot;);
    }

    println!(&quot;x 的數值為：{x}&quot;);
}
</code></pre></pre>
<p>此程式首先將 <code>x</code> 給予 <code>5</code>，然後它重複用 <code>let x =</code> 建立一個新變數 <code>x</code>，取代了原本的數值並加上 <code>1</code>，所以 <code>x</code> 的數值變為 <code>6</code>。然後在接下來括號的內部範圍內，第三次的 <code>let</code> 陳述式一樣遮蔽了 <code>x</code> 讓它將原本的值乘與 <code>2</code>，讓 <code>x</code> 數值為 <code>12</code>。當該範圍結束時，內部的遮蔽也結束，所以 <code>x</code> 就回到原本的 <code>6</code>。當我們運行此程式時，就會輸出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
x 在內部範圍的數值為：12
x 的數值為：6
</code></pre>
<p>遮蔽與標記變數為 <code>mut</code> 是不一樣的，因為如果我們不小心重新賦值而沒有加上 <code>let</code> 關鍵字的話，是會產生編譯期錯誤的。使用 <code>let</code> 的話，我們可以作出一些改變，然後在這之後該變數仍然是不可變的。</p>
<p>另一個 <code>mut</code> 與遮蔽不同的地方是，我們能有效地再次運用 <code>let</code> 產生新的變數，可以在重新運用相同名稱時改變它的型別。舉例來說，當我們希望程式要求使用者顯示出字串間應該顯示多少空格，同時我們又希望它被存為一個數字時，我們可以這樣做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>第一次宣告 <code>spaces</code> 的變數是一個字串型別，而第二次宣告 <code>spaces</code> 則成了數字型別。遮蔽這項功能讓我們不必去宣告像是 <code>spaces_str</code> 與 <code>spaces_num</code>，我們可以重複使用 <code>spaces</code> 這個變數名稱。不過，可變變數仍然是無法變更變數型別的，如果這樣做的話我們就會拿到編譯期錯誤：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre>
<p>此錯誤訊息告訴我們我們不允許改變變數的型別：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<p>現在我們講完變數了，讓我們看看它們可以擁有的資料型別吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="資料型別"><a class="header" href="#資料型別">資料型別</a></h2>
<p>每個數值在 Rust 中都屬於某種<strong>資料型別</strong>，這告訴 Rust 何種資料被指定，好讓它能妥善處理資料。我們將討論兩種資料型別子集：純量（scalar）與複合（compound）。</p>
<p>請記住 Rust 是一門<strong>靜態型別</strong>語言，這代表它必須在編譯時知道所有變數的型別。編譯器通常能依據數值與我們使用的方式推導出我們想使用的型別。但有時候如果多種型別都有可能時，像是第二章的<a href="ch02-00-guessing-game-tutorial.html#%E5%B0%87%E7%8C%9C%E6%B8%AC%E7%9A%84%E6%95%B8%E5%AD%97%E8%88%87%E7%A5%95%E5%AF%86%E6%95%B8%E5%AD%97%E5%81%9A%E6%AF%94%E8%BC%83">「將猜測的數字與祕密數字做比較」</a><!-- ignore -->用到的 <code>parse</code> 將 <code>String</code> 轉換成數字時，我們就需要像這樣加上型別詮釋：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;這不是數字！&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>如果我們沒有像上列程式碼這樣加上型別詮釋 <code>: u32</code> 的話，Rust 將會顯示以下錯誤訊息。這表示編譯器需要我們給予更多資訊才能夠知道我們想用何種型別：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;這不是數字！&quot;);
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = &quot;42&quot;.parse().expect(&quot;這不是數字！&quot;);
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>你將會看到其他資料型別的各種型別詮釋。</p>
<h3 id="純量型別"><a class="header" href="#純量型別">純量型別</a></h3>
<p><strong>純量</strong>型別代表單一數值。Rust 有四種主要純量型別：整數、浮點數、布林以及字元。你應該在其他程式語言就看過它們了，讓我們來看看它們在 Rust 是怎麼使用的：</p>
<h4 id="整數型別"><a class="header" href="#整數型別">整數型別</a></h4>
<p><strong>整數</strong>是沒有小數點的數字。我們在第二章用到了一個整數型別 <code>u32</code>，此型別表示其擁有的數值應該是一個佔 32 位元大小的非帶號整數（帶號整數的話則是用 <code>i</code> 起頭而非 <code>u</code>）。表格 3-1 展示了 Rust 中內建的整數型別。我們可以使用以下任何一種型別來宣告一個整數數值。</p>
<p><span class="caption">表格 3-1：Rust 中的整數型別</span></p>
<div class="table-wrapper"><table><thead><tr><th>長度</th><th>帶號</th><th>非帶號</th></tr></thead><tbody>
<tr><td>8 位元</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位元</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位元</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位元</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 位元</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>系統架構</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>每個變體都可以是帶號或非帶號的，並且都有明確的大小。<strong>帶號</strong>與<strong>非帶號</strong>的區別是數字能不能有負數，換句話說就是數字能否帶有正負符號，如果沒有的話那就只會出現正整數而已。就像在紙上寫數字一樣：當我們需要考慮符號時，我們就會在數字前面加上正負號；但如果我們只在意正整數的話，那它可以不帶符號。帶號數字是以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">二補數</a><!-- ignore -->的方式儲存。</p>
<p>每一帶號變體可以儲存的數字範圍包含從 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1 以內的數字，<em>n</em> 就是該變體佔用的位元大小。所以一個 <code>i8</code> 可以儲存的數字範圍就是從 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1，也就是 -128 到 127。而非帶號可以儲存的數字範圍則是從 0 到 2<sup>n</sup> - 1，所以 <code>u8</code> 可以儲存的範圍是從 0 到 2<sup>8</sup> - 1，也就是 0 到 255。</p>
<p>另外，<code>isize</code> 與 <code>usize</code> 型別則是依據你程式運行的電腦架構來決定大小，所以上方表格才用「系統架構」來表示長度：如果你在 64 位元架構上的話就是 64 位元；如果你是 32 位元架構的話就是 32 位元。</p>
<p>你可以用表格 3-2 列的格式來寫出整數字面值（literals）。能適用於數種數字型別的數字字面值都允許在最後面加上型別，比如說用 <code>57u8</code> 來指定型別。數字字面值也可以加上底線 <code>_</code> 分隔方便閱讀，比如說 <code>1_000</code> 其實就和指定 <code>1000</code> 的數值一樣。</p>
<p><span class="caption">表格 3-2：Rust 中的整數字面值</span></p>
<div class="table-wrapper"><table><thead><tr><th>數字字面值</th><th>範例</th></tr></thead><tbody>
<tr><td>十進制</td><td><code>98_222</code></td></tr>
<tr><td>十六進制</td><td><code>0xff</code></td></tr>
<tr><td>八進制</td><td><code>0o77</code></td></tr>
<tr><td>二進制</td><td><code>0b1111_0000</code></td></tr>
<tr><td>位元組（僅限<code>u8</code>）</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>所以你該用哪些整數型別呢？如果你不確定的話，Rust 預設的型別是很好的起始點：整數型別預設是 <code>i32</code>。而你會用到 <code>isize</code> 或 <code>usize</code> 的主要時機是作為某些集合的索引。</p>
<blockquote>
<h5 id="整數溢位"><a class="header" href="#整數溢位">整數溢位</a></h5>
<p>假設你有個變數型別是 <code>u8</code> 可以儲存 0 到 255 的數值。如果你想要改變變數的值超出這個範圍的話，比方說像是 256，那麼就會發生<strong>整數溢位</strong>，這會產生兩種不同的結果。如果你是在除錯模式編譯的話，Rust 會包含整數溢位的檢查，造成你的程式在執行時<strong>恐慌（panic）</strong>。Rust 使用恐慌來表示程式因錯誤而結束，我們會在第九章的<a href="ch09-01-unrecoverable-errors-with-panic.html">「對無法復原的錯誤使用 <code>panic!</code>」</a><!-- ignore -->段落討論更多造成恐慌的細節。</p>
<p>當你是在發佈模式下用 <code>--release</code> 來編譯的話，Rust 則<strong>不會</strong>加上整數溢位的檢查而造成恐慌。相反地，如果發生整數溢位的話，Rust 會作出<strong>二補數包裝</strong>的動作。簡單來說，超出最大值的數值可以被<strong>包裝</strong>成該型別的最低數值。以 <code>u8</code> 為例的話，256 會變成 0、257 會變成 1，以此類推。程式不會恐慌，但是該變數可能會得到一個不是你原本預期的數值。通常依靠整數溢位的行為仍然會被視為邏輯錯誤。</p>
<p>要顯式處理可能的溢位的話，你可以使用以下標準函式庫中基本型別提供的一系列方法：</p>
<ul>
<li>將所有操作用 <code>wrapping_*</code> 方法包裝，像是 <code>wrapping_add</code>。</li>
<li>使用 <code>checked_*</code> 方法，如果有溢位的話其會回傳 <code>None</code> 數值。</li>
<li>使用 <code>overflowing_*</code> 方法，其會回傳數值與一個布林值來顯示是否有溢位發生。</li>
<li>屬於 <code>saturating_*</code> ，讓數值溢位時保持在最小或最大值。</li>
</ul>
</blockquote>
<h4 id="浮點數型別"><a class="header" href="#浮點數型別">浮點數型別</a></h4>
<p>Rust 還有針對有小數點的<strong>浮點數</strong>提供兩種基本型別：<code>f32</code> 和 <code>f64</code>，分別佔有 32 位元與 64 位元的大小。而預設的型別為 <code>f64</code>，因為現代的電腦處理的速度幾乎和 <code>f32</code> 一樣卻還能擁有更高的精準度。所有的浮點數型別都是帶號的（signed）。</p>
<p>以下為展示浮點數的範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮點數是依照 IEEE-754 所定義的，<code>f32</code> 型別是單精度浮點數，而 <code>f64</code> 是倍精度浮點數。</p>
<h4 id="數值運算"><a class="header" href="#數值運算">數值運算</a></h4>
<p>Rust 支援你所有想得到的數值型別基本運算：加法、減法、乘法、除法和取餘。整數除法會取最接近零的下界數值。以下程式碼展示出如何在 <code>let</code> 陳述式使用這些運算：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 加法
    let sum = 5 + 10;

    // 減法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 結果爲 -1

    // 取餘
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>每一個陳述式中的表達式都使用了一個數學運算符號並計算出一個數值出來，賦值給該變數。<a href="appendix-02-operators.html">附錄 B</a><!-- ignore --> 有提供列表列出 Rust 所提供的所有運算子。</p>
<h4 id="布林型別"><a class="header" href="#布林型別">布林型別</a></h4>
<p>如同其他多數程式語言一樣，Rust 中的布林型別有兩個可能的值：<code>true</code> 和 <code>false</code>。布林值的大小為一個位元組。要在 Rust 中定義布林型別的話用 <code>bool</code>，如範例所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 型別詮釋的方式
}
</code></pre></pre>
<p>布林值最常使用的方式之一是作為條件判斷，像是在 <code>if</code> 表達式中使用。我們將會在<a href="ch03-05-control-flow.html#control-flow">「控制流程」</a><!-- ignore -->段落介紹如何在 Rust 使用 <code>if</code> 表達式。</p>
<h4 id="字元型別"><a class="header" href="#字元型別">字元型別</a></h4>
<p>Rust 的 <code>char</code> 型別是最基本的字母型別，以下程式碼顯示了使用它的方法：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // 明確標註型別的寫法
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>注意到 <code>char</code> 字面值是用單引號賦值，宣告字串字面值時才是用雙引號。Rust 的 <code>char</code> 型別大小為四個位元組並表示為一個 Unicode 純量數值，這代表它能擁有的字元比 ASCII 還來的多。舉凡標音字母（Accented letters）、中文、日文、韓文、表情符號以及零長度空格都是 Rust <code>char</code> 的有效字元。Unicode 純量數值的範圍包含從 <code>U+0000</code> 到 <code>U+D7FF</code> 以及 <code>U+E000</code> 到 <code>U+10FFFF</code>。但是一個「字元」並不是真正的 Unicode 概念，所以你對於什麼是一個「字元」的看法可能會和 Rust 的 <code>char</code> 不一樣。我們將會在第八章的<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">「透過字串儲存 UTF-8 編碼的文字」</a><!-- ignore -->來討論此議題。</p>
<h3 id="複合型別"><a class="header" href="#複合型別">複合型別</a></h3>
<p><strong>複合型別</strong>可以組合數個數值為一個型別，Rust 有兩個基本複合型別：元組（tuples）和陣列（arrays）。</p>
<h4 id="元組tuple型別"><a class="header" href="#元組tuple型別">元組（Tuple）型別</a></h4>
<p><strong>元組</strong>是個將許多不同型別的數值合成一個複合型別的常見方法。元組擁有固定長度：一旦宣告好後，它們就無法增長或縮減。</p>
<p>我們建立一個元組的方法是寫一個用括號囊括起來的數值列表，每個值再用逗號分隔開來。元組的每一格都是一個獨立型別，不同數值不必是相同型別。以下範例我們也加上了型別詮釋，平時不一定要加上：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>此變數 <code>tup</code> 就是整個元組，因為一個元組就被視為單一複合元素。要拿到元組中的每個獨立數值的話，我們可以用模式配對（pattern matching）來解構一個元組的數值，如以下所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;y 的數值為：{y}&quot;);
}
</code></pre></pre>
<p>此程式先是建立了一個元組然後賦值給 <code>tup</code>，接著它用模式配對和 <code>let</code> 將 <code>tup</code> 拆成三個個別的變數 <code>x</code>、<code>y</code> 和 <code>z</code>。這就叫做<strong>解構（destructuring）</strong>，因為它將單一元組拆成了三個部分。最後程式將 <code>y</code> 的值印出來，也就是 <code>6.4</code>。</p>
<p>我們也可以直接用句號（<code>.</code>）再加上數值的索引來取得元組內的元素。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>此程式建立了元組 <code>x</code>，然後用它們個別的索引來存取元組的元素。和多數程式語言一樣，元組的第一個索引是 0。</p>
<p>沒有任何數值的元組有一種特殊的名稱叫做<strong>單元型別（Unit）</strong>，其數值與型別都寫作 <code>()</code>，通常代表一個空的數值或空的回傳型別。表達式要是沒有回傳任何數值的話，它們就會隱式回傳單元型別。</p>
<h4 id="陣列型別"><a class="header" href="#陣列型別">陣列型別</a></h4>
<p>另一種取得數個數值集合的方法是使用<strong>陣列</strong>。和元組不一樣的是，陣列中的每個型別必須是一樣的。和其他語言的陣列不同，Rust 的陣列是固定長度的。</p>
<p>我們將數值寫在陣列中的括號內，每個數值再用逗號區隔開來：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>當你想要你的資料被分配在堆疊（stack）而不是堆積（heap）的話，使用陣列是很好的選擇（我們會在<a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">第四章</a><!-- ignore -->討論堆疊與堆積的內容）。或者當你想確定你永遠會取得固定長度的元素時也是。所以陣列不像向量（vector）型別那麼有彈性，<strong>向量</strong>是標準函式庫提供的集合型別，類似於陣列但<strong>允許</strong>變更長度大小。如果你不確定該用陣列或向量的話，通常你應該用向量就好。<a href="ch08-01-vectors.html">第八章</a><!-- ignore -->將會討論更多向量的細節。</p>
<p>不過如果你知道元素的多寡不會變的話，陣列就是個不錯的選擇。舉例來說，如果你想在程式中使用月份的話，你可能就會選擇用陣列宣告，因為永遠只會有 12 個月份：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;一月&quot;, &quot;二月&quot;, &quot;三月&quot;, &quot;四月&quot;, &quot;五月&quot;, &quot;六月&quot;, &quot;七月&quot;,
              &quot;八月&quot;, &quot;九月&quot;, &quot;十月&quot;, &quot;十一月&quot;, &quot;十二月&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>要詮釋陣列型別的話，你可以在中括號寫出型別和元素個數，並用分號區隔開來，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p><code>i32</code> 在此是每個元素的型別，在分號後面的數字 <code>5</code> 指的是此陣列有五個元素。</p>
<p>如果你想建立的陣列中每個元素數值都一樣的話，你可以指定一個數值後加上分號，最後寫出元素個數。如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>陣列 <code>a</code> 會包含 <code>5</code> 個元素，然後每個元素的初始化數值均為 <code>3</code>。這樣寫與 <code>let a = [3, 3, 3, 3, 3];</code> 的寫法一樣，但比較簡潔。</p>
<h5 id="獲取陣列元素"><a class="header" href="#獲取陣列元素">獲取陣列元素</a></h5>
<p>一個陣列是被分配在堆疊上且已知固定大小的一整塊記憶體，你可以用索引來取得陣列的元素，比如：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>在此範例中，變數 <code>first</code> 會得到數值 <code>1</code>，因為這是陣列索引 <code>[0]</code> 的數值。變數 <code>second</code> 則會從陣列索引 <code>[1]</code> 得到數值 <code>2</code>。</p>
<h5 id="無效的陣列元素存取"><a class="header" href="#無效的陣列元素存取">無效的陣列元素存取</a></h5>
<p>讓我們看看如果我們存取陣列之後的元素會發生什麼事呢？假設你修改成以下範例，這是改寫自第二章猜謎遊戲要從使用者取得陣列索引的程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;請輸入陣列索引&quot;);

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;讀行失敗&quot;);

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;輸入的索引並非數字&quot;);

    let element = a[index];

    println!(
        &quot;索引 {index} 元素的數值爲：{element}&quot;
    );
}
</code></pre>
<p>此程式碼能編譯成功。如果你透過 <code>cargo run</code> 執行此程式碼並輸入 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code> 或 <code>4</code>  的話，程式將會印出陣列索引對應的數值。但如果你輸入超出陣列長度的數值，像是 <code>10</code> 的話，你會看到像是這樣的輸出結果：</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>此程式會在使用無效數值進行索引操作時產生<strong>執行時</strong>（runtime）錯誤。程式會退出並回傳錯誤訊息，且不會執行最後的 <code>println!</code>。當你嘗試使用索引存取元素時，Rust 會檢查你的索引是否小於陣列長度，如果索引大於或等於陣列長度的話，Rust 就會恐慌。這樣的檢查必須發生在執行時，尤其是在此例，因爲編譯器無法知道之後的使用者將會輸入哪些數值。</p>
<p>這是 Rust 記憶體安全原則給予的保障。在許多低階語言並不會提供這樣的檢查，所以當你提供不正確的索引時，無效的記憶體可能會被存取。Rust 會保護你免於這樣的錯誤風險，並立即離開程式，而不是允許記憶體存取並繼續。第九章將會討論更多有關 Rust 的錯誤處理方式以及如何讓你寫出易讀且安全的程式碼，而不會恐慌或造成無效的記憶體存取。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="函式"><a class="header" href="#函式">函式</a></h2>
<p>函式在 Rust 程式碼中無所不在。你已經見過一個語言最重要的函式了：<code>main</code> 函式是許多程式的入口點。此外你也看到了 <code>fn</code> 關鍵字能讓你宣告新的函式。</p>
<p>Rust 程式碼使用 <em>snake case</em> 式作為函式與變數名稱的慣例風格。所有的字母都是小寫，並用底線區隔單字。以下是一支包含函式定義範例的程式：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;另一支函式。&quot;);
}
</code></pre></pre>
<p>我們在 Rust 中定義函式是先從 <code>fn</code> 開始，再加上函式名稱和一組括號，大括號告訴編譯器函式本體的開始與結束位置。</p>
<p>我們可以輸入函式的名稱並加上括號來呼叫任何我們定義過的函式。因為 <code>another_function</code> 已經在程式中定義了，他就可以在 <code>main</code> 函式中呼叫。注意到我們是在原始碼中的 <code>main</code> 函式<strong>之後</strong>定義 <code>another_function</code> 的，我們當然也可以把它定義在前面。Rust 不在乎你的函式是在哪裡定義的，只需要知道它定義在作用域的某處，且能被呼叫者看到就好。</p>
<p>讓我們開啟一個新的專案叫做 <em>functions</em> 來進一步探索。請將 <code>another_function</code> 範例放入 <em>src/main.rs</em> 然後執行它。你應該會看到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
另一支函式。
</code></pre>
<p>程式碼會按照 <code>main</code> 函式中的順序執行。首先，「Hello, world!」的訊息會先顯示出來，再來才會呼叫 <code>another_function</code> 並印出它的訊息。</p>
<h3 id="參數"><a class="header" href="#參數">參數</a></h3>
<p>我們也可以定義函式成擁有<strong>參數（parameters）<strong>的，這是函式簽名（signatures）中特殊的變數。當函式有參數時，你可以提供那些參數的確切數值。嚴格上來說，我們傳遞的數值會叫做</strong>引數（arguments）</strong>。但為了方便起見，通常大家不太會去在意兩者的區別。雖然函式定義時才叫<strong>參數</strong>，傳遞數值時叫做<strong>引數</strong>，但很多情況下都能被交換使用。</p>
<p>以下的 <code>another_function</code> 是加上參數後的版本：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;x 的數值為：{x}&quot;);
}
</code></pre></pre>
<p>嘗試執行程式的話，你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
x 的數值為：5
</code></pre>
<p>宣告 <code>another_function</code> 時有一個參數叫做 <code>x</code>，而 <code>x</code> 的型別被指定為 <code>i32</code>。當我們傳遞 <code>5</code> 給 <code>another_function</code> 時，<code>println!</code> 巨集會將 <code>5</code> 置於格式化字串中的大括號內 <code>x</code> 的位置。</p>
<p>在函式簽名中，你<strong>必須</strong>宣告每個參數的型別，這是 Rust 刻意做下的設計決定：在函式定義中要求型別詮釋，代表編譯器幾乎不需要你在其他地方再提供資訊才能知道你要使用什麼型別。而且如果編譯器能知道函式預期的型別的話，它還能夠給予更有幫助的錯誤訊息。</p>
<p>如果要定義函式擁有數個參數時，會用逗號區隔開來，像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;測量值爲：{value}{unit_label}&quot;);
}
</code></pre></pre>
<p>此範例建立了一個有兩個參數的函式 <code>print_labeled_measurement</code>，第一個參數叫做 <code>value</code> 而型別爲 <code>i32</code>，第二個參數叫做 <code>unit_label</code> 而型別爲 <code>char</code>。接著函式會印出包含 <code>value</code> 與 <code>unit_label</code> 的文字。</p>
<p>讓我們試著執行此程式碼，請覆蓋你的專案 <em>functions</em> 內的 <em>src/main.rs</em> 檔案內容為以上範例，然後用 <code>cargo run</code> 執行程式：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
測量值爲：5h
</code></pre>
<p>因為我們呼叫函式時，將 <code>5</code> 給了 <code>value</code> 且將 <code>'h'</code> 給了 <code>unit_label</code>，程式輸出就會包含這些數值。</p>
<h3 id="陳述式與表達式"><a class="header" href="#陳述式與表達式">陳述式與表達式</a></h3>
<p>函式本體是由一系列的陳述式（statements）並在最後可以選擇加上表達式（expression）來組成。目前我們只講了沒有用到表達式做結尾的函式。由於 Rust 是門基於表達式（expression-based）的語言，知道這樣的區別是很重要的。其他語言通常沒有這樣的區別，所以現在讓我們來看看陳述式和表達式有什麼不同，以及它們怎麼影響函式本體。</p>
<ul>
<li><strong>陳述式</strong>（Statements）是進行一些動作的指令，且不回傳任何數值。</li>
<li><strong>表達式</strong>（Expressions）則是計算並產生數值。讓我們來看一些範例：</li>
</ul>
<p>我們其實已經使用了很多次陳述式與表達式。建立一個變數然後用 <code>let</code> 關鍵字賦值給它就是一道陳述式。在範例 3-1 中的 <code>let y = 6;</code> 就是個陳述式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">範例 3-1：包含一道陳述式的 <code>main</code> 函式宣告</span></p>
<p>此函式定義也是陳述式，整個範例就是本身就是一個陳述式。</p>
<p>陳述式不會回傳數值，因此你無法將 <code>let</code> 陳述式賦值給其他變數。如同以下程式碼所做的，你將會得到一個錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>當你執行此程式時，你就會看到這樣的錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found `let` statement
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^

error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  |

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 3 previous errors; 1 warning emitted
</code></pre>
<p><code>let y = 6</code> 陳述式不回傳數值，所以 <code>x</code> 得不到任何數值。這就和其他語言有所不同，像是 C 或 Ruby，通常它們的賦值仍能回傳所得到的值。在那些語言，你可以寫 <code>x = y = 6</code> 同時讓 <code>x</code> 與 <code>y</code> 都取得 <code>6</code>，但在 Rust 就不行。</p>
<p>表達式則會運算出一個數值，並組合成你大部分所寫的 Rust 程式。先想想看一個數學運算比如 <code>5 + 6</code>，這就是個會算出 <code>11</code> 的表達式。表達式可以是陳述式的一部分：在範例 3-1 中 <code>let y = 6;</code> 的 <code>6</code> 其實就是個算出 <code>6</code> 的表達式。呼叫函式也可以是表達式、呼叫巨集也是表達式、我們用 <code>{}</code> 產生的作用域也是表達式。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;y 的數值為：{y}&quot;);
}
</code></pre></pre>
<p>此表達式：</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>就是一個會回傳 <code>4</code> 的區塊，此值再用 <code>let</code> 陳述式賦值給 <code>y</code>。請注意到 <code>x + 1</code> 這行沒有加上分號，它和你目前看到的寫法有點不同，因為表達式結尾不會加上分號。如果你在此表達式加上分號的話，它就不會回傳數值。在我們繼續探討函式回傳值與表達式的同時請記住這一點。</p>
<h3 id="函式回傳值"><a class="header" href="#函式回傳值">函式回傳值</a></h3>
<p>函式可以回傳數值給呼叫它們的程式碼，我們不會為回傳值命名，但我們必須用箭頭（<code>-&gt;</code>）來宣告它們的型別。在 Rust 中，回傳值其實就是函式本體最後一行的表達式。你可以用 <code>return</code> 關鍵字加上一個數值來提早回傳函式，但多數函式都能用最後一行的表達式作為數值回傳。以下是一個有回傳數值的函式範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;x 的數值為：{x}&quot;);
}
</code></pre></pre>
<p>在 <code>five</code> 函式中沒有任何函式呼叫、巨集甚至是 <code>let</code> 陳述式，只有一個 <code>5</code>。這在 Rust 中完全是合理的函式。請注意到函式的回傳型別也有指明，就是 <code>-&gt; i32</code>。嘗試執行此程式的話，輸出結果就會像是這樣：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
x 的數值為：5
</code></pre>
<p><code>five</code> 中的 <code>5</code> 就是函式的回傳值，這就是為何回傳型別是 <code>i32</code>。讓我們進一步研究細節，這邊有兩個重要的地方：首先這行 <code>let x = five();</code> 顯示了我們用函式的回傳值作為變數的初始值。因為函式 <code>five</code> 回傳 <code>5</code>，所以這行和以下程式碼相同：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>再來，<code>five</code> 函式沒有參數但有定義回傳值的型別。所以函式本體只需有一個 <code>5</code> 就好，不需加上分號，這樣就能當做表達式回傳我們想要的數值。</p>
<p>讓我們再看另一個例子：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;x 的數值為：{x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>執行此程式會顯示 <code>x 的數值為：6</code>，但如果我們在最後一行 <code>x + 1</code> 加上分號的話，就會將它從表達式變為陳述式。我們就會得到錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;x 的數值為：{x}&quot;);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>編譯此程式就會產生以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<p>錯誤訊息 <code>mismatched types</code> 就告訴了我們此程式碼的核心問題。<code>plus_one</code> 的函式定義說它會回傳 <code>i32</code> 但是陳述式不會回傳任何數值。我們用單元型別 <code>()</code> 表示不會回傳任何值。因此沒有任何值被回傳，這和函式定義相牴觸，最後產生錯誤。在此輸出結果，Rust 提供了一道訊息來協助解決問題：它建議移除分號，這樣就能修正錯誤。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="註解"><a class="header" href="#註解">註解</a></h2>
<p>所有程式設計師均致力於讓他們的程式碼易於閱讀，不過有時候額外的解釋還是需要的。這種情況下，開發者會在他們的程式碼留下一些<strong>註解（comments）</strong>，編譯器會忽略這些字，但其他人在閱讀程式碼時可能就會覺得很有幫助。</p>
<p>這是一個簡單地註解：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 安安，你好
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，慣用的註解風格是用兩行斜線再加上一個空格起頭，然後註解就能一直寫到該行結束為止。如果註解會超過一行的話，你需要在每一行都加上 <code>//</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 這邊處理的事情很複雜，長到
// 我們需要多行註解來能解釋！
// 希望此註解能幫助你理解。
<span class="boring">}
</span></code></pre></pre>
<p>註解也可以加在程式碼之後：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // 幸運 777！
}
</code></pre></pre>
<p>不過你會更常看到它們用用以下格式，註解會位於要說明的程式碼上一行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 幸運 777！
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust 還有另一種註解：技術文件註解。我們會在第十四章的<a href="ch14-02-publishing-to-crates-io.html">「發佈 Crate 到 Crates.io」</a><!-- ignore -->段落提到它。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<p>在大多數程式語言中，能夠決定依據某項條件是否為 <code>true</code> 來執行些程式碼，以及依據某項條件是否為 <code>true</code> 來重複執行些程式碼是非常基本的組成元件。在 Rust 程式碼中能讓你控制執行流程的常見方法有 <code>if</code> 表達式以及迴圈。</p>
<h3 id="if-表達式"><a class="header" href="#if-表達式"><code>if</code> 表達式</a></h3>
<p><code>if</code> 能讓你依照條件判斷對你的程式碼產生分支。基本上你提供一個條件然後就像是在說：「如果此條件符合的話，就執行這個程式碼區塊；如果沒有的話，就不要執行這段程式碼。」</p>
<p>請在你的 <em>projects</em> 目錄下建立一個新的專案叫做 <em>branches</em> 好讓我們來探討 <code>if</code> 表達式。接著請在 <em>src/main.rs</em> 檔案內輸入以下內容：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;條件為真&quot;);
    } else {
        println!(&quot;條件為否&quot;);
    }
}
</code></pre></pre>
<p>所有的 <code>if</code> 表達式都由 <code>if</code> 關鍵字開始再加上一個條件。在此例中的條件是判斷變數 <code>number</code> 是否小於 5。條件符合時所要執行的程式碼區塊被放在條件之後的大括號裡。與 <code>if</code> 表達式條件相關的程式碼段落有時也被稱為<strong>分支（arms）</strong>，就像我們在第二章<a href="ch02-00-guessing-game-tutorial.html#%E5%B0%87%E7%8C%9C%E6%B8%AC%E7%9A%84%E6%95%B8%E5%AD%97%E8%88%87%E7%A5%95%E5%AF%86%E6%95%B8%E5%AD%97%E5%81%9A%E6%AF%94%E8%BC%83">「將猜測的數字與祕密數字做比較」</a><!-- ignore -->段落提到的 <code>match</code> 表達式的分支一樣。</p>
<p>另外，我們還可以選擇性地加上 <code>else</code> 表達式（就像範例寫的），讓條件不符時可以去執行另外一段程式碼。如果你沒有提供 <code>else</code> 表達式且條件為否的話，程式會直接略過 <code>if</code> 的程式碼區塊，接著執行後續的程式碼。</p>
<p>請嘗試執行此程式碼，你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
條件為真
</code></pre>
<p>讓我們來變更 <code>number</code> 的值使條件變成 <code>false</code>，再來看看會發生什麼事：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;條件為真&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;條件為否&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>再跑一次程式，然後看看輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
條件為否
</code></pre>
<p>還有一件值得注意的是程式碼的條件判斷<strong>必須</strong>是 <code>bool</code>。如果條件不是 <code>bool</code> 的話，我們就會遇到錯誤。比方說，試試以下程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;數字為三&quot;);
    }
}
</code></pre>
<p>這次 <code>if</code> 條件計算出數值 <code>3</code>，然後 Rust 丟出錯誤給我們：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p>錯誤訊息告訴我們 Rust 預期收到 <code>bool</code> 但是卻拿到整數。這和 Ruby 和 JavaScript 就不同，Rust 不會自動將非布林值型別轉換成布林值。你永遠必須顯式提供布林值給 <code>if</code> 作為它的條件判斷。舉例來說，如果我們希望 <code>if</code> 只會在數值不為 <code>0</code> 才執行，我們可以將 <code>if</code> 表達式改成以下範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;數字不為零&quot;);
    }
}
</code></pre></pre>
<p>執行此程式碼就會印出「數字不為零」。</p>
<h4 id="使用-else-if-處理多重條件"><a class="header" href="#使用-else-if-處理多重條件">使用 <code>else if</code> 處理多重條件</a></h4>
<p>想要實現多重條件的話，你可以將 <code>if</code> 和 <code>else</code> 組合成 <code>else if</code> 表達式。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;數字可以被 4 整除&quot;);
    } else if number % 3 == 0 {
        println!(&quot;數字可以被 3 整除&quot;);
    } else if number % 2 == 0 {
        println!(&quot;數字可以被 2 整除&quot;);
    } else {
        println!(&quot;數字無法被 4、3、2 整除&quot;);
    }
}
</code></pre></pre>
<p>程式有四種可能的分支，當你執行它時你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
數字可以被 3 整除
</code></pre>
<p>當此程式執行時，他會依序檢查每一個 <code>if</code> 表達式，並執行第一個條件為 <code>true</code> 的程式碼段落。注意到雖然 6 的確可以除以 2，但我們沒有看到 <code>數字可以被 2 整除</code>，也沒有看到來自 <code>else</code> 那段的 <code>數字無法被 4、3、2 整除</code>。這是因為 Rust 只會執行第一個條件為 <code>true</code> 的區塊，而當它遇到時它就不會再檢查其他條件。</p>
<p>使用太多的 <code>else if</code> 表達式很容易讓你的程式碼變得凌亂，所以當你需要用到一個以上時，你可能會想要先重構程式碼看看。為此我們在第六章會介紹一個功能強大的 Rust 條件判斷結構叫做 <code>match</code>。</p>
<h4 id="在-let-陳述式中使用-if"><a class="header" href="#在-let-陳述式中使用-if">在 <code>let</code> 陳述式中使用 <code>if</code></a></h4>
<p>因為 <code>if</code> 是表達式，所以我們可以像範例 3-2 這樣放在 <code>let</code> 陳述式的右邊，將結果賦值給變數。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;數字結果為：{number}&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 3-2：將 <code>if</code> 表達式的結果賦值給變數</span></p>
<p>變數 <code>number</code> 會得到 <code>if</code> 表達式運算出的數值。執行此程式看看會發生什麼事：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
數字結果為：5
</code></pre>
<p>你應該還記得程式碼區塊也可以是表達式且會回傳最後一行的數值，而且數字本身也是表達式。在此例中，<code>if</code> 表達式的值取決於哪段程式碼被執行。這代表可能成為最終結果的每一個 <code>if</code> 分支必須要是相同型別。在範例 3-2 中，各分支的型別都是 <code>i32</code>。如果型別不一致的話，如以下範例所示，我們會得到錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;六&quot; };

    println!(&quot;數字結果為：{number}&quot;);
}
</code></pre>
<p>當我們嘗試編譯程式碼時，我們會得到錯誤。<code>if</code> 和 <code>else</code> 分支的型別並不一致，而且 Rust 還確切指出程式出錯的地方在哪：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;六&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<p><code>if</code> 段落的表達式運算出整數，但 <code>else</code> 的區塊卻運算出字串。這樣行不通的原因是變數只能有一個型別。Rust 必須在編譯期間確切知道變數 <code>number</code> 的型別，這樣才能驗證它的型別在任何有使用到 <code>number</code> 的地方都是有效的。要是 <code>number</code> 只能在執行時知道的話，Rust 就沒辦法這樣做了。如果編譯器必須追蹤所有變數多種可能存在的型別，那就會變得非常複雜並無法為程式碼提供足夠的保障。</p>
<h3 id="使用迴圈重複執行"><a class="header" href="#使用迴圈重複執行">使用迴圈重複執行</a></h3>
<p>重複執行同一段程式碼區塊時常是很有用的。針對這樣的任務，Rust 提供了多種產生<strong>迴圈</strong>（loops）的方式。一個迴圈會執行一段程式碼區塊，然後在結束時馬上回到區塊起始位置繼續執行。為了繼續探討迴圈，讓我們再開一個新專案 <em>loops</em>。</p>
<p>Rust 提供三種迴圈：<code>loop</code>、<code>while</code> 和 <code>for</code>。讓我們每個都嘗試看看吧。</p>
<h4 id="使用-loop-重複執行程式碼"><a class="header" href="#使用-loop-重複執行程式碼">使用 <code>loop</code> 重複執行程式碼</a></h4>
<p><code>loop</code> 關鍵字告訴 Rust 去反覆不停地執行一段程式碼直到你親自告訴它要停下來。</p>
<p>我們用以下範例示範，請修改你 <em>loops</em> 目錄下的 <em>src/main.rs</em> 檔案成以下程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;再一次！&quot;);
    }
}
</code></pre>
<p>當我們執行此程式時，我們會看到 <code>再一次！</code> 一直不停地重複顯示出來，直到我們手動停下程式為止。大多數的終端機都支援 <span class="keystroke">ctrl-c</span> 這個快捷鍵來中斷一支卡在無限迴圈的程式，你可以自己試試看：</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
再一次！
再一次！
再一次！
再一次！
^C再一次！
</code></pre>
<p><code>^C</code> 這個符號表示你按下了 <span class="keystroke">ctrl-c</span>。按照程式收到中斷訊號的時間點，你可能不會看到 <code>再一次！</code> 出現在 <code>^C</code> 之後。</p>
<p>幸運的是 Rust 有提供一個從程式中打破迴圈的方法。你可以在迴圈內加上 <code>break</code> 關鍵字告訴程式何時停止執行迴圈。回想一下我們在第二章<a href="ch02-00-guessing-game-tutorial.html#%E7%8C%9C%E5%B0%8D%E5%BE%8C%E9%9B%A2%E9%96%8B">「猜對後離開」</a><!-- ignore -->段落就做過這樣的事，當使用者猜對正確數字而獲勝時就會離開程式。</p>
<p>我們在猜謎遊戲中也用到了 <code>continue</code>。這在迴圈中會告訴程式跳過這次疊代中剩餘的程式碼，然後進行下一次疊代。</p>
<h4 id="從迴圈回傳數值"><a class="header" href="#從迴圈回傳數值">從迴圈回傳數值</a></h4>
<p>其中一種使用 <code>loop</code> 的用途是重試某些你覺得會失敗的動作，像是檢查一個執行緒是否已經完成其任務。這樣你可能就會想傳遞任務結果給之後的程式碼。要做到這樣的事，你可以在你要用來停下迴圈的 <code>break</code> 表達式內加上一個你想回傳數值，該值就會被停止的迴圈回傳，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;結果為：{result}&quot;);
}
</code></pre></pre>
<p>在迴圈之前，我們宣告了一個變數 <code>counter</code> 並初始化為 <code>0</code>，然後我們宣告了另一個變數 <code>result</code> 來取得迴圈回傳的值。在迴圈每一次的疊代中，我們將變數 <code>counter</code> 加上 <code>1</code> 並檢查它是否等於 <code>10</code>。如果是的話就用 <code>break</code> 關鍵字回傳 <code>counter * 2</code>。在迴圈結束後，我們用分號才結束這個賦值給 <code>result</code> 的陳述式。最後我們印出 <code>result</code>，而結果為 <code>20</code>。</p>
<h4 id="用迴圈標籤辨別多重迴圈"><a class="header" href="#用迴圈標籤辨別多重迴圈">用迴圈標籤辨別多重迴圈</a></h4>
<p>如果你有迴圈在迴圈之內的話，<code>break</code> 和 <code>continue</code> 會用在該位置最內層的迴圈中。你可以選擇在迴圈使用<strong>迴圈標籤（loop label）</strong>，然後使用 <code>break</code> 和 <code>continue</code> 加上那些迴圈標籤定義的關鍵字，而不是作用在最內層迴圈而已。以下是使用雙層巢狀迴圈的範例：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<p>外層迴圈有個 <code>'counting_up</code> 的標籤，而且其會從 0 數到 2。而內層沒有迴圈標籤的迴圈則會從 10 數到 9。第一個 <code>break</code> 沒有指定任何標籤只會離開內層迴圈。而陳述式 <code>break 'counting_up;</code> 則會離開外層迴圈。此程式碼會印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<h4 id="使用-while-做條件迴圈"><a class="header" href="#使用-while-做條件迴圈">使用 <code>while</code> 做條件迴圈</a></h4>
<p>在程式中用條件判斷迴圈的執行通常是很有用的。當條件為 <code>true</code> 時，迴圈就繼續執行。當條件不再是 <code>true</code> 時，程式就用 <code>break</code> 停止迴圈。這樣的循環行為可以用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 組合出來。如果你想嘗試的話，你現在就可以自己寫寫看看。但是這種模式非常常見，所以 Rust 有提供內建的結構稱為 <code>while</code> 迴圈。在範例 3-3 我們就是使用 <code>while</code> 讓該程式會循環三次，每次計數都減一，然後在迴圈之後印出訊息並離開。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;升空！！！&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 3-3：使用 <code>while</code> 迴圈，當條件符合就持續執行程式碼</span></p>
<p>這樣消除了很多使用 <code>loop</code>、<code>if</code>、<code>else</code> 與 <code>break</code> 會有的巢狀結構，這樣可以更易閱讀。當條件為 <code>true</code> 的，程式碼就執行；不然的話，它就離開迴圈。</p>
<h4 id="使用-for-遍歷集合"><a class="header" href="#使用-for-遍歷集合">使用 <code>for</code> 遍歷集合</a></h4>
<p>你可以用 <code>while</code> 來遍歷一個集合的元素，像是陣列等等。舉例來說，範例 3-4 的迴圈就會印出陣列 <code>a</code> 的每個元素。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;數值為：{}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">範例 3-4：使用 <code>while</code> 遍歷集合的每個元素</span></p>
<p>程式在此對陣列的每個元素計數，它先從索引 <code>0</code> 開始，然後持續循環直到它抵達最後一個陣列索引為止（也就是 <code>index &lt; 5</code> 不再為 <code>true</code>）。執行此程式會印出陣列裡的每個元素：</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
數值為：10
數值為：20
數值為：30
數值為：40
數值為：50
</code></pre>
<p>所有五個元素都如預期顯示在終端機上。儘管 <code>index</code> 會在某一刻達到 <code>5</code>，但是迴圈會在嘗試取得陣列第六個元素前就停止執行。</p>
<p>但這樣的方式是容易出錯的，我們可能取得錯誤的索引數值或測試條件而造成程式恐慌。這同時也使程式變慢，因為編譯器得在執行時的程式碼對迴圈中每次疊代中進行索引是否在陣列範圍內的條件檢查。</p>
<p>所以更簡潔的替代方案是，你可以使用 <code>for</code> 迴圈來對集合的每個元素執行一些程式碼。<code>for</code> 迴圈的樣子就像範例 3-5 寫的這一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;數值為：{element}&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">範例 3-5：使用 <code>for</code> 迴圈遍歷集合的每個元素</span></p>
<p>當我們執行此程式時，我們會看到和範例 3-4 一樣的結果。最重要的是，我們增加了程式的安全性，去除了造成程式錯誤的可能性。不會出現超出陣列大小或是讀取長度不足的風險。</p>
<p>比方說在範例 3-4 的程式碼，如果你變更陣列 <code>a</code> 的元素為只有 4 個，但忘記更新條件判斷為 <code>while index &lt; 4</code> 的話，程式就會恐慌。使用 <code>for</code> 迴圈的話，我們變更陣列長度時，就不需要去記得更新其他程式碼。</p>
<p><code>for</code> 迴圈的安全性與簡潔程度讓它成為 Rust 最常被使用的迴圈結構。就算你想執行的是依照次數循環的程式碼，像是範例 3-3 的 <code>while</code> 迴圈範例，多數 Rustaceans 還是會選擇 <code>for</code> 迴圈。要這麼做的方法是使用 <code>Range</code>，這是標準函式庫提供的型別，用來產生一連串的數字序列，從指定一個數字開始一直到另一個數字之前結束。</p>
<p>以下是我們用 <code>for</code> 迴圈來計數的另一種方式，它用了一個我們還沒講過的方法 <code>rev</code>，這可以用來反轉這個範圍：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{number}!&quot;);
    }
    println!(&quot;升空！！！&quot;);
}
</code></pre></pre>
<p>這樣是不是看起來好讀許多？</p>
<h2 id="總結-2"><a class="header" href="#總結-2">總結</a></h2>
<p>你做到了！這的確是篇大章節：你學到了變數、純量與複合資料型別、函式、註解、<code>if</code> 表達式以及迴圈！如果你想練習此章的概念，你可以試著打造以下程式：</p>
<ul>
<li>轉換攝氏與華氏溫度。</li>
<li>產生第 <em>n</em> 個斐波那契數字。</li>
<li>試著用重複的歌詞印出 Christmas carol 的 The Twelve Days of Christmas。</li>
</ul>
<p>當你準備好後，我們就來探討一個其他語言<strong>不常見</strong>的概念：所有權。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="理解所有權"><a class="header" href="#理解所有權">理解所有權</a></h1>
<p>所有權可以說是 Rust 最與眾不同的特色，並深深影響著整個語言。這讓 Rust 不需要垃圾回收（garbage collector）就可以保障記憶體安全，因此理解 Rust 中的所有權如何運作至關重要。在本章節，我們將討論所有權以及一些相關的功能：借用、切片與 Rust 如何在記憶體分配資料。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="什麼是所有權"><a class="header" href="#什麼是所有權">什麼是所有權？</a></h2>
<p><strong>所有權</strong>在 Rust 中用來管理程式記憶體的一系列規則。 </p>
<p>所有程式都需要在執行時管理它們使用記憶體的方式。有些語言會用垃圾回收機制，在程式執行時不斷尋找不再使用的記憶體；而有些程式，開發者必須親自分配和釋放記憶體。Rust 選擇了第三種方式：記憶體由所有權系統管理，且編譯器會在編譯時加上一些規則檢查。如果有地方違規的話，程式就無法編譯。這些所有權的規則完全不會降低執行程式的速度。</p>
<p>因為所有權對許多程式設計師來說是個全新的觀念，所以的確需要花一點時間消化。好消息是隨著你越熟悉 Rust 與所有權系統的規則，你越能輕鬆地開發出安全又高效的程式碼。加油，堅持下去！</p>
<p>當你理解所有權時，你就有一個穩健的基礎能夠理解那些使 Rust 獨特的功能。在本章節中，你將透過一些範例來學習所有權，我們會專注在一個非常常見的資料結構：字串。</p>
<blockquote>
<h3 id="堆疊stack與堆積heap"><a class="header" href="#堆疊stack與堆積heap">堆疊（Stack）與堆積（Heap）</a></h3>
<p>在許多程式語言中，你通常不需要去想到堆疊與堆積。但在像是 Rust 這樣的系統程式語言，資料是位於堆疊還是堆積就會有差，這會影響語言的行為也是你得作出某些特定決策的理由。在本章稍後討論所有權時，都會談到堆疊與堆積的關聯，所以這裡預先稍作解釋。</p>
<p>堆疊與堆積都是提供程式碼在執行時能夠使用的記憶體部分，但他們組成的方式卻不一樣。堆疊會按照它取得數值的順序依序存放它們，並以相反的順序移除數值。這通常稱為<strong>後進先出（last in, first out）</strong>。你可以把堆疊想成是盤子，當你要加入更多盤子，你會將它們疊在最上面。如果你要取走盤子的話，你也是從最上方拿走。想要從底部或中間，插入或拿走盤子都是不可行的！當我們要新增資料時，我們會稱呼為<strong>推入堆疊（pushing onto the stack）</strong>，而移除資料則是叫做<strong>彈出堆疊（popping off the stack）</strong>。所有在堆疊上的資料都必須是已知固定大小。在編譯時屬於未知或可能變更大小的資料必須儲存在堆積。</p>
<p>堆積就比較沒有組織，當你要將資料放入堆積，你得要求一定大小的空間。記憶體分配器（memory allocator）會找到一塊夠大的空位，標記為已佔用，然後回傳一個<strong>指標（pointer）</strong>，指著該位置的位址。這樣的過程稱為<strong>在堆積上分配（allocating on the heap）</strong>，或者有時直接簡稱為<strong>分配</strong>（allocating）就好（將數值放入堆疊不會被視為是在分配）。因為指標是固定已知的大小，所以你可以存在堆疊上。但當你要存取實際資料時，你就得去透過指標取得資料。你可以想像成是一個餐廳。當你進入餐廳時，你會告訴服務員你的團體有多少人，他就會將你們帶到足夠人數的餐桌。如果你的團體有人晚到的話，他們可以直接詢問你坐在哪而找到你。</p>
<p>將資料推入堆疊會比在堆積上分配還來的快，因為分配器不需要去搜尋哪邊才能存入新資料，其位置永遠在堆疊最上方。相對的，堆積就需要比較多步驟，分配器必須先找到一個夠大的空位來儲存資料，然後作下紀錄為下次分配做準備。</p>
<p>在堆積上取得資料也比在堆疊上取得來得慢，因為你需要用追蹤指標才找的到。現代的處理器如果在記憶體間跳轉越少的話速度就越快。讓我們繼續用餐廳做比喻，想像伺服器就是在餐廳為數個餐桌點餐。最有效率的點餐方式就是依照餐桌順序輪流點餐。如果幫餐桌 A 點了餐之後跑到餐桌 B 點，又跑回到 A 然後又跑到 B 的話，可以想像這是個浪費時間的過程。同樣的道理，處理器在處理任務時，如果處理的資料相鄰很近（就如同存在堆疊）的話，當然比相鄰很遠（如同存在堆積）來得快。</p>
<p>當你的程式碼呼叫函式時，傳遞給函式的數值（可能包含指向堆積上資料的指標）與函式區域變數會被推入堆疊。當函式結束時，這些數值就會被彈出。</p>
<p>追蹤哪部分的程式碼用到了堆積上的哪些資料、最小化堆積上的重複資料、以及清除堆積上沒在使用的資料確保你不會耗盡空間，這些問題都是所有權系統要處理的。一旦你理解所有權後，你通常就不再需要經常考慮堆疊與堆積的問題，不過能理解所有權主要就是為了管理堆積有助於解釋為何它要這樣運作。</p>
</blockquote>
<h3 id="所有權規則"><a class="header" href="#所有權規則">所有權規則</a></h3>
<p>首先，讓我們先看看所有權規則。當我們在解釋說明時，請記得這些規則：</p>
<ul>
<li>Rust 中每個數值都有個<strong>擁有者（owner）</strong>。</li>
<li>同時間只能有一個擁有者。</li>
<li>當擁有者離開作用域時，數值就會被丟棄。</li>
</ul>
<h3 id="變數作用域"><a class="header" href="#變數作用域">變數作用域</a></h3>
<p>現在既然我們已經知道了基本語法，我們接下來就不再將 <code>fn main() {</code> 寫進程式碼範例範例中。所以你在參考時，請記得親自寫在 <code>main</code> 函式內。這樣一來，我們的範例可以更加簡潔，讓我們更加專注在細節而非樣板程式。</p>
<p>作為所有權的第一個範例，我們先來看變數的<strong>作用域（scope）</strong>。作用域是一些項目在程式內的有效範圍。假設我們有以下變數：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>變數 <code>s</code> 是一個字串字面值（string literal），而字串數值是寫死在我們程式內。此變數的有效範圍是從它宣告開始一直到當前<strong>作用域</strong>結束為止。範例 4-1 註解了 <code>s</code> 在哪裡是有效的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s 在此處無效，因為它還沒宣告
        let s = &quot;hello&quot;;   // s 在此開始視為有效

        // 使用 s
    }                      // 此作用域結束， s 不再有效
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 4-1：變數與它在作用域的有效範圍</span></p>
<p>換句話說，這裡有兩個重要的時間點：</p>
<ul>
<li>當 <code>s</code> <strong>進入</strong>作用域時，它是有效的。</li>
<li>它持續被視為有效直到它<strong>離開</strong>作用域為止。</li>
</ul>
<p>目前為止，變數何時有效與作用域的關係都還跟其他程式語言相似。現在我們要以此基礎來介紹 <code>String</code> 型別</p>
<h3 id="string-型別"><a class="header" href="#string-型別"><code>String</code> 型別</a></h3>
<p>要能夠解釋所有權規則，我們需要使用比第三章的<a href="ch03-02-data-types.html#data-types">「資料型別」</a><!-- ignore -->介紹過的還複雜的型別才行。之前我們提到的型別都是已知固定大小且儲存在堆疊上的，在作用域結束時就會從堆疊中彈出。而且如果其它部分的程式碼需要在不同作用域使用相同數值的話，它們都能迅速簡單地透過複製產生新的單獨實例。但是我們想要觀察的是儲存在堆積上的資料，並研究 Rust 是如何知道要清理資料的。而 <code>String</code> 型別正是個絕佳範例。</p>
<p>我們專注在 <code>String</code> 與所有權有關的部分。這些部分也適用於其他基本函式庫或你自己定義的複雜資料型別。我們會在<a href="ch08-02-strings.html">第八章</a><!-- ignore -->更深入探討 <code>String</code>。</p>
<p>我們已經看過字串字面值（string literals），字串的數值是寫死在我們的程式內的。字串字面值的確很方便，但它不可能完全適用於我們使用文字時的所有狀況。其中一個原因是因為它是不可變的，另一個原因是並非所有字串值在我們編寫程式時就會知道。舉例來說，要是我們想要收集使用者的輸入並儲存它呢？對於這些情形，Rust 提供第二種字串型別 <code>String</code>。此型別管理分配在堆積上的資料，所以可以儲存我們在編譯期間未知的一些文字。你可以從字串字面值使用 <code>from</code> 函式來建立一個 <code>String</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>雙冒號 <code>::</code> 讓我們可以將 <code>from</code> 函式置於 <code>String</code> 型別的命名空間（namespace）底下，而不是取像是 <code>string_from</code> 這樣的名稱。我們將會在第五章的<a href="ch05-03-method-syntax.html#method-syntax">「方法語法」</a><!-- ignore -->討論這個語法，並在第七章的<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">「參考模組項目的路徑」</a><!-- ignore -->討論模組（modules）與命名空間。</p>
<p>這種類型的字串是<strong>可以</strong>被改變的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() 將字面值加到字串後面

    println!(&quot;{}&quot;, s); // 這會印出 `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>所以這邊有何差別呢？為何 <code>String</code> 是可變的，但字面值卻不行？兩者最主要的差別在於它們對待記憶體的方式。</p>
<h3 id="記憶體與分配"><a class="header" href="#記憶體與分配">記憶體與分配</a></h3>
<p>以字串字面值來說，我們在編譯時就知道它的內容，所以可以寫死在最終執行檔內。這就是為何字串字面值非常迅速且高效。但這些特性均來自於字串字面值的不可變性。不幸的是我們無法將編譯時未知大小的文字，或是執行程式時大小可能會改變的文字等對應記憶體塞進執行檔中。</p>
<p>而對於 <code>String</code> 型別來說，為了要能夠支援可變性、改變文字長度大小，我們需要在堆積上分配一塊編譯時未知大小的記憶體來儲存這樣的內容，這代表：</p>
<ul>
<li>記憶體分配器必須在執行時請求記憶體。</li>
<li>我們不再需要這個 <code>String</code> 時，我們需要以某種方法將此記憶體還給分配器。</li>
</ul>
<p>當我們呼叫 <code>String::from</code> 時就等於完成第一個部分，它的實作會請求分配一塊它需要的記憶體。這邊大概和其他程式語言都一樣。</p>
<p>不過第二部分就不同了。在擁有<strong>垃圾回收機制</strong>（garbage collector, GC）的語言中，GC 會追蹤並清理不再使用的記憶體，所以我們不用去擔心這件事。沒有 GC 的話，識別哪些記憶體不再使用並顯式呼叫程式碼釋放它們就是我們的責任了，就像我們請求取得它一樣。在以往的歷史我們可以看到要完成這件事是一項艱鉅的任務，如果我們忘了，那麼就等於在浪費記憶體。如果我們釋放的太早的話，我們則有可能會拿到無效的變數。要是我們釋放了兩次，那也會造成程式錯誤。我們必須準確無誤地配對一個 <code>allocate</code> 給剛好一個 <code>free</code>。</p>
<p>Rust 選擇了一條不同的道路：當記憶體在擁有它的變數離開作用域時就會自動釋放。以下是我們解釋作用域的範例 4-1，但使用的是 <code>String</code> 而不是原本的字串字面值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s 在此開始視為有效

        // 使用 s
    }                                  // 此作用域結束
                                       // s 不再有效
<span class="boring">}
</span></code></pre></pre>
<p>當 <code>s</code> 離開作用域時，我們就可以很自然地將 <code>String</code> 所需要的記憶體釋放回分配器。當變數離開作用域時，Rust 會幫我們呼叫一個特殊函式。此函式叫做 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a><!-- ignore -->，在這裡當時 <code>String</code> 的作者就可以寫入釋放記憶體的程式碼。Rust 會在大括號結束時自動呼叫 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++，這樣在項目生命週期結束時釋放資源的模式，有時被稱為<strong>資源取得即初始化（Resource Acquisition Is Initialization, RAII）</strong>。如果你已經用過 RAII 的模式，那麼你應該就會很熟悉 Rust 的 <code>drop</code> 函式。</p>
</blockquote>
<p>這樣的模式對於 Rust 程式碼的編寫有很深遠的影響。雖然現在這樣看起來很簡單，但在更多複雜的情況下程式碼的行為可能會變得很難預測。像是當我們需要許多變數，所以得在堆積上分配它們的情況。現在就讓我們開始來探討這些情形。</p>
<h4 id="變數與資料互動的方式移動move"><a class="header" href="#變數與資料互動的方式移動move">變數與資料互動的方式：移動（Move）</a></h4>
<p>數個變數在 Rust 中可以有許多不同方式來與相同資料進行互動。讓我們看看使用整數的範例 4-2。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 4-2：將變數 <code>x</code> 的數值賦值給 <code>y</code></span></p>
<p>我們大概可以猜到這做了啥：「<code>x</code> 取得數值 <code>5</code>，然後拷貝（copy）了一份 <code>x</code> 的值給 <code>y</code>。」所以我們有兩個變數 <code>x</code> 與 <code>y</code>，而且都等於 <code>5</code>。這的確是我們所想的這樣，因為整數是已知且固定大小的簡單數值，所以這兩個數值 <code>5</code> 都會推入堆疊中。</p>
<p>現在讓我們看看 <code>String</code> 的版本：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>這和之前的程式碼非常相近，所以我們可能會認為它做的事也是一樣的：也就是第二行也會拿到一份 <code>s1</code> 拷貝的值給 <code>s2</code>。但事實上卻不是這樣。</p>
<p>請看看圖示 4-1 來瞭解 <code>String</code> 底下的架構到底長什麼樣子。一個 <code>String</code> 由三個部分組成，如圖中左側所示：一個指向儲存字串內容記憶體的指標、它的長度和它的容量。這些資料是儲存在堆疊上的，但圖右的內容則是儲存在堆積上。</p>
<p><img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" /></p>
<p><span class="caption">圖示 4-1：將數值 <code>&quot;hello&quot;</code> 賦值給 <code>s1</code> 的 <code>String</code> 記憶體結構</span></p>
<p>長度指的是目前所使用的 <code>String</code> 內容在記憶體以位元組為單位所佔用的大小。而容量則是 <code>String</code> 從分配器以位元組為單位取得的總記憶體量。長度和容量的確是有差別的，但現在對我們來說還不太重要，你現在可以先忽略容量的問題。</p>
<p>當我們將 <code>s1</code> 賦值給 <code>s2</code>，<code>String</code> 的資料會被拷貝，不過我們拷貝的是堆疊上的指標、長度和容量。我們不會拷貝指標指向的堆積資料。資料以記憶體結構表示的方式會如圖示 4-2 表示。</p>
<p><img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">圖示 4-2：<code>s2</code> 擁有一份 <code>s1</code> 的指標、長度和容量的記憶體結構</span></p>
<p>所以實際上的結構<strong>不會</strong>長的像圖示 4-3 這樣，如果 Rust 也會拷貝堆積資料的話，才會看起來像這樣。如果 Rust 這麼做的話，<code>s2 = s1</code> 的動作花費會變得非常昂貴。當堆積上的資料非常龐大時，對執行時的性能影響是非常顯著的。</p>
<p><img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">圖示 4-3：如果 Rust 也會拷貝堆積資料，<code>s2 = s1</code> 可能會長得樣子</span></p>
<p>稍早我們提到當變數離開作用域時，Rust 會自動呼叫 <code>drop</code> 函式並清理該變數在堆積上的資料。但圖示 4-2 顯示兩個資料指標都指向相同位置，這會造成一個問題。當 <code>s2</code> 與 <code>s1</code> 都離開作用域時，它們都會嘗試釋放相同的記憶體。這被稱呼為<strong>雙重釋放</strong>（double free）錯誤，也是我們之前提過的錯誤之一。釋放記憶體兩次可能會導致記憶體損壞，進而造成安全漏洞。</p>
<p>為了保障記憶體安全，在此情況中 Rust 還會再做一件重要的事。在 <code>let s2 = s1;</code> 之後，Rust 就不再將 <code>s1</code> 視爲有效。因此當 <code>s1</code> 離開作用域時，Rust 不需要釋放任何東西。請看看如果在 <code>s2</code> 建立之後繼續使用 <code>s1</code> 會發生什麼事，以下程式就執行不了：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<p>你會得到像這樣的錯誤，因為 Rust 會防止你使用無效的參考：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>如果你在其他語言聽過<strong>淺拷貝（shallow copy）<strong>和</strong>深拷貝（deep copy）<strong>這樣的詞，拷貝指標、長度和容量而沒有拷貝實際內容這樣的概念應該就相近於淺拷貝。但因為 Rust 同時又無效化第一個變數，我們不會叫此為淺拷貝，而是稱此動作為</strong>移動（move）</strong>。在此範例我們會稱 <code>s1</code> <strong>被移動</strong>到 <code>s2</code>，所以實際上發生的事長得像圖示 4-4 這樣。</p>
<p><img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" /></p>
<p><span class="caption">圖示 4-4：<code>s1</code> 無效後的記憶體結構</span></p>
<p>這樣就解決了問題！只有 <code>s2</code> 有效的話，當它離開作用域，就只有它會釋放記憶體，我們就完成所有動作了。</p>
<p>除此之外，這邊還表達了另一個設計決策：Rust 永遠不會自動將你的資料建立「深拷貝」。因此任何<strong>自動</strong>的拷貝動作都可以被視為是對執行效能影響很小的。</p>
<h4 id="變數與資料互動的方式克隆clone"><a class="header" href="#變數與資料互動的方式克隆clone">變數與資料互動的方式：克隆（Clone）</a></h4>
<p>要是我們<strong>真的想</strong>深拷貝 <code>String</code> 在堆積上的資料而非僅是堆疊資料的話，我們可以使用一個常見的方法（method）叫做 <code>clone</code>。我們會在第五章講解方法語法，不過既然方法是很常見的程式語言功能，你很可能已經有些概念了。</p>
<p>以下是 <code>clone</code> 方法運作的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼能執行無誤，並明確作出了像圖示 4-3 這樣的行為，也就是堆積資料<strong>的確</strong>被複製了一份。</p>
<p>當你看到 <code>clone</code> 的呼叫，你就會知道有一些特定的程式碼被執行且消費可能是相對昂貴的。你可以很清楚地知道有些不同的行為正在發生。</p>
<h4 id="只在堆疊上的資料拷貝copy"><a class="header" href="#只在堆疊上的資料拷貝copy">只在堆疊上的資料：拷貝（Copy）</a></h4>
<p>還有一個小細節我們還沒提到，也就是我們在使用整數時的程式碼。回想一下範例 4-2 是這樣寫的，它能執行而且是有效的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但這段程式碼似乎和我們剛學的互相矛盾：我們沒有呼叫 <code>clone</code>，但 <code>x</code> 卻仍是有效的，沒有移動到 <code>y</code>。</p>
<p>原因是因為像整數這樣的型別在編譯時是已知大小，所以只會存在在堆疊上。所以要拷貝一份實際數值的話是很快的。這也讓我們沒有任何理由要讓 <code>x</code> 在 <code>y</code> 建立後被無效化。換句話說，這邊沒有所謂淺拷貝與深拷貝的差別。所以這邊呼叫 <code>clone</code> 的話不會與平常的淺拷貝有啥不一樣，我們可以保持這樣就好。</p>
<p>Rust 有個特別的標記叫做 <code>Copy</code> 特徵（trait）可以用在標記像整數這樣存在堆疊上的型別（我們會在<a href="ch10-02-traits.html">第十章</a><!-- ignore -->討論什麼是特徵）。如果一個型別有 <code>Copy</code> 特徵的話，一個變數在賦值給其他變數後仍然會是有效的。</p>
<p>如果一個型別有實作（implement）<code>Drop</code> 特徵的話，Rust 不會允許我們讓此型別擁有 <code>Copy</code> 特徵。如果我們對某個型別在數值離開作用域時，需要再做特別處理的話，我們對此型別標註 <code>Copy</code> 特徵會在編譯時期產生錯誤。想要瞭解如何為你的型別實作 <code>Copy</code> 特徵的話，請參考附錄 C <a href="appendix-03-derivable-traits.html">「可推導的特徵」</a><!-- ignore -->。</p>
<p>所以哪些型別有實作 <code>Copy</code> 特徵呢？你可以閱讀技術文件來知道哪些型別有，但基本原則是任何簡單地純量數值都可以實作 <code>Copy</code>，且不需要分配記憶體或任何形式資源的型別也有實作 <code>Copy</code>。以下是一些有實作 <code>Copy</code> 的型別：</p>
<ul>
<li>所有整數型別像是 <code>u32</code>。</li>
<li>布林型別 <code>bool</code>，它只有數值 <code>true</code> 與 <code>false</code>。</li>
<li>所有浮點數型別像是 <code>f64</code>。</li>
<li>字元型別 <code>char</code>。</li>
<li>元組，不過包含的型別也都要有實作 <code>Copy</code> 才行。比如 <code>(i32, i32)</code> 就有實作 <code>Copy</code>，但 <code>(i32, String)</code> 則無。</li>
</ul>
<h3 id="所有權與函式"><a class="header" href="#所有權與函式">所有權與函式</a></h3>
<p>傳遞數值給函式的方式和賦值給變數是類似的。傳遞變數給函式會是移動或拷貝，就像賦值一樣。範例 4-3 說明了變數如何進入且離開作用域。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 進入作用域

    takes_ownership(s);             // s 的值進入函式
                                    // 所以 s 也在此無效

    let x = 5;                      // x 進入作用域

    makes_copy(x);                  // x 本該移動進函式裡
                                    // 但 i32 有 Copy，所以 x 可繼續使用

} // x 在此離開作用域，接著是 s。但因為 s 的值已經被移動了
  // 它不會有任何動作

fn takes_ownership(some_string: String) { // some_string 進入作用域
    println!(&quot;{}&quot;, some_string);
} // some_string 在此離開作用域並呼叫 `drop`
  // 佔用的記憶體被釋放

fn makes_copy(some_integer: i32) { // some_integer 進入作用域
    println!(&quot;{}&quot;, some_integer);
} // some_integer 在此離開作用域，沒有任何動作發生
</code></pre></pre>
<p><span class="caption">範例 4-3：具有所有權的函式</span></p>
<p>如果我們嘗試在呼叫 <code>takes_ownership</code> 後使用 <code>s</code>，Rust 會拋出編譯時期錯誤。這樣的靜態檢查可以免於我們犯錯。你可以試試看在 <code>main</code> 裡哪裡可以使用 <code>s</code> 和 <code>x</code>，以及所有權規則如何防止你寫錯。</p>
<h3 id="回傳值與作用域"><a class="header" href="#回傳值與作用域">回傳值與作用域</a></h3>
<p>回傳值一樣能轉移所有權，範例 4-4 和範例 4-3 一樣加上了註解說明一個函式如何回傳些數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership 移動它的回傳值給 s1

    let s2 = String::from(&quot;哈囉&quot;);     // s2 進入作用域

    let s3 = takes_and_gives_back(s2);  // s2 移入 takes_and_gives_back
                                        // 該函式又將其回傳值移到 s3
} // s3 在此離開作用域並釋放
  // s2 已被移走，所以沒有任何動作發生
  // s1 離開作用域並釋放

fn gives_ownership() -&gt; String {             // gives_ownership 會將他的回傳值
                                             // 移動給呼叫它的函式

    let some_string = String::from(&quot;你的字串&quot;); // some_string 進入作用域

    some_string                              // 回傳 some_string 並移動給
                                             // 呼叫它的函式
}

// 此函式會取得一個 String 然後回傳它
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 進入作用域

    a_string  // 回傳 a_string 並移動給呼叫的函式
}
</code></pre></pre>
<p><span class="caption">範例 4-4：轉移回傳值的所有權</span></p>
<p>變數的所有權每次都會遵從相同的模式：賦值給其他變數就會移動。當擁有堆積資料的變數離開作用域時，該數值就會被 <code>drop</code> 清除，除非該資料的所有權被移動到其他變數所擁有。</p>
<p>雖然這樣是正確的，但在每個函式取得所有權再回傳所有權的確有點囉唆。要是我們可以讓函式使用一個數值卻不取得所有權呢？要是我們想重複使用同個值，但每次都要傳入再傳出實在是很麻煩。而且我們有時也會想要讓函式回傳一些它們自己產生的值。</p>
<p>Rust 能讓我們使用元組回傳多個數值，如範例 4-5 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;'{}' 的長度為 {}。&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 回傳 String 的長度

    (s, length)
}
</code></pre></pre>
<p><span class="caption">範例 4-5：回傳參數的所有權</span></p>
<p>但這實在太繁瑣，而且這樣的情況是很常見的。幸運的是 Rust 有提供一個概念能在不轉移所有權的狀況下使用數值，這叫做<strong>參考（references）</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="參考與借用"><a class="header" href="#參考與借用">參考與借用</a></h2>
<p>我們在範例 4-5 使用元組的問題在於，我們必須回傳 <code>String</code> 給呼叫的函式，我們才能繼續在呼叫 <code>calculate_length</code> 之後繼續使用 <code>String</code>，因為 <code>String</code> 會被傳入 <code>calculate_length</code>。不過我們其實可以提供個 <code>String</code> 數值的參考。<strong>參考（references）</strong> 就像是指向某個地址的指標，我們可以追蹤存取到該處儲存的資訊，而該地址仍被其他變數所擁有。和指標不一樣的是，參考保證所指向的特定型別的數值一定是有效的。</p>
<p>以下是我們定義並使用 <code>calculate_length</code> 時，在參數改用參考物件而非取得所有權的程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;'{}' 的長度為 {}。&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>首先你會注意到原先變數宣告與函式回傳值會用到元組的地方都被更改了。再來注意到我們傳遞的是 <code>&amp;s1</code> 給 <code>calculate_length</code>，然後在定義時我們是取 <code>&amp;String</code> 而非 <code>String</code>。這些「&amp;」符號就是<strong>參考</strong>，它們允許你不必獲取所有權來參考它。以下用圖示 4-5 示意。 </p>
<p><img alt="Three tables: the table for s contains only a pointer to the table
for s1. The table for s1 contains the stack data for s1 and points to the
string data on the heap." src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">圖示 4-5：顯示 <code>&amp;String s</code> 指向 <code>String s1</code> 的示意圖</span></p>
<blockquote>
<p>注意：使用 <code>&amp;</code> 參考的反向動作是<strong>解參考（dereferencing）</strong>，使用的是解參考運算符號 <code>*</code>。我們會在第八章看到一些解參考的範例並在第 15 章詳細解釋解參考。</p>
</blockquote>
<p>讓我們進一步看看函式的呼叫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;'{}' 的長度為 {}。&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p><code>&amp;s1</code> 語法讓我們可以建立一個指向 <code>s1</code> 數值的參考，但不會擁有它。因為它並沒有所有權，它所指向的資料在不再使用參考後並不會被丟棄。</p>
<p>同樣地，函式簽名也是用 <code>&amp;</code> 說明參數 <code>s</code> 是個參考。讓我們加一些註解在範例上：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;'{}' 的長度為 {}。&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s 是個 String 的參考
    s.len()
} // s 在此離開作用域，但因為它沒有它所指向的資料的所有權
  // 所以不會被釋放掉
</code></pre></pre>
<p>變數 <code>s</code> 有效的作用域和任何函式參數的作用域一樣，但當不再使用參考時，參考所指向的數值不會被丟棄，因為我們沒有所有權。當函式使用參考作為參數而非實際數值時，我們不需要回傳數值來還所有權，因為我們不曾擁有過。</p>
<p>我們會稱呼建立參考這樣的動作叫做<strong>借用（borrowing）</strong>。就像現實世界一樣，如果有人擁有每項東西，他可以借用給你。當你使用完後，你就還給他。你並不擁有它。</p>
<p>所以要是我們嘗試修改我們借用的東西會如何呢？請試試範例 4-6 的程式碼。直接劇透你：它執行不了的！</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">範例 4-6：嘗試修改借用的值</span></p>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(&quot;, world&quot;);
| ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>如同變數預設是不可變，參考也是一樣的。我們不被允許修改我們參考的值。</p>
<h3 id="可變參考"><a class="header" href="#可變參考">可變參考</a></h3>
<p>我們可以修正範例 4-6 的程式碼，讓我們可以變更借用的數值。我們可以加一點小修改，改用<strong>可變參考</strong>就好：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>首先我們將 <code>s</code> 加上了 <code>mut</code>，然後我們在呼叫 <code>change</code> 函式的地方建立了一個可變參考 <code>&amp;mut s</code>，然後更新函式的簽章成 <code>some_string: &amp;mut String</code> 來接收這個可變參考。這樣能清楚表達 <code> change</code> 函式會改變它借用的參考。</p>
<p>可變參考有個很大的限制：如果你有一個數值的可變參考，你就無法再對該數值有其他任何參考。所以嘗試建立兩個 <code>s</code> 的可變參考的話就會失敗，如以下範例所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<p>以下是錯誤資訊：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>此錯誤表示此程式碼是無效的，因爲我們無法同時可變借用 <code>s</code> 超過一次。第一次可變借用在 <code>r1</code> 且必須持續到它在 <code>println!</code> 用完爲止，但在其產生到使用之間，我們嘗試建立了另一個借用了與 <code>r1</code> 相同資料的可變借用 <code>r2</code>。</p>
<p>這項防止同時間對相同資料進行多重可變參考的限制允許了可變行為，但是同時也受到一定程度的約束。這通常是新 Rustaceans 遭受挫折的地方，因為多數語言都會任你去改變其值。這項限制的好處是 Rust 可以在編譯時期就防止資料競爭（data races）。<strong>資料競爭</strong>和競爭條件（race condition）類似，它會由以下三種行為引發：</p>
<ul>
<li>同時有兩個以上的指標存取同個資料。</li>
<li>至少有一個指標在寫入資料。</li>
<li>沒有針對資料的同步存取機制。</li>
</ul>
<p>資料競爭會造成未定義行為（undefined behavior），而且在執行時你通常是很難診斷並修正的。Rust 能夠阻止這樣的問題發生，不讓有資料競爭的程式碼編譯通過！</p>
<p>如往常一樣，我們可以用大括號來建立一個新的作用域來允許多個可變參考，只要不是同時擁有就好：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 離開作用域，所以建立新的參考也不會有問題

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Rust 對於可變參考和不可變參考的組合中也實施著類似的規則，以下程式碼就會產生錯誤：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // 沒問題
    let r2 = &amp;s; // 沒問題
    let r3 = &amp;mut s; // 很有問題！

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>哇！看來我們<strong>也不可以</strong>擁有不可變參考的同時擁有可變參考。</p>
<p>擁有不可變參考的使用者可不希望有人暗地裡突然改變了值！不過數個不可變參考是沒問題的，因為所有在讀取資料的人都無法影響其他人閱讀資料。</p>
<p>請注意參考的作用域始於它被宣告的地方，一直到它最後一次參考被使用為止。舉例來說以下程式就可以編譯，因為不可變參考最後一次的使用（<code>println!</code>）在可變參考宣告之前：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // 沒問題
    let r2 = &amp;s; // 沒問題
    println!(&quot;{} and {}&quot;, r1, r2);
    // 變數 r1 和 r2 將不再使用
    
    let r3 = &amp;mut s; // 沒問題
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>不可變參考 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 之後結束。這是它們最後一次使用到的地方，也就是在宣告可變參考 <code>r3</code> 之前。它們的作用域沒有重疊，所以程式碼是允許的：編譯器能辨別出參考何時在作用域之前不再被使用。</p>
<p>雖然借用錯誤有時是令人沮喪的，但請記得這是 Rust 編譯器希望提前（在編譯時而非執行時）指出潛在程式錯誤並告訴你問題的源頭在哪。這樣你就不必親自追蹤為何你的資料跟你預期的不一樣。</p>
<h3 id="迷途參考"><a class="header" href="#迷途參考">迷途參考</a></h3>
<p>在有指標的語言中，通常都很容易不小心產生<strong>迷途指標（dangling pointer）</strong>。當資源已經被釋放但指標卻還留著，這樣的指標指向的地方很可能就已經被別人所有了。相反地，在 Rust 中編譯器會保證參考絕不會是迷途參考：如果你有某些資料的參考，編譯器會確保資料不會在參考結束前離開作用域。</p>
<p>讓我們來嘗試產生迷途指標，看看 Rust 怎麼產生編譯期錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                 +++++++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>此錯誤訊息包含了一個我們還沒介紹的功能：生命週期（lifetimes）。我們會在第十章詳細討論生命週期。就算我們先不管生命週期的部分，錯誤訊息仍然告訴了我們程式出錯的關鍵點：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from
</code></pre>
<p>讓我們進一步看看我們的 <code>dangle</code> 程式碼每一步發生了什麼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // 回傳 String 的迷途參考

    let s = String::from(&quot;hello&quot;); // s 是個新 String

    &amp;s // 我們回傳 String s 的參考
} // s 在此會離開作用域並釋放，它的記憶體就不見了。
  // 危險！
</code></pre>
<p>因為 <code>s</code> 是在 <code>dangle</code> 內產生的，當 <code>dangle</code> 程式碼結束時，<code>s</code> 會被釋放。但我們卻嘗試回傳參考。此參考會指向一個已經無效的 <code>String</code>。這看起來不太優！Rust 不允許我們這麼做。</p>
<p>解決的辦法是直接回傳 <code>String</code> 就好：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<p>這樣就沒問題了。所有權轉移了出去，沒有任何值被釋放。</p>
<h3 id="參考規則"><a class="header" href="#參考規則">參考規則</a></h3>
<p>讓我們來回顧我們討論到的參考規則：</p>
<ul>
<li>在任何時候，我們要嘛<strong>只能有</strong>一個可變參考，要嘛可以有<strong>任意數量</strong>的不可變參考。</li>
<li>參考必須永遠有效。</li>
</ul>
<p>接下來我們要來看看一個不太一樣的參考型別：切片（slices）。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="切片型別"><a class="header" href="#切片型別">切片型別</a></h2>
<p><strong>切片（slice）</strong> 讓你可以參考一串集合中的元素序列，而並非參考整個集合。切片也算是某種類型的參考，所以它沒有所有權。</p>
<p>以下是個小小的程式問題：寫一支函式接收一串用空格分開單字的字串，並回傳第一個找到的單字，如果函式沒有在字串找到空格的話，就代表整個字串就是一個單字，所以就回傳整個字串。</p>
<p>我們先來想看看不使用切片的話，以下函式的簽名會長怎樣。這有助於我們理解切片想解決什麼問題：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>此函式 <code>first_word</code> 有一個參數 <code>&amp;String</code>。我們不需要取得所有權，所以這是合理的。但我們該回傳啥呢？我們目前還沒有方法能夠描述一個字串的<strong>其中一部分</strong>。不過我們可以回傳該單字的最後一個索引，也就是和空格作比較。讓我們像範例 4-7 這樣試試看。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 4-7：函式 <code>first_word</code> 回傳參數 <code>String</code> 第一個單字最後的索引</span></p>
<p>因為我們需要遍歷 <code>String</code> 的每個元素並檢查該值是否為空格，我們要用 <code>as_bytes</code> 方法將 <code>String</code> 轉換成一個位元組陣列。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>接下來我們使用 <code>iter</code> 方法對位元組陣列建立一個疊代器（iterator）：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>我們會在<a href="ch13-02-iterators.html">第十三章</a><!-- ignore -->討論疊代器的細節。現在我們只需要知道 <code>iter</code> 是個能夠回傳集合中每個元素的方法，然後 <code>enumerate</code> 會將 <code>iter</code> 的結果包裝起來回傳成元組。<code>enumerate</code> 回傳的元組中的第一個元素是索引，第二個才是元素的參考。這樣比我們自己計算索引還來的方便。</p>
<p>既然 <code>enumerate</code> 回傳的是元組，我們可以用模式配對來解構元組。我們會在<a href="ch06-02-match.html#patterns-that-bind-to-values">第六章</a><!-- ignore -->進一步解釋模式配對。所以在 <code>for</code> 迴圈中，我們指定了一個模式讓 <code>i</code> 取得索引然後 <code>&amp;item</code> 取得元組中的位元組。因為我們從用 <code>.iter().enumerate()</code> 取得參考的，所以在模式中我們用的是 <code>&amp;</code> 來獲取。</p>
<p>在 <code>for</code> 迴圈裡面我們使用字串字面值的語法搜尋位元組是不是空格。如果我們找到空格的話，我們就回傳該位置。不然我們就用 <code>s.len()</code> 回傳整個字串的長度。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>我們現在有了一個能夠找到字串第一個單字結尾索引的辦法，但還有一個問題。我們回傳的是一個獨立的 <code>usize</code>，它套用在 <code>&amp;String</code> 身上才有意義。換句話說，因為它是個與 <code>String</code> 沒有直接關係的數值，我們無法保證它在未來還是有效的。參考一下使用了範例 4-7 中函式 <code>first_word</code> 的範例 4-8：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word 取得數值 5

    s.clear(); // 這會清空 String，這就等於 &quot;&quot;

    // word 仍然是數值 5 ，但是我們已經沒有相等意義的字串了
    // 擁有 5 的變數 word 現在完全沒意義！
}
</code></pre></pre>
<p><span class="caption">範例 4-8：先儲存呼叫函式 <code>first_word</code>的結果再變更 <code>String</code> 的內容</span></p>
<p>此程式可以成功編譯沒有任何錯誤，而且我們在呼叫 <code>s.clear()</code> 後仍然能使用 <code>word</code>。因為 <code>word</code> 和 <code>s</code> 並沒有直接的關係，<code>word</code> 在之後仍能繼續保留 <code>5</code>。我們可以用 <code>s</code> 取得 <code>5</code> 並嘗試取得第一個單字。但這樣就會是程式錯誤了，因為 <code>s</code> 的內容自從我們賦值 <code>5</code> 給 <code>word</code> 之後的內容已經被改變了。</p>
<p>要隨時留意 <code>word</code> 會不會與 <code>s</code> 的資料脫鉤是很煩瑣的且容易出錯！要是我們又寫了個函式 <code>second_word</code>，管理這些索引會變得非常難以管控！我們會不得不將函式簽名改成這樣：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>現在我們得同時紀錄起始<strong>與</strong>結束的索引，而且我們還產生了更多與原本數值沒辦法直接相關的計算結果。我們現在有三個非直接相關的變數需要保持同步。</p>
<p>幸運的是 Rust 為此提供了一個解決辦法：字串切片（String slice）。</p>
<h3 id="字串切片"><a class="header" href="#字串切片">字串切片</a></h3>
<p><strong>字串切片</strong>是 <code>String</code> 其中一部分的參考，它長得像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>與其參考整個 <code>String</code>，<code>hello</code> 只參考了一部分的<code>String</code>，透過 <code>[0..5]</code> 來指示。我們可以像這樣 <code>[起始索引..結束索引]</code> 用中括號加上一個範圍來建立切片。<code>起始索引</code> 是切片的第一個位置，而 <code>結束索引</code> 在索引結尾之後的位置（所以不包含此值）。在內部的切片資料結構會儲存起始位置，以及 <code>結束索引</code> 與 <code>起始索引</code> 相減後的長度。所以用 <code>let world = &amp;s[6..11];</code> 作為例子的話， <code>world</code> 就會是個切片，包含一個指標指向索引爲 6 的位元組 <code>s</code> 和一個長度數值 <code>5</code>。</p>
<p>圖示 4-6 就是此例的示意圖。</p>
<p><img alt="Three tables: a table representing the stack data of s, which points
to the byte at index 0 in a table of the string data &quot;hello world&quot; on
the heap. The third table rep-resents the stack data of the slice world, which
has a length value of 5 and points to byte 6 of the heap data table."
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">圖示 4-6：指向部分 <code>String</code> 的字串切片</span></p>
<p>要是你想用 Rust 指定範圍的語法 <code>..</code> 從索引 0 開始的話，你可以省略兩個句點之前的值。換句話說，以下兩個是相等的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>同樣地，如果你的切片包含 <code>String</code> 的最後一個位元組的話，你同樣能省略最後一個數值。這代表以下都是相等的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>如果你要獲取整個字串的切片，你甚至能省略兩者的數值，以下都是相等的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意：字串切片的索引範圍必須是有效的 UTF-8 字元界限。如果你嘗試從一個多位元組字元（multibyte character）中產生字串切片，你的程式就會回傳錯誤。為了方便介紹字串切片，本章只使用了 ASCII 字元而已。
我們會在第八章的<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">「使用 String 儲存 UTF-8 編碼的文字」</a><!-- ignore -->做更詳盡的討論。</p>
</blockquote>
<p>有了這些資訊，讓我們用切片來重寫 <code>first_word</code> 吧。對於「字串切片」的回傳型別我們會寫 <code>&amp;str</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>我們如同範例 4-7 一樣用判斷第一個空格取得了單字結尾的索引。當我們找到第一個空格，我們用字串的初始索引與當前空格的索引作為初始與結束索引來回傳字串切片。</p>
<p>現在當我們呼叫 <code>first_word</code>，我們就會取得一個與原本資料有直接相關的數值。此數值是由切片的起始位置即切片中的元素個數組成。</p>
<p>這樣函式 <code>second_word</code>  一樣也可以回傳切片：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>我們現在有個不可能出錯且更直觀的 API，因為編譯器會確保 <code>String</code> 的參考會是有效的。還記得我們在範例 4-8 的錯誤嗎？就是那個當我們取得單字結尾索引，但字串卻已清空變成無效的錯誤。那段程式碼邏輯是錯誤的，卻不會馬上顯示錯誤。要是我們持續嘗試用該索引存取空字串的話，問題才會浮現。切片可以讓這樣的程式錯誤無所遁形，並及早讓我們知道我們程式碼有問題。使用切片版本 <code>first_word</code> 的程式碼的話就會出現編譯期錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // 錯誤！

    println!(&quot;第一個單字為：{}&quot;, word);
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // 錯誤！
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;第一個單字為：{}&quot;, word);
   |                                ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</code></pre>
<p>回憶一下借用規則，要是我們有不可變參考的話，我們就不能取得可變參考。因為 <code>clear</code> 會縮減 <code>String</code>，它必須是可變參考。在呼叫 <code>clear</code> 之後的 <code>println!</code> 用到了 <code>word</code> 的參考，所以不可變參考在該處仍必須保持有效。Rust 不允許同時存在 <code>clear</code> 的可變參考與 <code>word</code> 的不可變參考，所以編譯會失敗。Rust 不僅讓我們的 API 更容易使用，還想辦法讓所有錯誤在編譯期就消除！</p>
<h4 id="字串字面值作為切片"><a class="header" href="#字串字面值作為切片">字串字面值作為切片</a></h4>
<p>回想一下我們講說字串字面值是怎麼存在執行檔的。現在既然我們已經知道切片，我們就能知道更清楚理解字串字面值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>此處 <code>s</code> 的型別是 <code>&amp;str</code>：它是指向執行檔某部份的切片。這也是為何字串字面值是不可變的，<code>&amp;str</code> 是個不可變參考。</p>
<h4 id="字串切片作為參數"><a class="header" href="#字串切片作為參數">字串切片作為參數</a></h4>
<p>知道你可以取得字面值的切片與 <code>String</code> 數值後，我們可以再改善一次 <code>first_word</code>。也就是它的簽名表現：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>較富有經驗的 Rustacean 會用範例 4-9 的方式編寫函式簽名，因為這讓該函式可以同時接受 <code>&amp;String</code> 和 <code>&amp;str</code> 的數值。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word 適用於 `String` 的切片，無論是部分或整體
</span><span class="boring">    let word = first_word(&amp;my_string[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word 適用於字串字面值，無論是部分或整體
</span><span class="boring">    let word = first_word(&amp;my_string_literal[0..6]);
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 因為字串字面值本來就是切片
</span><span class="boring">    // 沒有切片語法也是可行的！
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 4-9：使用字串切片作為參數 <code>s</code> 來改善函式 <code>first_word</code></span></p>
<p>如果我們有字串切片的話，我們可以直接傳遞。如果我們有 <code>String</code> 的話，我們可以傳遞整個 <code>String</code> 的切片或參考。這樣的彈性用到了<strong>強制解參考</strong>（deref coercion），這個功能我們會在第十五章的<a href="ch15-02-deref.html#%E5%87%BD%E5%BC%8F%E8%88%87%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%B1%E5%BC%8F%E5%BC%B7%E5%88%B6%E8%A7%A3%E5%8F%83%E8%80%83">「函式與方法的隱式強制解參考」</a><!--ignore-->段落做介紹。</p>
<p>定義函式的參數為字串切片而非 <code>String</code> 可以讓我們的 API 更通用且不會失去任何功能：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word 適用於 `String` 的切片，無論是部分或整體
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word 適用於字串字面值，無論是部分或整體
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // 因為字串字面值本來就是切片
    // 沒有切片語法也是可行的！
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3 id="其他切片"><a class="header" href="#其他切片">其他切片</a></h3>
<p>字串切片如你所想的一樣是特別針對字串的。但是我們還有更通用的切片型別。請考慮以下陣列：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>就像我們參考一部分的字串一樣，我們可以這樣參考一部分的陣列：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>此切片的型別為 <code>&amp;[i32]</code>，它和字串運作的方式一樣，儲存了切片的第一個元素以及總長度。你以後會對其他集合也使用這樣的切片。我們會在第八章討論這些集合的更多細節。</p>
<h2 id="總結-3"><a class="header" href="#總結-3">總結</a></h2>
<p>所有權、借用與切片的概念讓 Rust 可以在編譯時期就確保記憶體安全。Rust 程式語言讓你和其他程式語言一樣控制你的記憶體使用方式，但是會在擁有者離開作用域時自動清除擁有的資料，讓你不必在編寫或除錯額外的程式碼。</p>
<p>所有權影響了 Rust 很多其它部分執行的方式，所以我們在書中之後討論這些概念。讓我們繼續到第五章，看看如何用 <code>struct</code> 將資料組合在一起。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="透過結構體組織相關資料"><a class="header" href="#透過結構體組織相關資料">透過結構體組織相關資料</a></h1>
<p><em>struct</em> 或<strong>結構體</strong>（structure）是個讓你封裝並命名數個相關數值為單一組合的自定型別。如果你熟悉物件導向語言的話，<em>struct</em> 就像是物件的資料屬性。在本章節，我們會比較元組與結構體的差別，介紹如何使用結構體，並討論何時使用結構體組織資料是比較好的選擇。</p>
<p>我們將會解釋如何定義並產生結構體實例，我們也會討論如何定義關聯函式，尤其是叫做<strong>方法（method）</strong> 的關聯函式，這能指定結構體型別特定的相關型別。結構體與將會在第六章提到的枚舉（enum）是 Rust 產生新型別的基本元件，它們能充分利用 Rust 的編譯時型別檢查。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定義與實例化結構體"><a class="header" href="#定義與實例化結構體">定義與實例化結構體</a></h2>
<p>結構體（Structs）和我們在<a href="ch03-02-data-types.html#%E5%85%83%E7%B5%84%E5%9E%8B%E5%88%A5">「元組型別」</a><!-- ignore -->段落討論過的元組類似，兩者都能持有多種相關數值。和元組一樣，結構體的每個部分可以是不同的型別。但與元組不同的地方是，在結構體中你必須為每個資料部分命名以便表達每個數值的意義。因為有了這些名稱，結構體通常比元組還來的有彈性：你不需要依賴資料的順序來指定或存取實例中的值。</p>
<p>欲定義結構體，我們輸入關鍵字 <code>struct</code> 並為整個結構體命名。結構體的名稱需要能夠描述其所組合出的資料意義。然後在大括號內，我們對每個資料部分定義名稱與型別，我們會稱為<strong>欄位（fields）</strong>。舉例來說，範例 5-1 定義了一個儲存使用者帳號的結構體。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 5-1：<code>User</code> 結構體定義</span></p>
<p>要在我們定義後使用該結構體，我們可以指定每個欄位的實際數值來建立結構體的<strong>實例（instance）</strong>。要建立實例的話，我們先寫出結構體的名稱再加上大括號，裡面會包含數個「key: value」的配對。<code>key</code> 是每個欄位的名稱，而 <code>value</code> 就是你想給予欄位的數值。欄位的順序可以不用和定義結構體時的順序一樣。換句話說，結構體的定義比較像是型別的通用樣板，然後實例會依據此樣板插入特定資料來將產生型別的數值。比如說，我們可以像範例 5-2 這樣宣告一個特定使用者。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let user1 = User {
        active: true,
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p><span class="caption">範例 5-2：產生一個 <code>User</code> 結構體的實例</span></p>
<p>要取得結構體中特定數值的話，我們使用句點。如果我們只是想要此使用者的電子郵件信箱，我們使用 <code>user1.email</code>。如果該實例可變的話，我們可以使用句點並賦值給該欄位來改變其值。範例 5-3 顯示了如何改變一個可變 <code>User</code> 實例中 <code>email</code> 欄位的值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut user1 = User {
        active: true,
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 5-3：改變 <code>User</code> 中 <code>email</code> 欄位的值</span></p>
<p>請注意整個實例必須是可變的，Rust 不允許我們只標記特定欄位是可變的。再來，就像任何表達式一樣，我們可以在函式本體最後的表達式中，建立一個新的結構體實例作為回傳值。</p>
<p>範例 5-4 展示了 <code>build_user</code> 函式會依據給予的電子郵件和使用者名稱來回傳 <code>User</code> 實例。而 <code>active</code> 欄位取得數值 <code>true</code> 且 <code>sign_in_count</code> 取得數值 <code>1</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        email: email,
        username: username,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-4：<code>build_user</code> 函式取得電子郵件與使用者名稱並回傳 <code>User</code> 實例</span></p>
<p>函式參數名稱與結構體欄位名稱相同是非常合理的，但是要重複寫 <code>email</code> 和 <code>username</code> 的欄位名稱與變數就有點冗長了。如果結構體有更多欄位的話，重複寫這些名稱就顯得有些煩人了。幸運的是，我們的確有更方便的語法！</p>
<h3 id="用欄位初始化簡寫語法"><a class="header" href="#用欄位初始化簡寫語法">用欄位初始化簡寫語法</a></h3>
<p>由於範例 5-4 的參數名稱與結構體欄位名稱相同，我們可以使用<strong>欄位初始化簡寫</strong>（field init shorthand）語法來重寫 <code>build_user</code>，讓它的結果相同但不必重複寫出 <code>email</code> 和 <code>username</code>，如範例 5-5 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        email,
        username,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-5：<code>build_user</code> 函式使用欄位初始化簡寫，因為參數 <code>username</code> 與 <code>email</code> 結構體欄位相同</span></p>
<p>在此我們建立了 <code>User</code> 結構體的實例，它有一個欄位叫做 <code>email</code>。我們希望用 <code>build_user</code> 函式中的參數 <code>email</code> 賦值給 <code>email</code> 欄位。然後因為 <code>email</code> 欄位與 <code>email</code> 參數有相同的名稱，我們只要寫 <code>email</code> 就好，不必寫 <code>email: email</code>。</p>
<h3 id="使用結構體更新語法從其他結構體建立實例"><a class="header" href="#使用結構體更新語法從其他結構體建立實例">使用結構體更新語法從其他結構體建立實例</a></h3>
<p>通常我們也會從其他的實例來產生新的實例，保留大部分欄位，不過修改一些欄位數值，這時你可以使用<strong>結構體更新語法（struct update syntax）</strong>。</p>
<p>首先範例 5-6 顯示了我們沒有使用更新語法來建立新的 <code>User</code> 實例 <code>user2</code>。我們設置了新的數值給 <code>email</code>，但其他欄位就使用我們在範例 5-2 建立的 <code>user1</code> 相同的值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --省略--
<span class="boring">    
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>    
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from(&quot;another@example.com&quot;),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre></pre>
<p><span class="caption">範例 5-6：從 <code>user1</code> 中建立新的 <code>User</code> 實例</span></p>
<p>使用結構體更新語法，我們可以用較少的程式碼達到相同的效果，如範例 5-7 所示。<code>..</code> 語法表示剩下沒指明的欄位都會取得與所提供的實例相同的值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    // --省略--
<span class="boring">
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span>
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        ..user1
    };
}
</code></pre></pre>
<p><span class="caption">範例 5-7：對新的 <code>User</code> 實例設置新的 <code>email</code> 數值，但剩下就都使用 <code>user1</code> </span></p>
<p>範例 5-7 的程式碼產生的 <code>user2</code> 實例有不同 <code>email</code>，但是有與 <code>user1</code> 相同的 <code>username</code>、<code>active</code> 和 <code>sign_in_count</code>。<code>..user1</code> 加在最後面表示任何剩餘的欄位都會與 <code>user1</code> 對應欄位的數值相同，不過我們可以用任意順序指定多少想指定的欄位，不需要與結構體定義欄位的順序一樣。</p>
<p>注意到結構體更新語法和賦值一樣使用 <code>=</code>，這是因為它也會轉移資料，就如同我們在<a href="ch04-01-what-is-ownership.html#%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%87%E6%96%99%E4%BA%92%E5%8B%95%E7%9A%84%E6%96%B9%E5%BC%8F%E7%A7%BB%E5%8B%95move">「變數與資料互動的方式：移動」</a><!-- ignore -->段落看到的一樣。在此範例中，我們在建立 <code>user2</code> 之後就無法再使用 <code>user1</code>，因為 <code>user1</code> 的 <code>username</code> 欄位的 <code>String</code> 被移到 <code>user2</code> 了。如果我們同時給 <code>user2</code> 的 <code>email</code> 與 <code>username</code> 新的 <code>String</code>，這樣 <code>user1</code> 會用到的數值只會有 <code>active</code> 和 <code>sign_in_count</code>，這樣 <code>user1</code> 在 <code>user2</code> 就仍會有效。因為 <code>active</code> 和 <code>sign_in_count</code> 都是有實作 <code>Copy</code> 特徵的型別，所以我們在<a href="ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E5%A0%86%E7%96%8A%E4%B8%8A%E7%9A%84%E8%B3%87%E6%96%99%E6%8B%B7%E8%B2%9Dcopy">「變數與資料互動的方式：克隆」</a><!-- ignore -->段落討論到的行為會造成影響。</p>
<h3 id="使用無名稱欄位的元組結構體來建立不同型別"><a class="header" href="#使用無名稱欄位的元組結構體來建立不同型別">使用無名稱欄位的元組結構體來建立不同型別</a></h3>
<p>Rust 還支援定義結構體讓它長得像是元組那樣，我們稱作<strong>元組結構體（tuple structs）</strong>。元組結構體仍然有定義整個結構的名稱，但是它們的欄位不會有名稱，它們只會有欄位型別而已。元組結構體的用途在於當你想要為元組命名，好讓它跟其他不同型別的元組作出區別，以及對常規結構體每個欄位命名是冗長且不必要的時候。</p>
<p>要定義一個元組結構體，一樣先從 <code>struct</code> 關鍵字開始，其後再接著要定義的元組。舉例來說，以下是兩個使用元組結構體定義的 <code>Color</code> 和 <code>Point</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<p>注意 <code>black</code> 與 <code>origin</code> 屬於不同型別，因為它們是不同的元組結構體實例。每個你定義的結構體都是專屬於自己的型別，就算它們的欄位型別可能一模一樣。舉例來說，一個參數為 <code>Color</code> 的函式就無法接受 <code>Point</code> 引數，就算它們的型別都是三個 <code>i32</code> 的組合。除此之外，元組結構體實例和元組類似，你可以將它們解構為獨立部分，你也可以使用 <code>.</code> 加上索引來取得每個數值。</p>
<h3 id="無任何欄位的類單元結構體"><a class="header" href="#無任何欄位的類單元結構體">無任何欄位的類單元結構體</a></h3>
<p>你也可以定義沒有任何欄位的結構體！這些叫做<strong>類單元結構體（unit-like structs）</strong>，因為它們的行為就很像我們在<a href="ch03-02-data-types.html#%E5%85%83%E7%B5%84%E5%9E%8B%E5%88%A5">「元組型別」</a><!-- ignore -->段落討論過的單元型別（unit type）<code>()</code> 類似。類單元結構體很適合用在當你要實作一個特徵（trait）或某種型別，但你沒有任何需要儲存在型別中的資料。我們會在第十章討論特徵。以下的範例宣告並實例化一個類單元結構體叫做 <code>AlwaysEqual</code>：</p>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<p>我們使用 <code>struct</code> 關鍵字定義我們想要的名稱 <code>AlwaysEqual</code>，然後加上分號就好，不必再加任何括號！這樣我們就能一樣用 <code>subject</code> 變數取得一個 <code>AlwaysEqual</code> 的實例：直接使用我們定義的名稱，不用加任何括號。想像一下之後我們可以針對 <code>AlwaysEqual</code> 的實例實作與其他型別實例相同的行爲，像是爲了測試回傳已知的結果。我們不需要任何資料就能實作該行爲！你能在第十章看到如何定義特徵（trait）並對任何型別實作它們，這也包含類單元結構體。</p>
<blockquote>
<h3 id="結構體資料的所有權"><a class="header" href="#結構體資料的所有權">結構體資料的所有權</a></h3>
<p>在範例 5-1 的 <code>User</code> 結構體定義中，我們使用了擁有所有權的 <code>String</code> 型別，而不是 <code>&amp;str</code> 字串切片型別。這邊是故意這樣選擇的，因為我們希望每個結構體的實例可以擁有它所有的資料，並在整個結構體都有效時資料也是有效的。</p>
<p>要在結構體中儲存別人擁有的資料參考是可行的，但這會用到<strong>生命週期（lifetimes）</strong>，我們在第十章才會談到。生命週期能確保資料參考在結構體存在期間都是有效的。要是你沒有使用生命週期來用結構體儲存參考的話，會如以下出錯：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        active: true,
        username: &quot;someusername123&quot;,
        email: &quot;someone@example.com&quot;,
        sign_in_count: 1,
    };
}
</code></pre>
<p>編譯器會抱怨它需要生命週期標記：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:15
  |
3 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:12
  |
4 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User&lt;'a&gt; {
2 |     active: bool,
3 |     username: &amp;str,
4 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs` due to 2 previous errors
</code></pre>
<p>在第十章，我們將會討論如何修正這樣的錯誤，好讓你可以在結構體中儲存參考。但現在的話，我們先用有所有權的 <code>String</code> 而非 <code>&amp;str</code> 參考來避免錯誤。</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用結構體的程式範例"><a class="header" href="#使用結構體的程式範例">使用結構體的程式範例</a></h2>
<p>為了瞭解我們何時會想要使用結構體，讓我們來寫一支計算長方形面積的程式。我們會先從單一變數開始，再慢慢重構成使用結構體。</p>
<p>讓我們用 Cargo 建立一個新的專案 <em>rectangles</em> ，它將接收長方形的長度與寬度，然後計算出長方形的面積。範例 5-8 展示了在我們專案底下 <em>src/main.rs</em> 用其中一種方式寫出來的小程式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;長方形的面積為 {} 平方像素。&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">範例 5-8：使用變數 width 和 height 計算長方形面積</span></p>
<p>現在使用 <code>cargo run</code> 執行程式：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/rectangles`
長方形的面積為 1500 平方像素。
</code></pre>
<p>雖然此程式碼成功呼叫 <code>area</code> 函式計算出長方形的面積，但我們可以做得更好，讓程式碼更簡潔且更易閱讀。</p>
<p>此程式碼的問題在 <code>area</code> 的函式簽名就能看出來：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;長方形的面積為 {} 平方像素。&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p><code>area</code> 函式應該要計算長方形的面積，但是我們寫的函式有兩個參數，但在我們得程式中參數的相關性卻沒有表達出來。要是能將寬度與長度組合起來的話，會更容易閱讀與管理。我們可以使用我們在第三章提到的<a href="ch03-02-data-types.html#%E5%85%83%E7%B5%84%E5%9E%8B%E5%88%A5">「元組型別」</a><!-- ignore -->。</p>
<h3 id="使用元組重構"><a class="header" href="#使用元組重構">使用元組重構</a></h3>
<p>範例 5-9 展示了我們的程式用元組的另一種寫法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;長方形的面積為 {} 平方像素。&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">範例 5-9：使用元組指定長方形的寬度與長度</span></p>
<p>一方面來說，此程式的確比較好。元組讓我們增加了一些結構，而我們現在只需要傳遞一個引數。但另一方面來說，此版本的閱讀性反而更差。元組無法命名它的元素，所以我們需要索引部分元組，讓我們的計算變得比較不清晰。</p>
<p>我們在計算面積時，哪個值是寬度還是長度的確不重要。但如果我們要顯示出來的話，這就很重要了！我們會需要記住元組索引 <code>0</code> 是 <code>width</code> 然後元組索引 <code>1</code> 是 <code>height</code>。如果有其他人要維護這段程式碼的話，他就也記住這件事才能使用我們的程式碼。由於我們無法從程式碼表達出資料的意義，它就很容易產生錯誤。</p>
<h3 id="使用結構體重構賦予更多意義"><a class="header" href="#使用結構體重構賦予更多意義">使用結構體重構：賦予更多意義</a></h3>
<p>我們可以用結構體來為資料命名以賦予其意義。我們可以將元組轉換成一個有整體名稱且內部資料也都有名稱的結構體，如範例 5-10 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;長方形的面積為 {} 平方像素。&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">範例 5-10：定義 <code>Rectangle</code> 結構體</span></p>
<p>我們在此定義了一個結構體叫做 <code>Rectangle</code>。在大括號內，我們定義了 <code>width</code> 與 <code>height</code> 的欄位，兩者型別皆為 <code>u32</code>。然後在 <code>main</code> 中，我們建立了一個寬度為 <code>30</code> 長度為 <code>50</code> 的 <code>Rectangle</code> 實例。</p>
<p>現在我們的 <code>area</code> 函式使需要一個參數 <code>rectangle</code>，其型別為 <code>Rectangle</code> 結構體實例的不可變借用。如同第四章提到的，我們希望借用結構體而非取走其所有權。這樣一來，<code>main</code> 能保留它的所有權並讓 <code>rect1</code> 繼續使用，這也是為何我們要在要呼叫函式的簽名中使用 <code>&amp;</code>。</p>
<p><code>area</code> 函式能夠存取 <code>Rectangle</code> 中的 <code>width</code> 與 <code>height</code> 欄位（存取借用結構體實例的欄位不會移動欄位數值，這就是為何你常看到結構體的借用）。我們的 <code>area</code> 函式簽名由可以表達出我們想要做的事情了：使用 <code>width</code> 與 <code>height</code> 欄位來計算 <code>Rectangle</code> 的面積。這能表達出寬度與長度之間的關係，並且給了它們容易讀懂的名稱，而不是像元組那樣用索引 <code>0</code> 和 <code>1</code>。這樣清楚多了。</p>
<h3 id="使用推導特徵實現更多功能"><a class="header" href="#使用推導特徵實現更多功能">使用推導特徵實現更多功能</a></h3>
<p>現在要是能夠在我們除錯程式時能夠印出 <code>Rectangle</code> 的實例並看到它所有的欄位數值就更好了。範例 5-11 嘗試使用我們之前章節提到的 <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code> 巨集</a><!-- ignore -->，但是卻無法執行。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">範例 5-11：嘗試印出 <code>Rectangle</code> 實例</span></p>
<p>當我們編譯此程式碼時，我們會得到以下錯誤訊息：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p><code>println!</code> 巨集預設可以做各式各樣的格式化，大括號告訴 <code>println!</code> 要使用 <code>Display</code> 特徵的格式化方式：其輸出結果是用來給最終使用者使用的。我們目前遇過的基本型別預設都會實作 <code>Display</code>，因為它們也只有一種顯示方式（像是 <code>1</code>）能夠給使用者。但是對結構體來說 <code>println!</code> 要怎麼格式化輸出結果就會有點不明確了，因為顯示的方式就很有多種。是要加上頓號嗎？是要印出大括號嗎？所有的欄位都要顯示出來嗎？基於這些不確定因素，Rust 不會去猜我們要的是什麼，所以結構體預設並沒有 <code>Display</code> 的實作，也就無法使用 <code>println!</code> 與 <code>{}</code> 佔位符。</p>
<p>如果我們繼續閱讀錯誤訊息，我們會得到一些有幫助的資訊：</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>讓我們來試試看吧！<code>println!</code> 巨集的呼叫方式現在看起來應該會像這樣 <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>。在 <code>println!</code> 內加上 <code>:?</code> 這樣的標記指的是我們想要使用 <code>Debug</code> 特徵來作為輸出格式方式。<code>Debug</code> 特徵讓我們能印出對開發者有幫助的資訊，好讓我們在除錯程式時可以看到它的數值。</p>
<p>但是要是編譯這樣的程式的話，哎呀！我們卻還是會得到錯誤：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `Debug`
</code></pre>
<p>不過同樣地，編譯器又給了我們有用的資訊：</p>
<pre><code class="language-text">   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre>
<p>Rust <strong>的確</strong>有印出除錯資訊的功能，但是我們要針對我們的結構體顯式實作出來才會有對應的功能。為此我們可以在結構體前加上屬性（attribute） <code>#[derive(Debug)]</code>，如範例 5-12 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">範例 5-12：加上屬性（attribute）來推導（derive） <code>Debug</code> 特徵的並印出 <code>Rectangle</code> 實例的格式化資訊</span></p>
<p>現在當我們執行程式，我們不會再得到錯誤了，而且我們可以看到格式化後的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>漂亮！雖然這不是非常好看的輸出格式，但是它的確顯示了實例中所有的欄位數值，這對我們除錯時會非常有用。不過如果我們的結構體非常龐大的話，我們會希望輸出格式可以比較好閱讀。為此我們可以在 <code>println!</code> 的字串使用 <code>{:#?}</code> 而非 <code>{:?}</code>。在此例中使用 <code>{:#?}</code> 風格的話，輸出結果就會如下：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/rectangles`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>另一種使用 <code>Debug</code> 格式印出數值的方式是使用 <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code> 巨集</a> <!-- ignore -->。這會拿走一個表達式的所有權（相較於 <code>println!</code> 只會拿參考），印出該 <code>dbg!</code> 巨集在程式碼中呼叫的檔案與行數，以及該表達式的數值結果，最後回傳該數值的所有權。</p>
<blockquote>
<p>呼叫 <code>dbg!</code> 巨集會顯示到標準錯誤終端串流（<code>stderr</code>），而不像 <code>println!</code> 是印到標準輸出終端串流（<code>stdout</code>）。我們會在第十二章的<a href="ch12-06-writing-to-stderr-instead-of-stdout.html">「將錯誤訊息寫入標準錯誤而非標準輸出」</a><!-- ignore -->段落進一步討論 <code>stderr</code> 與 <code>stdout</code>。</p>
</blockquote>
<p>以下的範例我們印出賦值給 <code>width</code> 的數值，以及整個 <code>rect1</code> 結構體的數值： </p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&amp;rect1);
}
</code></pre></pre>
<p>我們在表達式 <code>30 * scale</code> 加上 <code>dbg!</code>，因爲 <code>dbg!</code> 會回傳表達式的數值所有權， <code>width</code> 將能取得和如果我們不加上 <code>dbg!</code> 時相同的數值。而我們不希望 <code>dbg!</code> 取走 <code>rect1</code> 的所有權，所以我們在下一個 <code>rect1</code> 的呼叫使用參考。以下是此範例得到的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/rectangles`
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<p>我們可以看見第一個輸出結果來自 <em>src/main.rs</em> 第十行，也就是我們除錯表達式 <code>30 * scale</code> 的地方，其結果數值爲 <code>60</code> （整數實作的 <code>Debug</code> 格式只會印出它們的數值）。而在 <em>src/main.rs</em> 第十四行所呼叫的 <code>dbg!</code> 則輸出 <code>&amp;rect1</code> 的數值，也就是 <code>Rectangle</code> 的結構體。此輸出就會使用 <code>Rectangle</code> 實作的 <code>Debug</code> 漂亮格式。當你需要嘗試理解程式碼怎麼運作時，<code>dbg!</code> 巨集可以變得相當實用！</p>
<p>除了 <code>Debug</code> 特徵之外，Rust 還提供了一些特徵能讓我們透過 <code>derive</code> 屬性來使用並爲我們的自訂型別擴增實用的行爲。這些特徵與它們的行爲有列在<a href="appendix-03-derivable-traits.html">附錄 C</a><!--ignore -->。我們會在第十章介紹如何實作這些特徵的自訂行爲，以及如何建立你自己的特徵。除了 <code>derive</code> 以外也有其他很多屬性，想了解更多資訊的話，請參考 Rust Reference 的「<a href="https://doc.rust-lang.org/reference/attributes.html">Attributes</a>」段落。</p>
<p>我們的函式 <code>area</code> 最後就非常清楚明白了，它只會計算長方形的面積。這樣的行為要是能夠緊貼著我們的 <code>Rectangle</code> 結構體，因為這樣一來它就不會相容於其他型別。讓我們看看我們如何繼續重構我們的程式碼，接下來我們可以將函式 <code>area</code> 轉換為 <code>Rectangle</code> 型別的<strong>方法（method）</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="方法語法"><a class="header" href="#方法語法">方法語法</a></h2>
<p><strong>方法</strong>（Methods）和函式類似，我們用 <code>fn</code> 關鍵字並加上它們名稱來宣告，它們都有參數與回傳值，然後它們包含一些程式碼能夠在其他地方呼叫方法。和函式不同的是，方法是針對結構體定義的（或是枚舉和特徵物件，我們會在<a href="ch06-00-enums.html">第六章</a><!-- ignore -->與<a href="ch17-02-trait-objects.html">第十七章</a><!-- ignore -->分別介紹它們），且它們第一個參數永遠是 <code>self</code>，這代表的是呼叫該方法的結構體實例。</p>
<h3 id="定義方法"><a class="header" href="#定義方法">定義方法</a></h3>
<p>讓我們把 <code>Rectangle</code> 作為參數的 <code>area</code> 函式轉換成定義在 <code>Rectangle</code> 內的 <code>area</code> 方法，如範例 5-13 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;長方形的面積為 {} 平方像素。&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">範例 5-13：在 <code>Rectangle</code> 中定義 <code>area</code> 方法</span></p>
<p>要定義 <code>Rectangle</code> 中的方法，我們先為 <code>Rectangle</code> 加個 <code>impl</code>（implementation）區塊來開始。所有在此區塊的內容都跟 <code>Rectangle</code> 型別有關。再來將 <code>area</code> 移入 <code>impl</code> 的大括號中，並將簽名中的第一個參數（在此例中是唯一一個）與其本體中用到的地方改成 <code>self</code>。在 <code>main</code> 中我們原先使用 <code>rect1</code> 作為引數呼叫的 <code>area</code>，可以改成使用<strong>方法語法</strong>（method syntax）來呼叫 <code>Rectangle</code> 的 <code>area</code> 方法。方法語法在實例後面呼叫，我們在其之後加上句點、方法名稱、括號然後任何所需的引數。</p>
<p>在 <code>area</code> 的簽名中，我們使用 <code>&amp;self</code> 而非 <code>rectangle: &amp;Rectangle</code>。<code>&amp;self</code> 是 <code>self: &amp;Self</code> 的簡寫。在一個 <code>impl</code> 區塊內，<code>Self</code> 型別是該 <code>impl</code> 區塊要實作型別的別名。方法必須有個叫做 <code>self</code> 的 <code>Self</code> 型別作為它們的第一個參數，所以 Rust 讓你在寫第一個參數時能直接簡寫成 <code>self</code>。注意到我們在 <code>self</code> 縮寫的前面仍使用 <code>&amp;</code>，已表示此方法是借用 <code>Self</code> 的實例，就像我們在 <code>rectangle: &amp;Rectangle</code> 做的一樣。就和其他參數一樣，方法可以選擇拿走 <code>self</code> 的所有權、像我們這裡借用不可變的 <code>self</code> 或是借用可變的 <code>self</code>。</p>
<p>我們之所以選擇 <code>&amp;self</code> 的原因和我們在之前函式版本的 <code>&amp;Rectangle</code> 一樣，我們不想取得所有權，只想讀取結構體的資料，而非寫入它。如果我們想要透過方法改變實例的數值的話，我們會使用 <code>&amp;mut self</code> 作為第一個參數。而只使用 <code>self</code> 取得所有權的方法更是非常少見，這種使用技巧通常是為了想改變 <code>self</code> 成你想要的樣子，並且希望能避免原本被改變的實例繼續被呼叫。</p>
<p>使用方法而非函式最大的原因是，除了可以使用方法語法而不必在方法簽名重複 <code>self</code> 的型別之外，其更具組織性。我們將所有一個型別所能做的事都放入 <code>impl</code> 區塊中了，而不必讓未來的使用者在茫茫函式庫中尋找 <code>Rectangle</code> 的功能。</p>
<p>另外我們還可以選擇將方法的名稱取作其結構體的其中一個欄位。舉例來說，我們也可以在 <code>Rectangle</code> 定義一個 <code>width</code> 方法：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(&quot;長方形的寬度不為零，而是 {}&quot;, rect1.width);
    }
}
</code></pre></pre>
<p>這裡我們選擇讓 <code>width</code> 方法判斷實例的 <code>width</code> 是否大於 0：如果是的話回傳 <code>true</code>；如果為 0 的話就回傳 <code>false</code>。我們可以讓欄位與方法擁有相同的名稱，並作為任何用途使用。在 <code>main</code> 中，當我們在 <code>rect1.width</code> 後方加上括號，Rust 就會知道我們指的是 <code>width</code> 方法。當我們沒有使用括號時，Rust 會知道我們指的是 <code>width</code> 欄位。</p>
<p>雖然不是必定的做法，但通常我們將方法名稱與欄位設為一樣時，我們希望它只回傳該欄位的數值而已。像這樣的方法稱為 <strong>getter</strong>，Rust 並不會像其他語言那樣自動為結構體欄位實作它們。Getter 常用於將欄位隱藏起來，但提供個公開方法並只限讀取該欄位，來做為該型別的公開 API。我們會在<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E9%97%9C%E9%8D%B5%E5%AD%97%E5%85%AC%E9%96%8B%E8%B7%AF%E5%BE%91">第七章</a><!-- ignore -->討論什麼是公開與私有，以及如何設計方法或欄位為公開或私有的。</p>
<blockquote>
<h3 id="--運算子跑去哪了"><a class="header" href="#--運算子跑去哪了"><code>-&gt;</code> 運算子跑去哪了？</a></h3>
<p>在 C 與 C++ 中，我們有兩種呼叫方式的運算元：我們會用 <code>.</code> 來直接呼叫物件的方法；用 <code>-&gt;</code> 來呼叫需要先解參考的物件。換句話說，如果 <code>object</code> 是指標的話，<code>object-&gt;something()</code> 就會像是<code>(*object).something()</code>。</p>
<p>Rust 沒有提供 <code>-&gt;</code> 這樣的運算子。相反地 Rust 有個功能叫做<strong>自動參考與解參考（automatic referencing and dereferencing）</strong>。呼叫方法是 Rust 少數會有這樣行為的地方。</p>
<p>運作方式如下：當你呼叫方法像是 <code>object.something()</code> 時，Rust 會自動加上<code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code>，以便符合方法簽名。換句話說，以下範例是相同的：</p>
<!-- CAN'T EXTRACT SEE BUG https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>第一個呼叫簡潔多了，這種自動參考的行為之所以可行是因為方法有明確的 <code>self</code> 參考型別。依據接收者的方法名稱，Rust 可以知道該方法是在讀取（<code>&amp;self</code>）、可變的（<code>&amp;mut self</code>）或是會消耗的（<code>self</code>）。而 Rust 之所以允許借用方法接收者成隱式的原因，是因為這可以讓所有權更易讀懂。</p>
</blockquote>
<h3 id="擁有更多參數的方法"><a class="header" href="#擁有更多參數的方法">擁有更多參數的方法</a></h3>
<p>讓我們來練習再實作另一個 <code>Rectangle</code> 的方法。這次我們要 <code>Rectangle</code> 的實例可以接收另一個 <code>Rectangle</code> 實例，要是 <code>self</code> 本身（第一個 <code>Rectangle</code>）可以包含另一個 <code>Rectangle</code> 的話我們就回傳 <code>true</code>，不然的話就回傳 <code>false</code>。也就是我們希望定一個方法 <code>can_hold</code> ，如範例 5-14 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;rect1 能容納 rect2 嗎？{}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;rect1 能容納 rect3 嗎？{}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">範例 5-14：使用一個還沒定義完的方法 <code>can_hold</code></span></p>
<p>然後我們預期的輸出結果會如以下所示，因為 <code>rect2</code> 的兩個維度都比 <code>rect1</code> 小，但 <code>rect3</code> 比 <code>rect1</code> 寬：</p>
<pre><code class="language-text">rect1 能容納 rect2 嗎？true
rect1 能容納 rect3 嗎？false
</code></pre>
<p>我們知道我們要定義方法的話，它一定得在 <code>impl Rectangle</code> 區塊底下。方法的名稱會叫做 <code>can_hold</code>。它會取得另一個 <code>Rectangle</code> 的不可變參考作為參數。我們可以從程式碼呼叫方法的地方來知道參數的可能的型別：<code>rect1.can_hold(&amp;rect2)</code> 傳遞了 <code>&amp;rect2</code>，這是一個 <code>rect2</code> 的不可變參考，同時也是 <code>Rectangle</code> 的實例。這是合理的，因為我們只需要讀取 <code>rect2</code>（而不是寫入，寫入代表我們需要可變參考），且我們希望 <code>main</code> 能夠保持 <code>rect2</code> 的所有權，好讓我們之後能在繼續使用它來呼叫 <code>can_hold</code> 方法。<code>can_hold</code> 的回傳值會是布林值，然後實作細節會是檢查 <code>self</code> 的寬度與長度是否都大於其他 <code>Rectangle</code> 的寬度與長度。讓我們加入範例 5-13 的 <code>can_hold</code> 方法到 <code>impl</code> 區塊中，如範例 5-15 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 能容納 rect2 嗎？{}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 能容納 rect3 嗎？{}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-15：在 <code>Rectangle</code> 中實作了取得其他 <code>Rectangle</code> 作為參數的 <code>can_hold</code> 方法</span></p>
<p>當我們用範例 5-14 的 <code>main</code> 函式執行此程式碼的話，我們會得到預期的輸出結果。方法可以在參數 <code>self</code> 之後接收更多參數，而那些參數就和函式中的參數用法一樣。</p>
<h3 id="關聯函式"><a class="header" href="#關聯函式">關聯函式</a></h3>
<p>所有在 <code>impl</code> 區塊內的方法都屬於<strong>關聯函式（associated functions）</strong>，因為它們都與 <code>impl</code> 實作的型別相關。要是有方法不需要自己的型別實例的話，我們可以定義個沒有 <code>self</code> 作為它們第一個參數的關聯函式（因此不會被稱作方法）。我們已經在 <code>String</code> 型別使用過 <code>String::from</code> 這種關聯函式了。</p>
<p>不屬於方法的關聯函式很常用作建構子，來產生新的結構體實例。這通常會叫做 <code>new</code>，但是 <code>new</code> 其實不是特殊名稱，也沒有內建在語言內。舉例來說，我們可以提供一個只接收一個維度作為參數的關聯函式，讓它賦值給寬度與長度，讓我們可以用 <code>Rectangle</code> 來產生正方形，而不必提供兩次相同的值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>回傳型別中與函式本體中的 <code>Self</code> 關鍵字是 <code>impl</code> 關鍵字接著出現的型別別名，在此例中就是 <code>Rectangle</code>。</p>
<p>要呼叫關聯函式的話，我們使用 <code>::</code> 語法並加上結構體的名稱。比方說 <code>let sq = Rectangle::square(3);</code>。此函式用結構體名稱作為命名空間，<code>::</code> 語法可以用在關聯函式以及模組的命名空間，我們會在<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">第七章</a><!-- ignore -->介紹模組。</p>
<h3 id="多重-impl-區塊"><a class="header" href="#多重-impl-區塊">多重 <code>impl</code> 區塊</a></h3>
<p>每個結構體都允許有數個 <code>impl</code> 區塊。舉例來說，範例 5-15 與範例 5-16 展示的程式碼是一樣的，它讓每個方法都有自己的 <code>impl</code> 區塊。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;rect1 能容納rect2？{}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;rect1 能容納rect3？{}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-16：使用多重 <code>impl</code> 來重寫範例 5-15</span></p>
<p>這邊我們的確沒有將方法拆為 <code>impl</code> 區塊的理由，不過這樣的語法是合理的。我們會在第十章介紹泛型型別與特徵，看到多重 <code>impl</code> 區塊是非常實用的案例。</p>
<h2 id="總結-4"><a class="header" href="#總結-4">總結</a></h2>
<p>結構體讓你可以自訂對你的領域有意義的型別。使用結構體的話，你可以讓每個資料部分與其他部分具有相關性，並為每個部分讓程式更好讀懂。在 <code>impl</code> 區塊中，你可以定義與你的型別有關的函式，而方法就是其中一種關聯函式，能讓你指定你的結構體能有何種行為。</p>
<p>但是結構體並不是自訂型別的唯一方法：讓我們看下去 Rust 的枚舉功能，讓你的工具箱可以再多一項可以使用的工具。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚舉與模式配對"><a class="header" href="#枚舉與模式配對">枚舉與模式配對</a></h1>
<p>在本章節中，我們將討論<strong>枚舉</strong>（enumerations），有時也被簡寫為 <em>enums</em>。枚舉讓你定義一個能夠列舉其可能<strong>變體</strong>（variants）的型別。首先，我們會定義並使用枚舉來展示枚舉如何將其數據組織起來。再來，我們會來探討一個特定的實用枚舉：<code>Option</code>，其代表該值為某些東西不然就是什麼都沒有。然後我們會看看 <code>match</code> 表達式的模式配對是怎麼運作的，讓它能夠針對枚舉中不同數值執行不同的程式碼。最後，我們會介紹 <code>if let</code> 這個結構，來用簡潔又方便的方式處理枚舉。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定義枚舉"><a class="header" href="#定義枚舉">定義枚舉</a></h2>
<p>結構體讓你能將相關的欄位與資訊組織在一起，像是 <code>Rectangle</code> 中的 <code>width</code> 與 <code>height</code>，而枚舉則是讓你能表達一個數值屬於一組特定數值的其中一種。舉例來說，我們可能想要表達 <code>Rectangle</code> 是其中一種可能的形狀，而這些形狀可能還包括 <code>Circle</code> 與 <code>Triangle</code>。Rust 讓我們能以枚舉的形式表現這樣的可能性。</p>
<p>讓我們看一個程式碼表達的例子，來看看為何此時用枚舉會比結構體更恰當且實用。假設我們要使用 IP 位址，而且現在有兩個主要的標準能使用 IP 位址：IPv4 與 IPv6。這些是我們的程式碼可能會遇到的 IP 位址，我們可以<strong>枚舉</strong>（enumerate）出所有可能的變體，這正是枚舉的由來。</p>
<p>任何 IP 位址可以是第四版或第六版，但不是同時存在。IP 位址這樣的特性非常適合使用枚舉資料結構，因為枚舉的值只能是其中一個變體。第四版與第六版同時都屬於 IP 位址，所以當有程式碼要處理任何類型的 IP 位址時，它們都應該被視為相同型別。</p>
<p>要表達這樣的概念，我們可以定義 <code>IpAddrKind</code> 枚舉和列出 IP 位址可能的類型 <code>V4</code> 和 <code>V6</code>。這些稱為枚舉的變體（variants）：</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> 現在成了能在我們程式碼任何地方使用的自訂資料型別。</p>
<h3 id="枚舉數值"><a class="header" href="#枚舉數值">枚舉數值</a></h3>
<p>我們可以像這樣建立兩個不同變體的 <code>IpAddrKind</code> 實例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>注意變體會位於枚舉命名空間底下，所以我們用兩個冒號來標示。這樣的好處在於 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是同型別 <code>IpAddrKind</code>。比方說，我們就可以定義一個接收任 <code>IpAddrKind</code> 的函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>然後我們可以用任意變體呼叫此函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>使用枚舉還有更多好處。我們再進一步想一下我們的 IP 位址型別還沒有辦法儲存實際的 IP 位址<strong>資料</strong>，我們現在只知道它是哪種<strong>類型</strong>。考慮到你已經學會第五章的結構體，你應該會像範例 6-1 這樣嘗試用結構體解決問題。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-1：使用 <code>struct</code> 儲存 IP 位址的資料與 <code>IpAddrKind</code> 的變體</span></p>
<p>我們在這裡定義了一個有兩個欄位的結構體 <code>IpAddr</code>：欄位 <code>kind</code> 擁有 <code>IpAddrKind</code>（我們上面定義過的枚舉）型別，<code>address</code> 欄位則是 <code>String</code> 型別。再來我們有兩個此結構體的實例。第一個 <code>home</code> 擁有 <code>IpAddrKind::V4</code> 作為 <code>kind</code> 的值，然後位址資料是 <code>127.0.0.1</code>。第二個實例 <code>loopback</code> 擁有 <code>IpAddrKind</code> 另一個變體 <code>V6</code> 作為 <code>kind</code> 的值，且有 <code>::1</code> 作為位址資料。我們用結構體來組織 <code>kind</code> 和 <code>address</code> 的值在一起，讓變體可以與數值相關。</p>
<p>但是我們可以用另一種更簡潔的方式來定義枚舉就好，而不必使用結構體加上枚舉。枚舉內的每個變體其實都能擁有數值。以下這樣新的定義方式讓 <code>IpAddr</code> 的 <code>V4</code> 與 <code>V6</code> 都能擁有與其相關的 <code>String</code> 數值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我們將資料直接附加到枚舉的每個變體上，這樣就不再用結構體。這裏我們還能看到另一項枚舉的細節：我們定義的每一個枚舉變體也會變成建構該枚舉的函式。也就是說 <code>IpAddr::V4()</code> 是個函式，且接收 <code>String</code> 引數並回傳 <code>IpAddr</code> 的實例。我們在定義枚舉時就會自動拿到這樣的建構函式。</p>
<p>改使用枚舉而非結構體的話還有另一項好處：每個變體可以擁有不同型別與資料的數量。第四版的 IP 位址永遠只會有四個 0 到 255 的數字部分，如果我們想要讓 <code>V4</code> 儲存四個 <code>u8</code>，但 <code>V6</code> 位址仍保持 <code>String</code> 不變的話，我們在結構體是無法做到的。枚舉可以輕鬆勝任：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我們展示了許多種定義儲存第四版與第六版 IP 位址資料結構的方式，不過需要儲存 IP 位址並編碼成不同類型的案例實在太常見了，所以<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">標準函式庫已經幫我們定義好了！</a><!-- ignore -->讓我們看看標準函式庫是怎麼定義 <code>IpAddr</code> 的：它有和我們一模一樣的枚舉變體，不過變體各自儲存的資料是另外兩個不同的結構體，兩個定義的內容均不相同：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --省略--
}

struct Ipv6Addr {
    // --省略--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼展示了你可以將任何資料類型放入枚舉的變體中：字串、數字型別、結構體都可以。你甚至可以再包含另一個枚舉！另外標準函式庫內的型別常常沒有你想得那麼複雜。</p>
<p>請注意雖然標準函式庫已經有定義 <code>IpAddr</code>，但我們還是可以使用並建立我們自己定義的型別，而且不會產生衝突，因為我們還沒有將標準函式庫的定義匯入到我們的作用域中。我們會在第七章討論如何將型別匯入作用域內。</p>
<p>讓我們再看看範例 6-2 的另一個枚舉範例，這次的變體有各式各樣的型別。</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-2：<code>Message</code> 枚舉的變體各自擁有不同的型別與數值數量</span></p>
<p>此枚舉有四個不同型別的變體：</p>
<ul>
<li><code>Quit</code> 沒有包含任何資料。</li>
<li><code>Move</code> 包含了和結構體一樣的名稱欄位。</li>
<li><code>Write</code> 包含了一個 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含了三個 <code>i32</code>。</li>
</ul>
<p>如同範例 6-2 這樣定義枚舉變體和定義不同類型的結構體很像，只不過枚舉不使用 <code>struct</code> 關鍵字，而且所有的變體都會在 <code>Message</code> 型別底下。以下的結構體可以包含與上方枚舉變體定義過的資料：</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // 類單元結構體
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元組結構體
struct ChangeColorMessage(i32, i32, i32); // 元組結構體
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>但是如果我們使用不同結構體且各自都有自己的型別的話，我們就無法像範例 6-2 那樣將 <code>Message</code> 視為單一型別，輕鬆在定義函式時接收訊息所有可能的類型。</p>
<p>枚舉和結構體還有一個地方很像：如同我們可以對結構體使用 <code>impl</code> 定義方法，我們也可以對枚舉定義方法。以下範例顯示我們可以對 <code>Message</code> 枚舉定義一個 <code>call</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // 在此定義方法本體
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>方法本體使用 <code>self</code> 來取得我們呼叫方法的值。在此例中，我們建立了一個變數 <code>m</code> 並取得 <code>Message::Write(String::from(&quot;hello&quot;))</code>，而這就會是當我們執行 <code>m.call()</code> 時 <code>call</code> 方法內會用到的 <code>self</code>。</p>
<p>讓我們再看看另一個標準函式庫內非常常見且實用的枚舉：<code>Option</code>。</p>
<h3 id="option-枚舉相對於空值的優勢"><a class="header" href="#option-枚舉相對於空值的優勢"><code>Option</code> 枚舉相對於空值的優勢</a></h3>
<p>在此段落我們將來研究 <code>Option</code>，這是在標準函式庫中定義的另一種枚舉。<code>Option</code> 廣泛運用在許多場合，它能表示一個數值可能有某個東西，或者什麼都沒有。</p>
<p>舉例來說，如果你向一串包含元素的列表索取第一個值，你會拿到數值，但如果你向空列表索取的話，你就什麼都拿不到。在型別系統中表達這樣的概念可以讓編譯器檢查我們是否都處理完我們該處理的情況了。這樣的功能可以防止其他程式語言中極度常見的程式錯誤。</p>
<p>程式語言設計通常要考慮哪些功能是你要的，但同時哪些功能是你不要的也很重要。Rust 沒有像其他許多語言都有空值。<strong>空值</strong>（Null）代表的是沒有任何數值。在有空值的語言，所有變數都有兩種可能：空值或非空值。</p>
<p>而其發明者 Tony Hoare 在他 2009 的演講「空參考：造成數十億損失的錯誤」（“Null References: The Billion Dollar Mistake”）中提到：</p>
<blockquote>
<p>我稱它為我十億美元級的錯誤。當時我正在為一門物件導向語言設計第一個全方位的參考型別系統。我當時的目標是透過編譯器自動檢查來確保所有的參考都是安全的。但我無法抗拒去加入空參考的誘惑，因為實作的方式實在太簡單了。這導致了無數的錯誤、漏洞與系統崩潰，在接下來的四十年中造成了大概數十億美金的痛苦與傷害。</p>
</blockquote>
<p>空值的問題在於，如果你想在非空值使用空值的話，你會得到某種錯誤。由於空值與非空值的特性無所不在，你會很容易犯下這類型的錯誤。</p>
<p>但有時候能夠表達「空（null）」的概念還是很有用的：空值代表目前的數值因為某些原因而無效或缺少。</p>
<p>所以問題不在於概念本身，而在於如何實作。所以 Rust 並沒有空值，但是它有一個枚舉可以表達出這樣的概念，也就是一個值可能是存在或不存在的。此枚舉就是 <code>Option&lt;T&gt;</code>，它是在<a href="https://doc.rust-lang.org/std/option/enum.Option.html">標準函式庫中這樣定義的</a><!-- ignore -->：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> 實在太實用了，所以它早已加進 prelude 中，你不需要特地匯入作用域中。它的變體一樣也被加進 prelude 中，你可以直接使用 <code>Some</code> 和 <code>None</code> 而不必加上 <code>Option::</code> 的前綴。<code>Option&lt;T&gt;</code> 仍然就只是個枚舉，
<code>Some(T)</code> 與 <code>None</code> 仍然是<code>Option&lt;T&gt;</code> 型別的變體。</p>
<p><code>&lt;T&gt;</code> 語法是我們還沒介紹到的 Rust 功能。它是個泛型型別參數，我們會在第十章正式介紹泛型（generics）。現在你只需要知道 <code>&lt;T&gt;</code> 指的是 <code>Option</code> 枚舉中的 <code>Some</code> 變體可以是任意型別。而透過 <code>Option</code> 數值來持有數字型別和字串型別的話，它們最終會換掉 <code>Option&lt;T&gt;</code> 中的 <code>T</code>，成為不同的型別。以下是使用 <code>Option</code> 來包含數字與字串型別的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p><code>some_number</code> 的型別是 <code>Option&lt;i32&gt;</code>，而 <code>some_char</code> 的型別是 <code>Option&lt;char&gt;</code>，兩者是不同的型別。Rust 可以推導出這些型別，因為我們已經在 <code>Some</code> 變體指定數值。至於 <code>absent_number</code> 的話，Rust 需要我們寫出完整的 <code>Option</code> 型別，因為編譯器無法從 <code>None</code> 推導出相對應的 <code>Some</code> 變體會持有哪種型別。我們在這裡告訴 Rust 我們 <code>absent_number</code> 所指的型別為 <code>Option&lt;i32&gt;</code>。</p>
<p>當我們有 <code>Some</code> 值時，我們會知道數值是存在的而且就位於 <code>Some</code> 內。當我們有 <code>None</code> 值時，在某種意義上它代表該值是空的，我們沒有有效的數值。所以為何 <code>Option&lt;T&gt;</code> 會比用空值來得好呢？</p>
<p>簡單來說因為 <code>Option&lt;T&gt;</code> 與 <code>T</code>（<code>T</code> 可以是任意型別）是不同的型別，編譯器不會允許我們像一般有效的值那樣來使用 <code>Option&lt;T&gt;</code>。舉例來說，以下範例是無法編譯的，因為這是將 <code>i8</code> 與 <code>Option&lt;i8&gt;</code> 相加：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>如果我們執行此程式，我們會得到以下錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            &lt;&amp;'a f32 as Add&lt;f32&gt;&gt;
            &lt;&amp;'a f64 as Add&lt;f64&gt;&gt;
            &lt;&amp;'a i128 as Add&lt;i128&gt;&gt;
            &lt;&amp;'a i16 as Add&lt;i16&gt;&gt;
            &lt;&amp;'a i32 as Add&lt;i32&gt;&gt;
            &lt;&amp;'a i64 as Add&lt;i64&gt;&gt;
            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;
            &lt;&amp;'a isize as Add&lt;isize&gt;&gt;
          and 48 others

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</code></pre>
<p>這樣其實很好！此錯誤訊息事實上指的是 Rust 不知道如何將 <code>i8</code> 與 <code>Option&lt;i8&gt;</code> 相加，因為它們是不同的型別。當我們在 Rust 中有個型別像是 <code>i8</code>，編譯器將會確保我們永遠會擁有有效數值。我們可以很放心地使用該值，而不必檢查是不是空的。我們只有在使用 <code>Option&lt;i8&gt;</code> （或者任何其他要使用的型別）時才需要去擔心會不會沒有值。然後編譯器會確保我們在使用該值前，有處理過該有的條件。</p>
<p>換句話說，你必須將 <code>Option&lt;T&gt;</code> 轉換為 <code>T</code> 你才能對 <code>T</code> 做運算。這通常就能幫助我們抓到空值最常見的問題：認為某值不為空，但它其實就是空值。</p>
<p>消除掉非空值是否正確的風險，可以讓你對你寫的程式碼更有信心。要讓一個值變成可能為空的話，你必須顯式建立成對應型別的 <code>Option&lt;T&gt;</code>。然後當你要使用該值時，你就得顯式處理數值是否為空的條件。只要一個數值的型別不是 <code>Option&lt;T&gt;</code>，你就<strong>可以</strong>安全地認定該值不為空。這是 Rust 刻意考慮的設計決定，限制無所不在的空值，並增強 Rust 程式碼的安全性。</p>
<p>所以當我們有一個數值型別 <code>Option&lt;T&gt;</code>，我們要怎麼從 <code>Some</code> 變體取出 <code>T</code>，好讓我們可以使用該值呢？<code>Option&lt;T&gt;</code> 枚舉有大量實用的方法可以在不同的場合下使用。你可以在<a href="https://doc.rust-lang.org/std/option/enum.Option.html">它的技術文件</a><!-- ignore -->查閱。更加熟悉 <code>Option&lt;T&gt;</code> 的方法十分益於你接下來的 Rust 旅程。</p>
<p>整體來說，要使用 <code>Option&lt;T&gt;</code> 數值的話，你要讓程式碼可以處理每個變體。你會希望有一些程式碼只會在當我們有 <code>Some(T)</code> 時執行，然後這些程式碼允許使用內部的 <code>T</code>。你會希望有另一部分的程式碼能在只有 <code>None</code> 時執行，且這些程式碼不會拿到有效的 <code>T</code> 數值。<code>match</code> 表達式正是處理此枚舉行為的控制流結構：它會針對不同的枚舉變體執行不同的程式碼，而且程式碼可以使用配對到的數值資料。</p>
<div style="break-before: page; page-break-before: always;"></div><p><a id="match-控制流運算子"></a></p>
<h2 id="match-控制流建構子"><a class="header" href="#match-控制流建構子"><code>match</code> 控制流建構子</a></h2>
<p>Rust 有個功能非常強大的控制流建構子叫做 <code>match</code>，你可以使用一系列模式來配對數值並依據配對到的模式來執行對應的程式。模式（Patterns）可以是字面數值、變數名稱、萬用字元（wildcards）和其他更多元件來組成。<a href="ch18-00-patterns.html">第十八章</a><!-- ignore -->會涵蓋所有不同類型的模式，以及它們的用途。<code>match</code> 強大的地方在於模式表達的清楚程度以及編譯器會確保所有可能的情況都處理了。</p>
<p>你可以想像 <code>match</code> 表達式成一個硬幣分類機器：硬幣會滑到不同大小的軌道，然後每個硬幣會滑入第一個符合大小的軌道。同樣地，數值會依序遍歷 <code>match</code> 的每個模式，然後進入第一個「配對」到該數值的模式所在的程式碼區塊，並在執行過程中使用。</p>
<p>既然我們都提到硬幣了，就讓我們用它們來作為 <code>match</code> 的範例吧！我們可以寫一個接收未知美國硬幣的函式，以類似驗鈔機的方式，決定它是何種硬幣並以美分作為單位回傳其值。如範例 6-3 所示。</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-3：枚舉以及用枚舉變體作為模式的 <code>match</code> 表達式</span></p>
<p>讓我們一一介紹 <code>value_in_cents</code> 函式中 <code>match</code> 的每個部分。首先我們使用 <code>match</code> 並加上一個表達式，在此例的話就是指 <code>coin</code>。這和 <code>if</code> 中條件表達式的用法很像。不過差別在於 <code>if</code> 中的條件必須是布林值，而在此它可以回傳任何型別。在此範例中 <code>coin</code> 的型別是我們在第一行定義的枚舉 <code>Coin</code>。</p>
<p>接下來是 <code>match</code> 的分支，每個分支有兩個部分：一個模式以及對應的程式碼。這邊第一個分支的模式是 <code>Coin::Penny</code> 然後 <code>=&gt;</code> 會將模式與要執行的程式碼分開來，而在此例的程式碼就只是個 <code>1</code>。每個分支之間由逗號區隔開來。</p>
<p>當 <code>match</code> 表達式執行時，他會將計算的數據結果依序與每個分支的模式做比較。如果有模式配對到該值的話，其對應的程式碼就會執行。如果該模式與數值不符的話，就繼續執行下一個分支，就像硬幣分類機器。</p>
<p>每個分支對應的程式碼都是表達式，然後在配對到的分支中表達式的數值結果就會是整個 <code>match</code> 表達式的回傳值。</p>
<p>如果配對分支的程式碼很短的話，我們通常就不會用到大括號，像是範例 6-3 每個分支就只回傳一個數值。如果你想要在配對分支執行多行程式碼的話，你就必須用大括號，然後你可以在括號後選擇性加上逗號。舉例來說，以下程式會在每次配對到 <code>Coin::Penny</code> 時印出「幸運幣！」再回傳程式碼區塊最後的數值 <code>1</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;幸運幣！&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="綁定數值的模式"><a class="header" href="#綁定數值的模式">綁定數值的模式</a></h3>
<p>另一項配對分支的實用功能是它們可以綁定配對模式中部分的數值，這讓我們可以取出枚舉變體中的數值。</p>
<p>舉例來說，讓我們改變我們其中一個枚舉變體成擁有資料。從 1999 年到 2008 年，美國在鑄造 25 美分硬幣時，其中一側會有 50 個州不同的設計。不過其他的硬幣就沒有這樣的設計，只有 25 美分會有特殊值而已。我們可以改變我們的 <code>enum</code> 中的 <code>Quarter</code> 變體成儲存 <code>UsState</code> 數值，如範例 6-4 所示。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // 這讓我們可以顯示每個州
enum UsState {
    Alabama,
    Alaska,
    // --省略--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-4：修改 <code>Coin</code> 枚舉的 <code>Quarter</code> 變體來包含一個 <code>UsState</code> 數值</span></p>
<p>讓我們想像有一個朋友想要收集所有 50 州的 25 美分硬幣。當我們在排序零錢的同時，我們會在拿到 25 美分時喊出該硬幣對應的州，好讓我們的朋友知道，如果他沒有的話就可以納入收藏。</p>
<p>在此程式中的配對表達式中，我們在 <code>Coin::Quarter</code> 變體的配對模式中新增了一個變數 <code>state</code>。當 <code>Coin::Quarter</code> 配對符合時，變數 <code>state</code> 會綁定該 25 美分的數值，然後我們就可以在分支程式碼中使用 <code>state</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --省略--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;此 25 美分所屬的州為 {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>如果我們呼叫 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> 的話，<code>coin</code> 就會是 <code>Coin::Quarter(UsState::Alaska)</code>。當我們比較每個配對分支時，我們會到 <code>Coin::Quarter(state)</code> 的分支才配對成功。此時 <code>state</code> 綁定的數值就會是 <code>UsState::Alaska</code>。我們就可以在 <code>println!</code> 表達式中使用該綁定的值，以此取得 <code>Coin</code> 枚舉中 <code>Quarter</code> 變體內的值。</p>
<h3 id="配對-optiont"><a class="header" href="#配對-optiont">配對 <code>Option&lt;T&gt;</code></a></h3>
<p>在上一個段落，我們想要在使用 <code>Option&lt;T&gt;</code> 時取得 <code>Some</code> 內部的 <code>T</code> 值。如同枚舉 <code>Coin</code>，我們一樣可以使用 <code>match</code> 來處理 <code>Option&lt;T&gt;</code>！相對於比較硬幣，我們要比較的是 <code>Option&lt;T&gt;</code> 的變體，不過 <code>match</code> 表達式運作的方式一模一樣。</p>
<p>假設我們要寫個接受 <code>Option&lt;i32&gt;</code> 的函式，而且如果內部有值的話就將其加上 1。如果內部沒有數值的話，該函式就回傳 <code>None</code> 且不再嘗試做任何動作。</p>
<p>拜 <code>match</code> 所賜，這樣的函式很容易寫出來，長得就像範例 6-5。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-5：對 <code>Option&lt;i32&gt;</code> 使用 <code>match</code> 表達式的函式</span></p>
<p>讓我們來仔細分析 <code>plus_one</code> 第一次的執行結果。當我們呼叫 <code>plus_one(five)</code> 時，<code>plus_one</code> 本體中的變數 <code>x</code> 會擁有 <code>Some(5)</code>。我們接著就拿去和每個配對分支比較：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> 並不符合 <code>None</code> 這樣的模式，所以我們繼續進行下一個分支：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> 有符合 <code>Some(i)</code> 這樣的模式嗎？這是當然的囉！我們有相同的變體。<code>i</code> 會綁定 <code>Some</code> 中的值，所以 <code>i</code> 會取得 <code>5</code>。接下來配對分支中的程式碼就會執行，我們將 1 加入 <code>i</code> 並產生新的 <code>Some</code> 其內部的值就會是 <code>6</code>。</p>
<p>現在讓我們看看範例 6-5 第二次的 <code>plus_one</code> 呼叫，這次的 <code>x</code> 是 <code>None</code>。我們進入 <code>match</code> 然後比較第一個分支：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>配對成功！因為沒有任何數值可以相加，程式就停止並在 <code>=&gt;</code> 之後馬上回傳 <code>None</code>。因為第一個分支就配對成功了，沒有其他的分支需要再做比較。</p>
<p>用 <code>match</code> 與枚舉組合起來在很多地方都很實用。你將會在許多 Rust 程式碼看到這樣的模式，使用 <code>match</code> 配對枚舉，綁定內部的資料，然後執行對應的程式碼。一開始使用的確會有點陌生，但當你熟悉以後，你會希望所有語言都能提供這樣的功能。這一直是使用者最愛的功能之一。</p>
<h3 id="配對必須是徹底的"><a class="header" href="#配對必須是徹底的">配對必須是徹底的</a></h3>
<p>我們還有一個 <code>match</code> 的細節要討論：分支的模式必須涵蓋所有可能性。今天要是我們像這樣寫了一個有錯誤的 <code>plus_one</code> 函式版本，它會無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>我們沒有處理到 <code>None</code> 的情形，所以此程式碼會產生錯誤。幸運的是這是 Rust 能夠抓到的錯誤。如果我們嘗試編譯此程式的話，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
note: `Option&lt;i32&gt;` defined here
  = note: the matched value is of type `Option&lt;i32&gt;`
help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown
  |
4 ~             Some(i) =&gt; Some(i + 1),
5 ~             None =&gt; todo!(),
  |

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</code></pre>
<p>Rust 發現我們沒有考慮到所有可能條件，而且還知道我們少了哪些模式！Rust 中的配對必須是<strong>徹底</strong>（<em>exhaustive</em>）的：我們必須列舉出所有可能的情形，程式碼才能夠被視為有效。尤其是在 <code>Option&lt;T&gt;</code> 的情況下，當 Rust 防止我們忘記處理 <code>None</code> 的情形時，它也使我們免於以為擁有一個有效實際上卻是空的值。因此要造成之前提過的十億美元級錯誤在這邊基本上是不可能的。</p>
<h3 id="catch-all-模式與-_-佔位符"><a class="header" href="#catch-all-模式與-_-佔位符">Catch-all 模式與 <code>_</code> 佔位符</a></h3>
<p>使用枚舉的話，我們可以針對特定數值作特別的動作，而對其他所有數值採取預設動作。想像一下我們正在做款骰子遊戲，如果你骰出 3 的話，你的角色就動不了，但是可以拿頂酷炫的帽子。如果你骰出 7 你的角色就損失那頂帽子。至於其他的數值，你的角色就按照那個數值在遊戲桌上移動步數。以下是用 <code>match</code> 實作出的邏輯，骰子的結果並非隨機數而是寫死的，且所有邏輯對應的函式本體都是空的，因為實際去實作並非本範例的重點：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
<span class="boring">}
</span></code></pre></pre>
<p>在前兩個分支中的模式分別為數值 <code>3</code> 和 <code>7</code>。至於最後一個涵蓋其他可能數值的分支，我們用變數 <code>other</code> 作為模式。在 <code>other</code> 分支執行的程式碼會將該變數傳入函式 <code>move_player</code> 中。</p>
<p>此程式碼就算我們沒有列完所有 <code>u8</code> 可能的數字也能編譯完成，因為最後的模式會配對所有尚未被列出來的數值。這樣的 catch-all 模式能滿足 <code>match</code> 必須要徹底的要求。注意到我們需要將 catch-all 分支放在最後面，因為模式是按照順序配對的。如果我們將 catch-all 放在其他分支前的話，這樣一來其他後面的分支就永遠配對不到了，所以要是我們在 catch-all 之後仍加上分支的話 Rust 會警告我們！</p>
<p>當我們想使用 catch-all 模式但不想<strong>使用</strong>其數值時，Rust 還有一種模式能讓我們使用：<code>_</code> 這是個特殊模式，用來配對任意數值且不綁定該數值。這告訴 Rust 我們不會用到該數值，所以 Rust 不會警告我們沒使用到變數。</p>
<p>讓我們來改變一下遊戲規則：如果你骰到除了 3 與 7 以外的話，你必須要重新擲骰。我們不需要用到 catch-all 的數值，所以我們可以修改我們的程式碼來使用 <code>_</code>，而不必繼續用變數 <code>other</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
<span class="boring">}
</span></code></pre></pre>
<p>此範例一樣也滿足徹底的要求，因為我們在最後的分支顯式地忽略其他所有數值，我們沒有遺漏任何值。</p>
<p>我們再改最後一次遊戲規則，改成如果你骰到除了 3 與 7 以外，不會有任何事發生的話，我們可以用單元數值（我們在<a href="ch03-02-data-types.html#%E5%85%83%E7%B5%84%E5%9E%8B%E5%88%A5">元組型別</a><!-- ignore -->段落提到的空元組）作為 <code>_</code> 的程式碼： </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; (),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
<span class="boring">}
</span></code></pre></pre>
<p>這裡我們顯式地告訴 Rust 我們不會使用任何其他沒被先前分支配對到的數值，而且我們也不想在此執行任何程式碼。</p>
<p>我們會在<a href="ch18-00-patterns.html">第十八章</a><!-- ignore -->更進一步探討模式與配對，現在我們要先去看看 <code>if let</code> 語法。當 <code>match</code> 表達式變得太囉嗦時，這語法就會變得很有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過-if-let-簡化控制流"><a class="header" href="#透過-if-let-簡化控制流">透過 <code>if let</code> 簡化控制流</a></h2>
<p><code>if let</code> 語法讓你可以用 <code>if</code> 與 <code>let</code> 的組合來以比較不冗長的方式，來處理只在乎其中一種模式而忽略其餘的數值。現在考慮一支程式如範例 6-6 所示，我們在配對 <code>config_max</code> 中 <code>Option&lt;u8&gt;</code> 的值，但只想在數值為 <code>Some</code> 變體時執行程式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;最大值被設為 {}&quot;, max),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-6：<code>match</code> 只在數值為 <code>Some</code> 時執行程式</span></p>
<p>如果數值為 <code>Some</code>，我們就在分支中綁定 <code>max</code> 變數，印出 <code>Some</code> 變體內的數值。我們不想對 <code>None</code> 作任何事情。為了滿足 <code>match</code> 表達式，我們必須在只處理一種變體的分支後面，再加上 <code>_ =&gt; ()</code>。這樣就加了不少樣板程式碼。</p>
<p>不過我們可以使用 <code>if let</code> 以更精簡的方式寫出來，以下程式碼的行為就與範例 6-6 的 <code>match</code> 一樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;最大值被設為 {}&quot;, max);
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> 接收一個模式與一個表達式，然後用等號區隔開來。它與 <code>match</code> 的運作方式相同，表達式的意義與 <code>match</code> 相同，然後前面的模式就是第一個分支。
在此例中的模式就是 <code>Some(max)</code>，然後 <code>max</code> 會綁定 <code>Some</code> 內的數值。我們就和 <code>match</code> 分支中使用 <code>max</code> 一樣，在 <code>if let</code> 區塊的本體中使用 <code>max</code>。如果數值沒有配對到模式，<code>if let</code> 中的程式碼就不會執行。</p>
<p>使用 <code>if let</code> 可以少打些字、減少縮排以及不用寫多餘的樣板程式碼。不過你就少了 <code>match</code> 強制的徹底窮舉檢查。要何時選擇 <code>match</code> 還是 <code>if let</code> 得依據你在的場合是要做什麼事情，以及在精簡度與徹底檢查之間做取捨。</p>
<p>換句話說，你可以想像 <code>if let</code> 是 <code>match</code> 的語法糖（syntax sugar），它只會配對一種模式來執行程式碼並忽略其他數值。</p>
<p>我們也可以在 <code>if let</code> 之後加上 <code>else</code>，<code>else</code> 之後的程式碼區塊等同於 <code>match</code> 表達式中 <code>_</code> 情形的程式碼區塊。這樣一來的 <code>if let</code> 和 <code>else</code> 組合就等同於 <code>match</code> 了。回想一下範例 6-4 的 <code>Coin</code> 枚舉定義， <code>Quarter</code> 變體擁有數值 <code>UsState</code>。如果我們希望統計所有不是 25 美分的硬幣的同時，也能繼續回報 25 美分所屬的州的話，我們可以用 <code>match</code> 像這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --省略--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;此 25 美分所屬的州為 {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>或是我們也可以用 <code>if let</code> 和 <code>else</code> 表達式這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --省略--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;此 25 美分所屬的州為 {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果你的程式碼邏輯遇到使用 <code>match</code> 表達會太囉唆的話，記得 <code>if let</code> 也在你的 Rust 工具箱中供你使用。</p>
<h2 id="總結-5"><a class="header" href="#總結-5">總結</a></h2>
<p>我們現在涵蓋了如何使用枚舉來建立一系列枚舉數值的自訂型別。我們展示了標準函式庫的 <code>Option&lt;T&gt;</code> 型別如何用型別系統來預防錯誤。當枚舉數值其內有資料時，你可以依照你想處理的情況數量，使用 <code>match</code> 或 <code>if let</code> 來取出並使用那些數值。</p>
<p>你的 Rust 程式碼現在能夠使用結構體與枚舉來表達你所相關研究領域的概念了。在你的 API 建立自訂型別可以確保型別安全，編譯器會保證你的函式只會取得該函式預期的型別數值。</p>
<p>接下來為了提供組織完善且直觀的的 API 供你的使用者使用，並只表達出使用者確切所需要的內容，我們需要瞭解 Rust 的模組。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="透過套件crate-與模組管理成長中的專案"><a class="header" href="#透過套件crate-與模組管理成長中的專案">透過套件、Crate 與模組管理成長中的專案</a></h1>
<p>當你寫的程式規模更大時，組織你的程式碼就很重要。因為用你的腦袋要記住整個程式碼是幾乎不可能的。要是能組織相關功能的程式碼並將它們分成明確功能的話，你就能清楚地找到實作特定功能的程式碼，以及該在哪裏修改該功能的行為。</p>
<p>我們之前寫過的程式都只在一個檔案內的一個模組（module）中。隨著專案成長，我們應該要組織程式碼，拆成數個模組與數個檔案。一個套件（package）可以包含數個執行檔 crate 以及選擇性提供一個函式庫 crate。隨著套件增長，你可以取出不同的部分作為獨立的 crate，成為對外的依賴函式庫。此章節將會介紹這些所有概念。對於非常龐大的專案，需要一系列的關聯套件組合在一起的話，Cargo 有提供<strong>工作空間</strong>（workspaces），我們會在第十四章的<a href="ch14-03-cargo-workspaces.html">「Cargo 工作空間」</a><!-- ignore -->做介紹。</p>
<p>我們還會討論對實作細節進行封裝，讓你的程式碼在頂層更好使用。一旦你實作了某項功能，其他程式就可以用程式碼的公開介面呼叫該程式碼，而不必去知道它實作如何運作。你在寫程式碼時會去定義哪些部分是給其他程式碼公開使用的，以及哪些部分是私底下你可以任意修改的實作細節。這能再減少你的腦袋需要煩惱的細節數量。</p>
<p>還有一個概念需要再提一次，也就是作用域（scope）：程式碼需要能被定義在「作用域內」並要能夠指明此作用域。當讀取寫入或編譯程式碼時，程式設計師與編譯器需要知道特定地點的名稱，才能知道其內的變數、函式、結構體、枚舉、常數或其他任何有意義的項目。你可以建立作用域，並改變其在作用域內與作用域外的名稱。你無法在同個作用域內擁有兩個相同名稱的項目。我們可以使用一些工具來解決名稱衝突的問題。</p>
<p>Rust 有一系列的功能能讓你管理你的程式碼組織，包含哪些細節能對外提供、哪些細節是私有的，以及程式中每個作用域的名稱為何。這些功能有時會統一稱作<em>模組系統（module system）</em>，其中包含：</p>
<ul>
<li><strong>套件（Package）：</strong> 讓你建構、測試並分享 crate 的 Cargo 功能</li>
<li><strong>Crates：</strong> 產生函式庫或執行檔的模組集合</li>
<li><strong>模組（Modules）與 use：</strong> 讓你控制組織、作用域與路徑的隱私權</li>
<li><strong>路徑（Paths）:</strong> 對一個項目的命名方式，像是一個結構體、函式或模組</li>
</ul>
<p>在本章節中，我們會涵蓋所有這些功能，討論它們如何互動，並解釋如何使用它們來管理作用域。在讀完後，你應該就會對模組系統有紮實的認知，並能夠對作用域的使用駕輕就熟！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="套件與-crates"><a class="header" href="#套件與-crates">套件與 Crates</a></h2>
<p>首先我們要介紹的第一個模組系統部分為套件與 crates。</p>
<p>一個 <em>crate</em> 是 Rust 編譯器同個時間內視為程式碼的最小單位。就算你執行的是 <code>rustc</code> 而非 <code>cargo</code>，然後傳入單一源碼檔案（就像我們在第一章的「編寫並執行 Rust 程式」那樣），編譯器會將該檔案視為一個 crate。Crate 能包含模組，而模組可以在其他檔案中定義然後同時與 crate 一起編譯，我們會在接下來的段落看到。</p>
<p>一個 crate 可以有兩種形式：執行檔 crate 或函式庫 crate。<strong>執行檔（Binary）crate</strong> 是種你能編譯成執行檔並執行的程式，像是命令列程式或伺服器。這種 crate 需要有一個函式 <code>main</code> 來定義執行檔執行時該做什麼事。目前我們建立的所有 crate 都是執行檔 crate。</p>
<p><strong>函式庫（Library）crate</strong> 則不會有 <code>main</code> 函式，而且它們也不會編譯成執行檔。這種 crate 定義的功能用來分享給多重專案使用。舉例來說，我們在<a href="ch02-00-guessing-game-tutorial.html#%E7%94%A2%E7%94%9F%E9%9A%A8%E6%A9%9F%E6%95%B8%E5%AD%97">第二章</a><!-- ignore -->用到的 <code>rand</code> crate 就提供了產生隨機數值的功能。當大多數的 Rustacean 講到「crate」時，他們其實指的是函式庫 crate，所以他們講到「crate」時相當於就是在講其他程式語言概念中的「函式庫」。</p>
<p><strong>crate 的源頭</strong>會是一個原始檔案，讓 Rust 的編譯器可以作為起始點並組織 crate 模組的地方（我們會在<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">「定義模組來控制作用域與隱私權」</a><!-- ignore -->的段落更加解釋模組）。</p>
<p><strong>套件</strong>（package）則是提供一系列功能的一或數個 crate。一個套件會包含一個 <em>Cargo.toml</em> 檔案來解釋如何建構那些 crate。Cargo 本身其實就是個套件，包含了你已經用來建構程式碼的命令列工具。Cargo 套件還包含執行檔 crate 需要依賴的函式庫 crate。其他專案可以依賴 Cargo 函式庫來使用與 Cargo 命令列工具用到的相同邏輯功能。</p>
<p>一個套件能依照你的喜好擁有數個執行檔 crate，但最多只能有一個函式庫 crate。而一個套件至少要有一個 crate，無論是函式庫或執行檔 crate。</p>
<p>讓我們看看當我們建立一個套件時發生了什麼事。首先我們先輸入 <code>cargo new</code> 命令：</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>在我們執行 <code>cargo new</code> 之後，我們使用 <code>ls</code> 來查看 Cargo 建立了什麼。在專案的目錄中會有個 <em>Cargo.toml</em> 檔案，這是套件的設定檔。然後還會有個 <em>src</em> 目錄底下包含了 <em>main.rs</em>。透過你的文字編輯器打開 <em>Cargo.toml</em>，你會發現沒有提到 <em>src/main.rs</em>。Cargo 遵循的常規是 <em>src/main.rs</em> 就是與套件同名的執行檔 crate 的 crate 源頭。同樣地，Cargo 也會知道如果套件目錄包含 <em>src/lib.rs</em>的話，則該套件就會包含與套件同名的函式庫 crate。Cargo 會將 crate 源頭檔案傳遞給 <code>rustc</code> 來建構函式庫或執行檔。</p>
<p>我們在此的套件只有包含 <em>src/main.rs</em> 代表它只有一個同名的執行檔 crate 叫做 <code>my-project</code>。如果套件包含 <em>src/main.rs</em> 與 <em>src/lib.rs</em> 的話，它就有兩個 crate：一個執行檔與一個函式庫，兩者都與套件同名。一個套件可以有多個執行檔 crate，只要將檔案放在 <em>src/bin</em> 目錄底下就好，每個檔案會被視為獨立的執行檔 crate。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="定義模組來控制作用域與隱私權"><a class="header" href="#定義模組來控制作用域與隱私權">定義模組來控制作用域與隱私權</a></h2>
<p>在此段落，我們將討論模組以及其他模組系統的部分，像是<strong>路徑</strong>（paths）允許你來命名項目，而 <code>use</code> 關鍵字可以將路徑引入作用域，再來 <code>pub</code> 關鍵字可以讓指定的項目對外公開。我們還會討論到 <code>as</code> 關鍵字、外部套件以及全域（glob）運算子。</p>
<p>首先，讓我們先介紹一些規則好讓你在之後組織程式碼時能更容易理解初步概念。然後我們會再詳細解釋每個規則。</p>
<h3 id="模組懶人包"><a class="header" href="#模組懶人包">模組懶人包</a></h3>
<p>這裡我們先快速帶過模組、路徑、<code>use</code> 關鍵字以及 <code>pub</code> 關鍵字在編譯器中是怎麼運作的，以及多數開發者會怎麼組織他們的程式碼。我們會在此章節透過範例逐依介紹，不過這裡能讓你快速理解模組是怎麼運作的。</p>
<ul>
<li><strong>從 crate 源頭開始</strong>：在編譯 crate 時，編譯器會先尋找 crate 源頭檔案（函式庫 crate 的話，通常就是 <em>src/lib.rs</em>；執行檔 crate 的話，通常就是 <em>src/main.rs</em>）來編譯程式碼。</li>
<li><strong>宣告模組</strong>：在 crate 源頭檔案中，你可以宣告新的模組，比如說你宣告了一個「garden」模組 <code>mod garden;</code>。編譯器會在以下這幾處尋找模組的程式碼：
<ul>
<li>同檔案內用 <code>mod garden</code> 加上大括號，寫在括號內的程式碼</li>
<li><em>src/garden.rs</em> 檔案中</li>
<li><em>src/garden/mod.rs</em> 檔案中</li>
</ul>
</li>
<li><strong>宣告子模組</strong>：除了 crate 源頭以外，其他檔案也可以宣告子模組。舉例來說，你可能會在 <em>src/garden.rs</em> 中宣告個 <code>mod vegetables;</code>。編譯器會與當前模組同名的目錄底下這幾處尋找子模組的程式碼：
<ul>
<li>同檔案內，直接用 <code>mod vegetables</code> 加上大括號，寫在括號內的程式碼</li>
<li><em>src/garden/vegetables.rs</em> 檔案中</li>
<li><em>src/garden/vegetables/mod.rs</em> 檔案中</li>
</ul>
</li>
<li><strong>模組的路徑</strong>：一旦有個模組成為 crate 的一部分，只要隱私權規則允許，你可以在 crate 裡任何地方使用該模組的程式碼。舉例來說，「garden」模組底下的「vegetables」模組的 <code>Asparagus</code> 型別可以用 <code>crate::garden::vegetables::Asparagus</code> 來找到。</li>
<li><strong>私有 vs 公開</strong>：模組內的程式碼從上層模組來看預設是私有的。要公開的話，將它宣告為 <code>pub mod</code> 而非只是 <code>mod</code>。要讓公開模組內的項目也公開的話，在這些項目前面也加上 <code>pub</code> 即可。</li>
<li><strong><code>use</code> 關鍵字</strong>：在一個作用域內，<code>use</code> 關鍵字可以建立項目的捷徑，來縮短冗長的路徑名稱。在任何能使用 <code>crate::garden::vegetables::Asparagus</code> 的作用域中，你可以透過 <code>use crate::garden::vegetables::Asparagus;</code> 來建立捷徑，接著你只需要寫 <code>Asparagus</code> 就能在作用域內使用該型別了。</li>
</ul>
<p>這裡我們建立個執行檔 crate 叫做 <code>backyard</code> 來展示這些規則。Crate 的目錄也叫做 <code>backyard</code>，其中包含了這些檔案與目錄：</p>
<pre><code class="language-text">backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
</code></pre>
<p>此例的 crate 源頭檔案就是 <em>src/main.rs</em>，它包含了：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust noplayground ignore">use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!(&quot;I'm growing {:?}!&quot;, plant);
}
</code></pre>
<p><code>pub mod garden;</code> 這行告訴編譯器要包含在 <em>src/garden.rs</em> 中的程式碼，也就是：</p>
<p><span class="filename">檔案名稱：src/garden.rs</span></p>
<pre><code class="language-rust noplayground ignore">pub mod vegetables;
</code></pre>
<p>這裡的 <code>pub mod vegetables;</code> 代表 <em>src/garden/vegetables.rs</em> 的程式碼也包含在內。而這段程式碼就是：</p>
<pre><code class="language-rust noplayground ignore">#[derive(Debug)]
pub struct Asparagus {}
</code></pre>
<p>現在讓我們詳細介紹這些規則並解釋如何運作的吧！</p>
<h3 id="組織相關程式碼成模組"><a class="header" href="#組織相關程式碼成模組">組織相關程式碼成模組</a></h3>
<p><strong>模組</strong>（Modules）能讓我們在 crate 內組織程式碼成數個群組以便使用且增加閱讀性。模組也能控制項目的<strong>隱私權</strong>，因為模組內的程式碼預設是私有的。私有項目是內部的實作細節，並不打算讓外部能使用。我們能讓模組與其內的項目公開，讓外部程式碼能夠使用並依賴它們。</p>
<p>舉例來說，讓我們建立一個提供餐廳功能的函式庫 crate。我們定義一個函式簽名不過本體會是空的，好讓我們專注在程式組織，而非餐廳程式碼的實作。</p>
<p>在餐飲業中，餐廳有些地方會被稱作<strong>前台（front of house）<strong>而其他部分則是</strong>後台（back of house）</strong>。前台是消費者的所在區域，這裡是安排顧客座位、點餐並結帳、吧台調酒的地方。而後台則是主廚與廚師工作的廚房、洗碗工洗碗以及經理管理行政工作的地方。</p>
<p>要讓 crate 架構長這樣的話，我們可以組織函式進入模組中。要建立一個新的函式庫叫做 <code>restaurant</code> 的話，請執行 <code>cargo new --lib restaurant</code>。然後將範例 7-1 的程式碼放入 <em>src/lib.rs</em> 中，這定義了一些模組與函式簽名。以下是前台的段落：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p><span class="caption">範例 7-1：<code>front_of_house</code> 模組包含了其他擁有函式的模組</span></p>
<p>我們用 <code>mod</code> 關鍵字加上模組的名稱（在此例為 <code>front_of_house</code>）來定義一個模組，並用大括號涵蓋模組的本體。在模組中，我們可以再包含其他模組，在此例中我們包含了 <code>hosting</code> 和 <code>serving</code>。模組還能包含其他項目，像是結構體、枚舉、常數、特徵、以及像是範例 7-1 的函式。</p>
<p>使用模組的話，我們就能將相關的定義組合起來，並用名稱指出會與它們互相關聯。程式設計師在使用此程式碼時只要觀察依據組合起來的模組名稱就好，不必遍歷所有的定義。這樣就能快速找到他們想使用的定義。要對此程式碼增加新功能的開發者也能知道該將程式碼放在哪裡，以維持程式碼的組織。</p>
<p>稍早我們提到說 <em>src/main.rs</em> 和 <em>src/lib.rs</em> 屬於 crate 的源頭。之所以這樣命名的原因是因為這兩個文件的內容都會在 crate 源頭模組架構中組成一個模組叫做 <code>crate</code>，這樣的結構稱之為<strong>模組樹（module tree）</strong>。</p>
<p>範例 7-2 顯示了範例 7-1 的模組樹架構。</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">範例 7-2：範例 7-1 的模組樹</span></p>
<p>此樹顯示了有些模組是包含在其他模組內的，比方說 <code>hosting</code> 就在 <code>front_of_house</code> 底下。此樹也顯示了有些模組是其他模組的<strong>同輩（siblings）</strong>，代表它們是在同模組底下定義的，<code>hosting</code> 和 <code>serving</code> 都在 <code>front_of_house</code> 底下定義。如果模組 A 被包含在模組 B 中，我們會說模組 A 是模組 B 的<strong>下一代（child）</strong>，而模組 B 是模組 A 的<strong>上一代（parent）</strong>。注意到整個模組樹的根是一個隱性模組叫做 <code>crate</code>。</p>
<p>模組樹可能會讓你想到電腦中檔案系統的目錄樹，這是一個非常恰當的比喻！就像檔案系統中的目錄，你使用模組來組織你的程式碼。而且就像目錄中的檔案，我們需要有方法可以找到我們的模組。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="參考模組項目的路徑"><a class="header" href="#參考模組項目的路徑">參考模組項目的路徑</a></h2>
<p>要展示 Rust 如何從模組樹中找到一個項目，我們要使用和查閱檔案系統時一樣的路徑方法。要呼叫函式的話，我們需要知道它的路徑：</p>
<p>路徑可以有兩種形式：</p>
<ul>
<li><strong>絕對路徑</strong>（absolute path）是從 crate 的源頭起始的完整路徑。如果是外部 crate 的話，絕對路徑起始於該 crate 的名稱；如果是當前 crate 的話，則是 <code>crate</code> 作為起頭。</li>
<li><strong>相對路徑</strong>（relative path）則是從本身的模組開始，使用 <code>self</code>、<code>super</code> 或是當前模組的標識符（identifiers）。</li>
</ul>
<p>無論是絕對或相對路徑其後都會接著一或多個標識符，並使用雙冒號（<code>::</code>）區隔開來。</p>
<p>回頭看看範例 7-1，假設我們想呼叫函式 <code>add_to_waitlist</code>。這就像在問函式 <code>add_to_waitlist</code> 的路徑在哪？範例 7-3 移除了一些範例 7-1 的模組與函式來精簡程式碼的呈現方式。</p>
<p>我們會展示兩種從 crate 源頭定義的 <code>eat_at_restaurant</code> 函式內呼叫 <code>add_to_waitlist</code> 的方法。這些路徑是正確的，不過目前還有其他問題會導致此範例無法編譯，我們會在稍後說明。</p>
<p><code>eat_at_restaurant</code> 函式是我們函式庫 crate 公開 API 的一部分，所以我們會加上 <code>pub</code> 關鍵字。在<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E4%BD%BF%E7%94%A8-pub-%E9%97%9C%E9%8D%B5%E5%AD%97%E5%85%AC%E9%96%8B%E8%B7%AF%E5%BE%91">「使用 <code>pub</code> 關鍵字公開路徑」</a><!-- ignore -->的段落中，我們會提到更多 <code>pub</code> 的細節。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絕對路徑
    crate::front_of_house::hosting::add_to_waitlist();

    // 相對路徑
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-3：使用絕對與相對路徑呼叫 <code>add_to_waitlist</code> 函式</span></p>
<p>我們在 <code>eat_at_restaurant</code> 中第一次呼叫 <code>add_to_waitlist</code> 函式的方式是用絕對路徑。<code>add_to_waitlist</code> 函式和 <code>eat_at_restaurant</code> 都是在同一個 crate 底下，所以我們可以使用 <code>crate</code> 關鍵字來作為絕對路徑的開頭。我們接續加上對應的模組直到抵達 <code>add_to_waitlist</code>。你可以想像一個有相同架構的檔案系統，然後我們指定 <code>/front_of_house/hosting/add_to_waitlist</code> 這樣的路徑來執行 <code>add_to_waitlist</code> 程式。使用 <code>crate</code> 這樣的名稱作為 crate 源頭的開始，就像在你的 shell 使用 <code>/</code> 作為檔案系統的根一樣。</p>
<p>而我們第二次在 <code>eat_at_restaurant</code> 呼叫 <code>add_to_waitlist</code> 的方式是使用相對路徑。路徑的起頭是 <code>front_of_house</code>，因為它和 <code>eat_at_restaurant</code> 都被定義在模組樹的同一層中。這裡相對應的檔案系統路徑就是 <code>front_of_house/hosting/add_to_waitlist</code>。使用一個模組名稱作為開頭通常就是代表相對路徑。</p>
<p>何時該用相對或絕對路徑是你在你的專案中要做的選擇，依照你想將程式碼的定義連帶與使用它們的程式碼一起移動，或是分開移動到不同地方。舉例來說，如果我們同時將 <code>front_of_house</code> 模組和 <code>eat_at_restaurant</code> 函式移入另一個模組叫做 <code>customer_experience</code> 的話，就會需要修改 <code>add_to_waitlist</code> 的絕對路徑，但是相對路徑就可以原封不動。而如果我們只單獨將 <code>eat_at_restaurant</code> 函式移入一個叫做 <code>dining</code> 模組的話，<code>add_to_waitlist</code> 的絕對路徑就不用修改，但相對路徑就需要更新。我們通常會傾向於指定絕對路徑，因為分別移動程式碼定義與項目呼叫的位置通常是比較常見的。</p>
<p>讓我們嘗試編譯範例 7-3 並看看為何不能編譯吧！以下範例 7-4 是我們得到的錯誤資訊。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">範例 7-4：範例 7-3 嘗試編譯程式碼出現的錯誤</span></p>
<p>錯誤訊息表示 <code>hosting</code> 模組是私有的。換句話說，我們指定 <code>hosting</code> 模組與 <code>add_to_waitlist</code> 函式的路徑是正確的，但是因為它沒有私有部分的存取權，所以 Rust 不讓我們使用。在 Rust 中所有項目（函式、方法、結構體、枚舉、模組與常數）的隱私權都是私有的。如果你想要建立私有的函式或結構體，你可以將它們放入模組內。</p>
<p>上層模組的項目無法使用下層模組的私有項目，但下層模組能使用它們上方所有模組的項目。這麼做的原因是因為下層模組用來實現實作細節，而下層模組應該要能夠看到在自己所定義的地方的其他內容。讓我們繼續用餐廳做比喻的話，我們可以想像隱私權規則就像是餐廳的後台辦公室。對餐廳顧客來說裡面發生什麼事情都是未知的，但是辦公室經理可以知道經營餐廳時的所有事物。</p>
<p>Rust 選擇這樣的模組系統，讓內部實作細節預設都是隱藏起來的。這樣一來，你就能知道內部哪些程式碼需要修改，而不會破壞到外部的程式碼。不過 Rust 有提供 <code>pub</code> 關鍵字能讓項目公開，讓你可以將下層模組內部的一些程式碼公開給上層模組來使用。</p>
<h3 id="使用-pub-關鍵字公開路徑"><a class="header" href="#使用-pub-關鍵字公開路徑">使用 <code>pub</code> 關鍵字公開路徑</a></h3>
<p>讓我們再執行一次範例 7-4 的錯誤，它告訴我們 <code>hosting</code> 模組是私有的。我們希望上層模組中的 <code>eat_at_restaurant</code> 函式可以呼叫下層模組的 <code>add_to_waitlist</code> 函式，所以我們將 <code>hosting</code> 模組加上 <code>pub</code> 關鍵字，如範例 7-5 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絕對路徑
    crate::front_of_house::hosting::add_to_waitlist();

    // 相對路徑
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-5：宣告 <code>hosting</code> 模組為 <code>pub</code> 好讓 <code>eat_at_restaurant</code> 可以使用</span></p>
<p>不幸的是範例 7-5 的程式碼仍然回傳了另一個錯誤，如範例 7-6 所示。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
<p><span class="caption">範例 7-6：編譯範例 7-5 時產生的錯誤</span></p>
<p>到底發生了什麼事？在 <code>mod hosting</code> 之前加上 <code>pub</code> 關鍵字確實公開了模組。有了這項修改後，我們的確可以在取得 <code>front_of_house</code> 的後繼續進入 <code>hosting</code>。但是 <code>hosting</code> 的所有<strong>內容</strong>仍然是私有的。模組中的 <code>pub</code> 關鍵字只會讓該模組公開讓上層模組使用而已，而不是存取它所有的內部程式碼。因為模組相當於一個容器，如果我們只公開模組的話，本身並不能做多少事情。我們需要再進一步選擇公開模組內一些項目才行。</p>
<p>範例 7-6 的錯誤訊息表示 <code>add_to_waitlist</code> 函式是私有的。隱私權規則如同模組一樣適用於結構體、枚舉、函式與方法。</p>
<p>讓我們在 <code>add_to_waitlist</code> 的函式定義加上 <code>pub</code> 公開它吧，如範例 7-7 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絕對路徑
    crate::front_of_house::hosting::add_to_waitlist();

    // 相對路徑
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-7：將 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 都加上 <code>pub</code> 關鍵字，讓我們可以從 <code>eat_at_restaurant</code> 呼叫函式</span></p>
<p>現在程式碼就能成功編譯了！要理解為何加上 <code>pub</code> 關鍵字讓我們可以在 <code>add_to_waitlist</code> 取得這些路徑，同時遵守隱私權規則，讓我們來看看絕對路徑與相對路徑。</p>
<p>在絕對路徑中，我們始於 <code>crate</code>，這是 crate 模組樹的根。再來 <code>front_of_house</code> 模組被定義在 crate 源頭中，<code>front_of_house</code> 模組不是公開，但因為 <code>eat_at_restaurant</code> 函式被定義在與 <code>front_of_house</code> 同一層模組中（也就是 <code>eat_at_restaurant</code> 與 <code>front_of_house</code> 同輩（siblings）），我們可以從 <code>eat_at_restaurant</code> 參考 <code>front_of_house</code>。接下來是有 <code>pub</code> 標記的 <code>hosting</code> 模組，我們可以取得 <code>hosting</code> 的上層模組，所以我們可以取得 <code>hosting</code>。最後 <code>add_to_waitlist</code> 函式也有 <code>pub</code> 標記而我們可以取得它的上層模組，所以整個程式呼叫就能執行了！</p>
<p>而在相對路徑中，基本邏輯與絕對路徑一樣，不過第一步有點不同。我們不是從 crate 源頭開始，路徑是從 <code>front_of_house</code> 開始。<code>front_of_house</code> 與 <code>eat_at_restaurant</code> 被定義在同一層模組中，所以從 <code>eat_at_restaurant</code> 開始定義的相對路徑是有效的。再來因為 <code>hosting</code> 與 <code>add_to_waitlist</code> 都有 <code>pub</code> 標記，其餘的路徑也都是可以進入的，所以此函式呼叫也是有效的！</p>
<p>如果你計畫分享你的函式庫 crate 來讓其他專案能使用你的程式碼，你的公開 API 就是你對 crate 使用者的合約，這會決定他們能如何使用你的程式碼。這需要考量管理你的公開 API，好讓其他人能輕鬆依賴你的 crate。這類的考量不在本書的範疇，如果你對於此議題有興趣的話，請查看 <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>。</p>
<blockquote>
<h4 id="執行檔與函式庫套件的最佳實踐"><a class="header" href="#執行檔與函式庫套件的最佳實踐">執行檔與函式庫套件的最佳實踐</a></h4>
<p>我們提到套件能同時包含 <em>src/main.rs</em> 作為執行檔 crate 源頭以及 <em>src/lib.rs</em> 作為函式庫 crate 源頭，兩者預設都是用套件的名稱。通常來說，一個函式庫與一個執行檔 crate 這樣的套件模式，在執行檔中只會留下必要的程式碼，其餘則呼叫函式庫的程式碼。這樣其他專案也能運用到套件提供的多數功能，因為函式庫 crate 的程式碼可以分享。</p>
<p>模組要定義在 <em>src/lib.rs</em>。然後在執行檔 crate 中，任何公開項目都能用套件名稱作為開頭找到。執行檔 crate 應視為函式庫 crate 的使用者，就像外部 crate 那樣使用一樣，只能使用公開 API。這有助於你設計出良好的 API，你不僅是作者，同時還是自己的客戶！</p>
<p>在<a href="ch12-00-an-io-project.html">第十二章</a><!-- ignore -->中，我們會透過寫個命令列程式來介紹這樣的組織練習，該程式會包含一個執行檔 crate 與一個函式庫 crate。</p>
</blockquote>
<h3 id="使用-super-作為相對路徑的開頭"><a class="header" href="#使用-super-作為相對路徑的開頭">使用 <code>super</code> 作為相對路徑的開頭</a></h3>
<p>我們可以在路徑開頭使用 <code>super</code> 來建構從上層模組出發的相對路徑，而不用從 crate 源頭開始。這就像在檔案系統中使用 <code>..</code> 作為路徑開頭一樣。使用 <code>super</code> 讓我們能參考確定位於上層模組的項目。當模組與上層模組有高度關聯，且上層模組可能以後會被移到模組樹的其他地方時，這能讓組織模組樹更加輕鬆。</p>
<p>請考慮範例 7-8 的程式碼，這模擬了一個主廚修正一個錯誤的訂單，並親自提供給顧客的場景。定義在 <code>back_of_house</code> 模組的函式 <code>fix_incorrect_order</code> 呼叫了定義在上層模組的函式 <code>deliver_order</code>，不過這次是使用 <code>super</code> 來指定 <code>deliver_order</code> 的路徑：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
<p><span class="caption">範例 7-8：使用 <code>super</code> 作為呼叫函式路徑的開頭</span></p>
<p><code>fix_incorrect_order</code> 函式在 <code>back_of_house</code> 模組中，所以我們可以使用 <code>super</code> 前往 <code>back_of_house</code> 的上層模組，在此例的話就是源頭 <code>crate</code>。然後在此時我們就能找到 <code>deliver_order</code>。成功！我們認定 <code>back_of_house</code> 模組與 <code>deliver_order</code> 函式應該會維持這樣相同的關係，在我們要組織 crate 的模組樹時，它們理當一起被移動。因此我們使用 <code>super</code> 讓我們在未來程式碼被移動到不同模組時，我們不用更新太多程式路徑。</p>
<h3 id="公開結構體與枚舉"><a class="header" href="#公開結構體與枚舉">公開結構體與枚舉</a></h3>
<p>我們也可以使用 <code>pub</code> 來公開結構體與枚舉，但是我們有些額外細節要考慮到。如果我們在結構體定義之前加上 <code>pub</code> 的話，我們的確能公開結構體，但是結構體內的欄位仍然會是私有的。我們可以視情況決定每個欄位要不要公開。在範例 7-9 我們定義了一個公開的結構體 <code>back_of_house::Breakfast</code> 並公開欄位 <code>toast</code>，不過將欄位 <code>seasonal_fruit</code> 維持是私有的。這次範例模擬的情境是，餐廳顧客可以選擇早餐要點什麼類型的麵包，但是由主廚視庫存與當季食材來決定提供何種水果。餐廳提供的水果種類隨季節變化很快，所以顧客無法選擇或預先知道他們會拿到何種水果。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;桃子&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 點夏季早餐並選擇黑麥麵包
    let mut meal = back_of_house::Breakfast::summer(&quot;黑麥&quot;);
    // 我們想改成全麥麵包
    meal.toast = String::from(&quot;全麥&quot;);
    println!(&quot;我想要{}麵包，謝謝&quot;, meal.toast);

    // 接下來這行取消註解的話，我們就無法編譯通過
    // 我們無法擅自更改餐點搭配的季節水果
    // meal.seasonal_fruit = String::from(&quot;藍莓&quot;);
}
</code></pre>
<p><span class="caption">範例 7-9：一個有些欄位公開而有些是私有欄位的結構體</span></p>
<p>因為 <code>back_of_house::Breakfast</code> 結構體中的 <code>toast</code> 欄位是公開的，在 <code>eat_at_restaurant</code> 中我們可以加上句點來對 <code>toast</code> 欄位進行讀寫。注意我們不能在 <code>eat_at_restaurant</code> 使用 <code>seasonal_fruit</code> 欄位，因為它是私有的。請嘗試解開修改 <code>seasonal_fruit</code> 欄位數值的那行程式註解，看看你會獲得什麼錯誤！</p>
<p>另外因為 <code>back_of_house::Breakfast</code> 擁有私有欄位，該結構體必須提供一個公開的關聯函式（associated function）才有辦法產生 <code>Breakfast</code> 的實例（我們在此例命名為 <code>summer</code>）。如果 <code>Breakfast</code> 沒有這樣的函式的話，我們就無法在 <code>eat_at_restaurant</code> 建立 <code>Breakfast</code> 的實例，因為我們無法在 <code>eat_at_restaurant</code> 設置私有欄位 <code>seasonal_fruit</code> 的數值。</p>
<p>接下來，如果我們公開枚舉的話，那它所有的變體也都會公開。我們只需要在 <code>enum</code> 關鍵字之前加上 <code>pub</code> 就好，如範例 7-10 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
</code></pre>
<p><span class="caption">範例 7-10：公開枚舉會讓其所有變體也公開</span></p>
<p>因為我們公開了 <code>Appetizer</code> 枚舉，我們可以在 <code>eat_at_restaurant</code> 使用 <code>Soup</code> 和 <code>Salad</code>。</p>
<p>枚舉的變體沒有全部都公開的話，通常會讓枚舉很不好用。要用 <code>pub</code> 標註所有的枚舉變體都公開的話又很麻煩。所以公開枚舉的話，預設就會公開其變體。相反地，結構體不讓它的欄位全部都公開的話，通常反而比較實用。因此結構體欄位的通用原則是預設為私有，除非有 <code>pub</code> 標註。</p>
<p>我們還有一個 <code>pub</code> 的使用情境還沒提到，也就是我們模組系統最後一項功能：<code>use</code> 關鍵字。我們接下來會先解釋 <code>use</code>，再來研究如何組合 <code>pub</code> 和 <code>use</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過-use-關鍵字引入路徑"><a class="header" href="#透過-use-關鍵字引入路徑">透過 <code>use</code> 關鍵字引入路徑</a></h2>
<p>要是每次都得寫出呼叫函式的路徑的話是很冗長、重複且不方便的。舉例來說範例 7-7 我們在考慮要使用絕對或相對路徑來呼叫 <code>add_to_waitlist</code> 函式時，每次想要呼叫 <code>add_to_waitlist</code> 我們都得指明 <code>front_of_house</code> 以及 <code>hosting</code>。幸運的是，我們有簡化過程的辦法：我們可以用 <code>use</code> 關鍵字建立路徑的捷徑，然後在作用域內透過更短的名稱來使用。</p>
<p>在範例 7-11 中，我們引入了 <code>crate::front_of_house::hosting</code> 模組進 <code>eat_at_restaurant</code> 函式的作用域中，所以我們要呼叫函式 <code>add_to_waitlist</code> 的話我們只需要指明 <code>hosting::add_to_waitlist</code>。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-11：使用 <code>use</code> 將模組引入</span></p>
<p>使用 <code>use</code> 將路徑引入作用域就像是在檔案系統中產生符號連結一樣（symbolic link）。在 crate 源頭加上 <code>use crate::front_of_house::hosting</code> 後，<code>hosting</code> 在作用域內就是個有效的名稱了。使用 <code>use</code> 的路徑也會檢查隱私權，就像其他路徑一樣。</p>
<p>注意到 <code>use</code> 只會在它所位在的特定作用域內建立捷徑。範例 7-12 將 <code>eat_at_restaurant</code> 移入子模組 <code>customer</code>，這樣就會與 <code>use</code> 陳述式的作用域不同，所以其函式本體將無法編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness does_not_compile ignore">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
<p><span class="caption">範例 7-12：<code>use</code> 陳述式只適用於所在的作用域</span></p>
<p>編譯器錯誤顯示了該捷徑無法用在 <code>customer</code> 模組內：</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0433]: failed to resolve: use of undeclared crate or module `hosting`
  --&gt; src/lib.rs:11:9
   |
11 |         hosting::add_to_waitlist();
   |         ^^^^^^^ use of undeclared crate or module `hosting`

warning: unused import: `crate::front_of_house::hosting`
 --&gt; src/lib.rs:7:5
  |
7 | use crate::front_of_house::hosting;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

For more information about this error, try `rustc --explain E0433`.
warning: `restaurant` (lib) generated 1 warning
error: could not compile `restaurant` due to previous error; 1 warning emitted
</code></pre>
<p>你會發現還有另外一個警告說明 <code>use</code> 在它的作用域中並沒有被用到！要解決此問題的話，我們可以將 <code>use</code> 也移動到 <code>customer</code> 模組內，或是在<code>customer</code> 子模組透過 <code>super::hosting</code> 參考上層模組的捷徑。</p>
<h3 id="建立慣用的-use-路徑"><a class="header" href="#建立慣用的-use-路徑">建立慣用的 <code>use</code> 路徑</a></h3>
<p>在範例 7-11 你可能會好奇為何我們指明 <code>use crate::front_of_house::hosting</code> 然後在 <code>eat_at_restaurant</code> 呼叫，而不是直接用 <code>use</code> 指明 <code>add_to_waitlist</code> 函式的整個路徑就好。像範例 7-13 這樣寫。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-13：使用 <code>use</code> 將 <code>add_to_waitlist</code> 函式引入作用域，但這較不符合習慣</span></p>
<p>雖然範例 7-11 與範例 7-13 都能完成相同的任務，但是範例 7-11 使用 <code>use</code> 將函式引入作用域的方法比較符合習慣用法。使用 <code>use</code> 將函式的上層模組引入作用域，讓我們必須在呼叫函式時得指明對應模組。在呼叫函式時指定上層模組能清楚地知道該函式並非本地定義的，同時一樣能簡化路徑。範例 7-13 的程式碼會不清楚 <code>add_to_waitlist</code> 是在哪定義的。</p>
<p>另一方面，如果是要使用 <code>use</code> 引入結構體、枚舉或其他項目的話，直接指明完整路徑反而是符合習慣的方式。範例 7-14 顯示了將標準函式庫的 <code>HashMap</code> 引入執行檔 crate 作用域的習慣用法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">範例 7-14：引入 <code>HashMap</code> 進作用域的習慣用法</span></p>
<p>此習慣沒什麼強硬的理由：就只是大家已經習慣這樣的用法來讀寫 Rust 的程式碼。</p>
<p>這樣的習慣有個例外，那就是如果我們將兩個相同名稱的項目使用 <code>use</code> 陳述式引入作用域時，因為 Rust 不會允許。範例 7-15 展示了如何引入兩個同名但屬於不同模組的 <code>Result</code> 型別進作用域中並使用的方法。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --省略--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --省略--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">範例 7-15：要將兩個同名的型別引入相同作用域的話，必須使用它們所屬的模組</span></p>
<p>如同你所見使用對應的模組可以分辨出是在使用哪個 <code>Result</code> 型別。如果我們直接指明 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code> 的話，我們會在同一個作用域中擁有兩個 <code>Result</code> 型別，這樣一來 Rust 就無法知道我們想用的 <code>Result</code> 是哪一個。</p>
<h3 id="使用-as-關鍵字提供新名稱"><a class="header" href="#使用-as-關鍵字提供新名稱">使用 <code>as</code> 關鍵字提供新名稱</a></h3>
<p>要在相同作用域中使用 <code>use</code> 引入兩個同名型別的話，還有另一個辦法。在路徑之後，我們可以用 <code>as</code> 指定一個該型別在本地的新名稱，或者說<strong>別名</strong>（alias）。範例 7-16 展示重寫了範例 7-15，將其中一個 <code>Result</code> 型別使用 <code>as</code> 重新命名。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --省略--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --省略--
<span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">範例 7-16：使用 <code>as</code> 將型別引入作用域的同時重新命名</span></p>
<p>在第二個 <code>use</code> 陳述式，我們選擇了將 <code>std::io::Result</code> 型別重新命名為 <code>IoResult</code>，這樣就不會和同樣引入作用域內 <code>std::fmt</code> 的 <code>Result</code> 有所衝突。範例 7-15 與 範例 7-16 都屬於習慣用法，你可以選擇你比較喜歡的方式！</p>
<h3 id="使用-pub-use-重新匯出名稱"><a class="header" href="#使用-pub-use-重新匯出名稱">使用 <code>pub use</code> 重新匯出名稱</a></h3>
<p>當我們使用 <code>use</code> 關鍵字將名稱引入作用域時，該有效名稱在新的作用域中是私有的。要是我們希望呼叫我們這段程式碼時，也可以使用這個名稱的話（就像該名稱是在此作用域內定義的），我們可以組合 <code>pub</code> 和 <code>use</code>。這樣的技巧稱之為<strong>重新匯出（re-exporting）</strong>，因為我們將項目引入作用域，並同時公開給其他作用域參考。</p>
<p>範例 7-17 將範例 7-11 在源頭模組中原本的 <code>use</code> 改成 <code>pub use</code>。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-17：使用 <code>pub use</code> 使名稱公開給任何程式的作用域中參考</span></p>
<p>在此之前，外部程式碼會需要透過 <code>restaurant::front_of_house::hosting::add_to_waitlist()</code> 這樣的路徑才能呼叫 <code>add_to_waitlist</code>。現在 <code>pub use</code> 從源頭模組重新匯出了 <code>hosting</code> 模組，外部程式碼現在可以使用 <code>restaurant::hosting::add_to_waitlist()</code> 這樣的路徑就好。</p>
<p>當程式碼的內部結構與使用程式的開發者對於該領域所想像的結構不同時，重新匯出會很有用。我們再次用餐廳做比喻的話就像是，經營餐廳的人可能會想像餐廳是由「前台」與「後台」所組成，但光顧的顧客可能不會用這些術語來描繪餐廳的每個部分。使用 <code>pub use</code> 的話，我們可以用某種架構寫出程式碼，再以不同的架構對外公開。這樣讓我們的的函式庫可以完整的組織起來，且對開發函式庫的開發者與使用函式庫的開發者都提供友善的架構。我們會在第十四章的<a href="ch14-02-publishing-to-crates-io.html#%E9%80%8F%E9%81%8E-pub-use-%E5%8C%AF%E5%87%BA%E7%90%86%E6%83%B3%E7%9A%84%E5%85%AC%E9%96%8B-api">「透過 <code>pub use</code> 匯出理想的公開 API」</a><!-- ignore -->段落再看看另一個 <code>pub use</code> 的範例並了解它會如何影響 crate 的技術文件。</p>
<h3 id="使用外部套件"><a class="header" href="#使用外部套件">使用外部套件</a></h3>
<p>在第二章我們寫了一支猜謎遊戲專案時，有用到一個外部套件叫做 <code>rand</code> 來取得隨機數字。要在專案內使用 <code>rand</code> 的話，我們會在 <em>Cargo.toml</em> 加上此行：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.5&quot;
</code></pre>
<p>在 <em>Cargo.toml</em> 新增  <code>rand</code> 作為依賴函式庫會告訴 Cargo 要從 <a href="https://crates.io/">crates.io</a> 下載  <code>rand</code> 以及其他相關的依賴，讓我們的專案可以使用 <code>rand</code>。</p>
<p>接下來要將 <code>rand</code> 的定義引入我們套件的作用域的話，我們加上一行 <code>use</code> 後面接著 crate 的名稱 <code>rand</code> 然後列出我們想要引入作用域的項目。回想一下在第二章<a href="ch02-00-guessing-game-tutorial.html#%E7%94%A2%E7%94%9F%E9%9A%A8%E6%A9%9F%E6%95%B8%E5%AD%97">「產生隨機數字」</a><!-- ignore -->的段落，我們將 <code>Rng</code> 特徵引入作用域中，並呼叫函式 <code>rand::thread_rng</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..=100);
<span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span>}
</code></pre>
<p>Rust 社群成員在 <a href="https://crates.io/">crates.io</a> 發佈了不少套件可供使用，要將這些套件引入到你的套件的步驟是一樣的。在你的套件的 <em>Cargo.toml</em> 檔案列出它們，然後使用 <code>use</code> 將這些 crate 內的項目引入作用域中。</p>
<p>請注意到標準函式庫 <code>std</code> 對於我們的套件來說也是一個外部 crate。由於標準函式庫會跟著 Rust 語言發佈，所以我們不需要更改 <em>Cargo.toml</em> 來包含 <code>std</code>。但是我們仍然需使用 <code>use</code> 來將它的項目引入我們套件的作用域中。舉例來說，要使用 <code>HashMap</code> 我們可以這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>這是個用標準函式庫的 crate 名稱 <code>std</code> 起頭的絕對路徑。</p>
<h3 id="使用巢狀路徑來清理大量的-use-行數"><a class="header" href="#使用巢狀路徑來清理大量的-use-行數">使用巢狀路徑來清理大量的 <code>use</code> 行數</a></h3>
<p>如果我們要使用在相同 crate 或是相同模組內定義的數個項目，針對每個項目都單獨寫一行的話，會佔據我們檔案內很多空間。舉例來說，範例 2-4 中的猜謎遊戲我們用了這兩個 <code>use</code> 陳述式來引入作用域中：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --省略--
use std::cmp::Ordering;
use std::io;
// --省略--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取行數失敗&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;太小了！&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;獲勝！&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>我們可以改使用巢狀路徑（nested paths）來只用一行就能將數個項目引入作用域中。我們先指明相同路徑的部分，加上雙冒號，然後在大括號內列出各自不同的路徑部分，如範例 7-18 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --省略--
use std::{cmp::Ordering, io};
// --省略--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;讀取行數失敗&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;請輸入一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;太小了！&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;獲勝！&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 7-18：使用巢狀路徑引入有部分相同前綴的數個路徑至作用域中</span></p>
<p>在較大的程式中，使用巢狀路徑將相同 crate 或相同模組中的許多項目引入作用域，可以大量減少 <code>use</code> 陳述式的數量！</p>
<p>我們可以在路徑中的任何部分使用巢狀路徑，這在組合兩個享有相同子路徑的 <code>use</code> 陳述式時非常有用。舉例來說，範例 7-19 顯示了兩個 <code>use</code> 陳述式：一個將 <code>std::io</code> 引入作用域，另一個將 <code>std::io::Write</code> 引入作用域。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io;
use std::io::Write;
</code></pre>
<p><span class="caption">範例 7-19：兩個 <code>use</code> 陳述式且其中一個是另一個的子路徑</span></p>
<p>這兩個路徑的相同部分是 <code>std::io</code>，這也是整個第一個路徑。要將這兩個路徑合為一個 <code>use</code> 陳述式的話，我們可以在巢狀路徑使用 <code>self</code>，如範例 7-20 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::io::{self, Write};
</code></pre>
<p><span class="caption">範例 7-20：組合範例 7-19 的路徑為一個 <code>use</code> 陳述式</span></p>
<p>此行就會將 <code>std::io</code> 和 <code>std::io::Write</code> 引入作用域。</p>
<h3 id="全域運算子"><a class="header" href="#全域運算子">全域運算子</a></h3>
<p>如果我們想要將在一個路徑中所定義的<strong>所有</strong>公開項目引入作用域的話，我們可以在指明路徑之後加上全域（glob）運算子 <code>*</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>此 <code>use</code> 陳述式會將 <code>std::collections</code> 定義的所有公開項目都引入作用域中。不過請小心使用全域運算子！它容易讓我們無法分辨作用域內的名稱，以及程式中使用的名稱是從哪定義來的。</p>
<p>全域運算子很常用在 <code>tests</code> 模組下，將所有東西引入測試中。我們會在第十一章的<a href="ch11-01-writing-tests.html#how-to-write-tests">「如何寫測試」</a><!-- ignore -->段落來討論。全域運算子也常拿來用在 prelude 模式中，你可以查閱<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">標準函式庫的技術文件</a><!-- ignore -->來瞭解此模式的更多資訊。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="將模組拆成不同檔案"><a class="header" href="#將模組拆成不同檔案">將模組拆成不同檔案</a></h2>
<p>本章節目前所有的範例將數個模組定義在同一個檔案中。當模組增長時，你可能會想要將它們的定義拆開到別的檔案中，好讓程式碼容易瀏覽。</p>
<p>舉例來說，讓我們從範例 7-17 餐廳的多重模組開始。我們會將模組拆成數個檔案，而不只是將所有模組都放在 crate 源頭檔案。在此例中，源頭檔案為 <em>src/lib.rs</em> 不過這步驟在執行檔 crate 的 <em>src/main.rs</em> 一樣可行。</p>
<p>首先，我們將 <code>front_of_house</code> 模組移到獨立的檔案中。刪掉 <code>front_of_house</code> 模組大括號內的程式碼，只留下宣告 <code>mod front_of_house;</code>，讓 <em>src/lib.rs</em> 包含的程式碼如範例 7-21 所示。請注意在我們加上範例 7-22 的 <em>src/front_of_house.rs</em> 檔案前這會仍無法編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-21：宣告 <code>front_of_house</code> 模組，其本體位於 <em>src/front_of_house.rs</em></span></p>
<p>接著，將原本大括號內的程式碼寫到新的檔案 <em>src/front_of_house.rs</em> 中，如範例 7-22 所示。編譯器知道要查看這個檔案，因為 crate 源頭有宣告這個模組的名稱 <code>front_of_house</code>。</p>
<p><span class="filename">檔案名稱：src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">範例 7-22：<code>front_of_house</code> 模組的定義位於 <em>src/front_of_house.rs</em></span></p>
<p>你只需要在模組樹中使用 <code>mod</code> 宣告一次來讀取檔案就好。一旦編譯器知道該檔案屬於專案的一部分（且知道其位在模組樹中的何處，因為你有宣告 <code>mod</code> 陳述式），專案中的其他檔案就能用宣告的路徑讀取檔案的程式碼，如同<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">「參考模組項目的路徑」</a><!-- ignore -->段落提到的一樣。換句話說，<code>mod</code> 和你在其他程式語言可能會看到的「include」動作並<strong>不一樣</strong>。</p>
<p>要開始移動 <code>hosting</code> 的話，我們先改變 <em>src/front_of_house.rs</em>，讓它只包含 <code>hosting</code> 模組的宣告：</p>
<p><span class="filename">檔案名稱：src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>然後我們建立一個目錄 <em>src/front_of_house</em> 以及一個檔案 <em>src/front_of_house/hosting.rs</em> 來包含 <code>hosting</code> 模組的定義：</p>
<p><span class="filename">檔案名稱：src/front_of_house/hosting.rs</span></p>
<pre><code class="language-rust ignore">pub fn add_to_waitlist() {}
</code></pre>
<p>如果我們將 <em>hosting.rs</em> 放在 <em>src</em> 目錄下，編譯器會將 <em>hosting.rs</em> 的程式碼視為是宣告在 crate 源頭底下的 <code>hosting</code> 模組。編譯器決定哪些檔案屬於哪些模組的規則讓目錄與檔案架構能更貼近模組樹的架構。</p>
<blockquote>
<h3 id="其他種的檔案路徑"><a class="header" href="#其他種的檔案路徑">其他種的檔案路徑</a></h3>
<p>目前我們涵蓋了 Rust 編譯器使用的最佳檔案路徑形式，但 Rust 仍然支援舊版的檔案路徑。當 crate 源頭宣告了一個模組 <code>front_of_house</code> 時，編譯器會在以下幾處尋找模組的程式碼：</p>
<ul>
<li><em>src/front_of_house.rs</em>（我們介紹的）</li>
<li><em>src/front_of_house/mod.rs</em>（舊版風格，仍然支援的路徑形式）</li>
</ul>
<p>當有個 <code>front_of_house</code> 的子模組 <code>hosting</code> 宣告時，編譯器會在以下幾處尋找模組的程式碼：</p>
<ul>
<li><em>src/front_of_house/hosting.rs</em>（我們介紹的）</li>
<li><em>src/front_of_house/hosting/mod.rs</em>（舊版風格，仍然支援的路徑形式）</li>
</ul>
<p>如果你對同個模組同時使用兩種風格的話，你會收到編譯器錯誤。在同個專案對不同模組使用不同風格則是允許的，但這有可能會讓瀏覽專案的人感到困惑。</p>
<p>使用 <em>mod.rs</em> 檔案名稱的風格最主要的缺點是你的專案可能最後會有很多檔案都叫做 <em>mod.rs</em>，當你在編輯器同時開啟這些檔案時可能會被混淆。</p>
</blockquote>
<p>我們將模組的程式碼搬到了不同的檔案，而模組樹仍維持完好如初。就算函式定義被移動不同檔案，<code>eat_at_restaurant</code> 內的函式呼叫不用任何修改仍能維持運作。這樣的方式讓你可以隨著模組成長時，移動到新的檔案中。</p>
<p>另外 <em>src/lib.rs</em> 內的 <code>pub use crate::front_of_house::hosting</code> 陳述式沒有改變，在檔案作為 crate 的一部分來編譯時，使用 <code>use</code> 的方式也沒有改變。<code>mod</code> 關鍵字能宣告模組，然後 Rust 會去同名的檔案尋找該模組的程式碼。</p>
<h2 id="總結-6"><a class="header" href="#總結-6">總結</a></h2>
<p>Rust 讓你能夠將套件拆成數個 crate，然後 crate 能再分成數個模組，好讓你可以從一個模組內指定其他模組的項目。而你可以使用絕對或相對路徑來達成。這些路徑可以用 <code>use</code> 陳述式來引入作用域，讓你可以在該作用域用更短的路徑來多次呼叫該項目。模組程式碼預設為私有的，但你可以使用 <code>pub</code> 關鍵字公開它的定義內容。</p>
<p>在下個章節，我們將探討在標準函式庫中的一些資料結構集合，讓你可以利用它們寫出整潔有組織的程式碼。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常見集合"><a class="header" href="#常見集合">常見集合</a></h1>
<p>Rust 的標準函式庫提供一些非常實用的資料結構稱之為<strong>集合（collections）</strong>。多數其他資料型別只會呈現一個特定數值，但是集合可以包含數個數值。不像內建的陣列與元組型別，這些集合指向的資料位於堆積上，代表資料的數量不必在編譯期就知道，而且可以隨著程式執行增長或縮減。每種集合都有不同的能力以及消耗，依照你的情形選擇適當的集合，是一項你會隨著開發時間漸漸掌握的技能。在本章節我們會介紹三種在 Rust 程式中十分常用的集合：</p>
<ul>
<li><strong>向量</strong>（Vector）允許你接二連三地儲存數量不定的數值。</li>
<li><strong>字串</strong>（String）是字元的集合。我們在之前就提過 <code>String</code> 型別，本章會正式深入介紹。</li>
<li><strong>雜湊映射</strong>（Hash map）允許你將值（value）與特定的鍵（key）相關聯。這是從一種更通用的資料結構<strong>映射</strong>（map）衍生出來的特定實作。</li>
</ul>
<p>想瞭解更多標準函式庫提供的集合種類的話，歡迎查閱<a href="https://doc.rust-lang.org/std/collections/index.html">技術文件</a>。</p>
<p>我們將討論如何建立與更新向量、字串與雜湊映射，以及它們的所長。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過向量儲存列表"><a class="header" href="#透過向量儲存列表">透過向量儲存列表</a></h2>
<p>我們第一個要來看的集合是 <code>Vec&lt;T&gt;</code> 常稱為<strong>向量</strong>（vector）。向量允許你在一個資料結構儲存不止一個數值，而且該結構的記憶體會接連排列所有數值。它們很適合用來處理你手上的項目列表，像是一個檔案中每行的文字，或是購物車內每項物品。</p>
<h3 id="建立新的向量"><a class="header" href="#建立新的向量">建立新的向量</a></h3>
<p>要建立一個新的空向量的話，我們呼叫 <code>Vec::new</code> 函式，如範例 8-1 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-1 建立一個儲存數值型別為 <code>i32</code> 的空向量</span></p>
<p>注意到我們在此加了型別詮釋。因為我們沒有對此向量插入任何數值，Rust 不知道我們想儲存什麼類型的元素。這是一項重點，向量是用泛型（generics）實作，我們會在第十章說明如何為你自己的型別使用泛型。現在我們只需要知道標準函式庫提供的 <code>Vec&lt;T&gt;</code> 型別可以持有任意型別，然後當特定向量要持有特定型別時，我們可以在尖括號內指定該型別。在範例 8-1，我們告訴 Rust 在 <code>v</code> 中的 <code>Vec&lt;T&gt;</code> 會持有 <code>i32</code> 型別的元素。</p>
<p>不過通常你在建立 <code>Vec&lt;T&gt;</code> 時只需要給予初始數值，Rust 就能推導出你想儲存的數值型別，所以你不太常會需要指明型別詮釋。Rust 還提供了 <code>vec!</code> 巨集讓我們能方便地建立一個新的向量並取得你提供的數值。在範例 8-2 中，我們建立了一個新的 <code>Vec&lt;i32&gt;</code> 並擁有數值 <code>1</code>、<code>2</code> 和 <code>3</code>。整數型別為 <code>i32</code> 是因為這是預設整數型別，如同我們在第三章的<a href="ch03-02-data-types.html#data-types">「資料型別」</a><!-- ignore --> 段落提到的一樣。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-2：建立一個擁有數值的新向量</span></p>
<p>因為我們給予了初始的 <code>i32</code> 數值，Rust 可以推導出 <code>v</code> 的型別為 <code>Vec&lt;i32&gt;</code>，所以型別詮釋就不是必要的了。接下來，讓我們看看如何修改向量。</p>
<h3 id="更新向量"><a class="header" href="#更新向量">更新向量</a></h3>
<p>要在建立向量之後新增元素的話，我們可以使用 <code>push</code> 方法，如範例 8-3 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-3：使用 <code>push</code> 方法來新增數值到向量</span></p>
<p>與其他變數一樣，如果我們想要變更其數值的話，我們需要使用 <code>mut</code> 關鍵字使它成為可變的，如同第三章提到的一樣。我們插入的數值所屬型別均為 <code>i32</code>，然後 Rust 可以從資料推導，所以我們不必指明 <code>Vec&lt;i32&gt;</code>。</p>
<h3 id="讀取向量元素"><a class="header" href="#讀取向量元素">讀取向量元素</a></h3>
<p>要參考向量儲存的數值有兩種方式。為了更加清楚說明此範例，我們詮釋了函式回傳值的型別。</p>
<p>範例 8-4 顯示了取得向量中數值的方法，可以使用索引語法與 <code>get</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;第三個元素是 {third}&quot;);

    let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;第三個元素是 {third}&quot;),
        None =&gt; println!(&quot;第三個元素並不存在。&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-4：使用索引語法或 <code>get</code> 方法來取得向量項目</span></p>
<p>這邊我們要注意一些地方。我們使用了索引數值 <code>2</code> 來獲取第三個元素：向量可以用數字來索引，從零開始計算。使用 <code>&amp;</code> 和 <code>[]</code> 會給我們索引數值的元素參考，而使用 <code>get</code> 方法加上一個索引作為引數，則會給我們 <code>Option&lt;&amp;T&gt;</code>，我們可以用 <code>match</code> 來配對。</p>
<p>Rust 提供兩種取得元素參考方式，所以當你嘗試使用索引數值取得向量範圍外的元素時，你可以決定程式的行為。讓我們看看一個範例，我們有一個向量擁有五個元素，但我們嘗試用索引 100 來取得對應數值，如範例 8-5 所示。</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-5：嘗試對只有五個元素的向量取得索引 100 的值</span></p>
<p>當我們執行程式時，第一個 <code>[]</code> 方法會讓程式恐慌，因為它參考了不存在的元素。此方法適用於當你希望一有無效索引時就讓程式崩潰的狀況。</p>
<p>當你使用 <code>get</code> 方法來索取向量不存在的索引時，它會回傳 <code>None</code> 而不會恐慌。如果正常情況下偶而會不小心存取超出向量範圍索引的話，你就會想要只用此方法。你的程式碼就會有個邏輯專門處理 <code>Some(&amp;element)</code> 或 <code>None</code>，如同第六章所述。舉例來說，可能會有由使用者輸入的索引。如果他不小心輸入太大的數字的話，程式可以回傳 <code>None</code>，你可以告訴使用者目前向量有多少項目，並讓他們可以再輸入一次。這會比直接讓程式崩潰還來的友善，他們可能只是不小心打錯而已！</p>
<p>當程式有個有效參考時，借用檢查器（borrow checker）會貫徹所有權以及借用規則（如第四章所述）來確保此參考及其他對向量內容的參考都是有效的。回想一下有個規則是我們不能在同個作用域同時擁有可變與不可變參考。這個規則一樣適用於範例 8-6，在此我們有一個向量第一個元素的不可變參考，然後我們嘗試在向量後方新增元素。如果我們嘗試在此動作後繼續使用第一個參考的話，程式會無法執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;第一個元素是：{first}&quot;);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 8-6：在持有一個項目的參考時，還嘗試對向量新增元素</span></p>
<p>編譯此程式會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;第一個元素為 {first}&quot;);
  |                           ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</code></pre>
<p>範例 8-6 的程式碼看起來好像能執行。為何第一個元素的參考要在意向量的最後端發生了什麼事呢？此錯誤其實跟向量運作的方式有關：由於向量會將元素放在前一位的記憶體位置後方，在向量後方新增元素時，如果當前向量的空間不夠再塞入另一個值的話，可能會需要分配新的記憶體並複製舊的元素到新的空間中。這樣一來，第一個元素的索引可能就會指向已經被釋放的記憶體，借用規則會防止程式遇到這樣的情形。</p>
<blockquote>
<p>注意：關於 <code>Vec&lt;T&gt;</code> 型別更多的實作細節，歡迎查閱<a href="https://doc.rust-lang.org/nomicon/vec/vec.html">「The Rustonomicon」</a>。</p>
</blockquote>
<h3 id="遍歷向量的元素"><a class="header" href="#遍歷向量的元素">遍歷向量的元素</a></h3>
<p>想要依序存取向量中每個元素的話，我們可以遍歷所有元素而不必用索引一個一個取得。範例 8-7 闡釋了如何使用 <code>for</code> 迴圈來取得一個 <code>i32</code> 向量中每個元素的不可變參考並印出他們。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{i}&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-7：使用 <code>for</code> 迴圈遍歷向量中每個元素</span></p>
<p>我們還可以遍歷可變向量中的每個元素取得可變參考來改變每個元素。像是範例 8-8 就使用 <code>for</code> 迴圈來為每個元素加上 <code>50</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-8：遍歷向量中的元素取得可變參考</span></p>
<p>要改變可變參考指向的數值，在使用 <code>+=</code> 運算子之前，我們需要使用 <code>*</code> 解參考運算子來取得 <code>i</code> 的數值。我們會在第十五章的<a href="ch15-02-deref.html#%E8%BF%BD%E8%B9%A4%E6%8C%87%E6%A8%99%E7%9A%84%E6%95%B8%E5%80%BC">「追蹤指標的數值」</a><!-- ignore -->段落來講解更多解參考運算子的細節。</p>
<p>當遍歷向量時，無論是不可變或可變地都是安全，因為借用檢查器的規則能確保如此。如果我們嘗試在範例 8-7 或範例 8-8 的 <code>for</code> 迴圈本體插入或刪除項目，我們就會獲得和範例 8-6 程式碼類似的編譯錯誤。<code>for</code> 迴圈持有的向量參考能避免同時修改整個向量。</p>
<h3 id="使用枚舉來儲存多種型別"><a class="header" href="#使用枚舉來儲存多種型別">使用枚舉來儲存多種型別</a></h3>
<p>向量只能儲存同型別的數值，這在某些情況會很不方便，一定會有場合是要儲存不同型別到一個列表中。幸運的是，枚舉的變體是定義在相同的枚舉型別，所以當我們需要在向量儲存不同型別的元素時，我們可以用枚舉來定義！</p>
<p>舉例來說，假設我們想從表格中的一行取得數值，但是有些行內的列會包含整數、浮點數以及一些字串。我們可以定義一個枚舉，其變體會持有不同的數值型別，然後所有的枚舉變體都會被視為相同型別：就是它們的枚舉。接著我們就可以建立一個擁有此枚舉型別的向量，最終達成持有不同型別。如範例 8-9 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;藍色&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-9：用 <code>enum</code> 定義儲存不同型別的枚舉並作為向量的型別</span></p>
<p>Rust 需要在編譯時期知道向量的型別以及要在堆積上用到多少記憶體才能儲存每個元素。我們必須明確知道哪些型別可以放入向量中。如果 Rust 允許向量一次持有任意型別的話，在對向量中每個元素進行處理時，可能就會有一或多種型別會產生錯誤。使用枚舉和 <code>match</code> 表達式讓 Rust 可以在編譯期間確保每個可能的情形都已經處理完善了，如同第六章提到的一樣。</p>
<p>如果你無法確切知道執行時程式所處理的所有型別的話，枚舉就不管用了。這時使用特徵物件會比較好，我們會在第十七章再來解釋。</p>
<p>現在我們已經講了一些向量常見的用法，有時間的話記得到<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">向量的 API 技術文件</a><!-- ignore -->瞭解標準函式庫中 <code>Vec&lt;T&gt;</code> 所有實用的方法。舉例來說，除了 <code>push</code> 方法以外，還有個 <code>pop</code> 方法可以移除並回傳最後一個元素。</p>
<h3 id="釋放向量的同時也會釋放其元素"><a class="header" href="#釋放向量的同時也會釋放其元素">釋放向量的同時也會釋放其元素</a></h3>
<p>就像其它 <code>struct</code> 一樣，向量會在作用域結束時被釋放，如範例 8-10 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // 使用 v 做些事情
    } // &lt;- v 在此離開作用域並釋放
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-10：顯示向量及其元素在哪裡被釋放</span></p>
<p>當向量被釋放時，其所有內容也都會被釋放，代表它持有的那些整數都會被清除。這雖然聽起來很直觀，但是當我們開始參考向量中的元素時可能就會變得有點複雜。讓我們看看怎麼處理這種情形吧！</p>
<p>接下來讓我們看看下一個集合型別：<code>String</code>！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過字串儲存-utf-8-編碼的文字"><a class="header" href="#透過字串儲存-utf-8-編碼的文字">透過字串儲存 UTF-8 編碼的文字</a></h2>
<p>我們已經在第四章提到字串（String），但現在我們要更加深入探討。Rustaceans 初學者常常會卡在三個環節：Rust 傾向於回報可能的錯誤、字串的資料結構比開發者所熟悉的還要複雜，以及 UTF-8。這些要素讓來自其他程式語言背景的開發者會遇到一些困難。</p>
<p>我們會在集合章節討論字串的原因是，字串本身就是位元組的集合，且位元組作為文字呈現時，它會提供一些實用的方法。在此段落我們將和其他集合型別一樣討論 <code>String</code> 的操作，像是建立、更新與讀取。我們還會討論到 <code>String</code> 與其他集合不一樣的地方，像是 <code>String</code> 的索引就比其他集合還複雜，因為它會依據人們對於 <code>String</code> 資料型別的理解而有所不同。</p>
<h3 id="什麼是字串"><a class="header" href="#什麼是字串">什麼是字串？</a></h3>
<p>首先我們要好好定義<strong>字串（String）<strong>這個術語。Rust 在核心語言中只有一個字串型別，那就是字串切片 <code>str</code>，它通常是以借用的形式存在 <code>&amp;str</code>。在第四章中我們提到</strong>字串切片</strong>是一個針對存在某處的  UTF-8 編碼資料的參考。舉例來說，字串字面值（String literals）就儲存在程式的執行檔中，因此就是字串切片。</p>
<p><code>String</code> 型別是 Rust 標準函式庫所提供的型別，並不是核心語言內建的型別，它是可增長的、可變的、可擁有所有權的 UTF-8 編碼字串型別。當 Rustaceans 提及 Rust 中的「字串」時，他們通常指的是 <code>String</code> 以及字串切片 <code>&amp;str</code> 型別，而不只是其中一種型別。雖然此段落大部分都在討論 <code>String</code>，這兩個型別都時常用在 Rust 的標準函式庫中，且 <code>String</code> 與字串切片都是 UTF-8 編碼的。</p>
<h3 id="建立新的字串"><a class="header" href="#建立新的字串">建立新的字串</a></h3>
<p>許多 <code>Vec&lt;T&gt;</code> 可使用的方法在 <code>String</code> 也都能用，因為 <code>String</code> 其實就是一種位元組向量的封裝再加上一些額外的保障、限制與能力。其中一個 <code>Vec&lt;T&gt;</code> 與 <code>String</code> 都有且用途相同的函式就是 <code>new</code>，這用來產生新的實例，如範例 8-11 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-11：建立新的空 <code>String</code></span></p>
<p>此行會建立新的字串叫做 <code>s</code>，我們之後可以再寫入資料。不過通常我們會希望建立字串的同時能夠初始化資料。為此我們可以使用 <code>to_string</code> 方法，任何有實作 <code>Display</code> 特徵的型別都可以使用此方法，就像字串字面值的使用方式一樣。範例 8-12 就展示了兩種例子。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;初始內容&quot;;

    let s = data.to_string();

    // 此方法也能直接用於字面值上
    let s = &quot;初始內容&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-12：從字串字面值使用 <code>to_string</code> 方法來建立 <code>String</code></span></p>
<p>此程式碼建立了一個字串內容為 <code>初始內容</code>。</p>
<p>我們也可以用函式 <code>String::from</code> 從字串字面值建立 <code>String</code>。範例 8-13 的程式碼和使用 <code>to_string</code> 的範例 8-12 效果一樣。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;初始內容&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-13：使用函式 <code>String::from</code> 從字串字面值建立 <code>String</code></span></p>
<p>因為字串用在許多地方，我們可以使用許多不同的通用字串 API 供我們選擇。有些看起來似乎是多餘的，但是它們都有一席之地的！在上面的範例中 <code>String::from</code> 和 <code>to_string</code> 都在做相同的事，所以你的選擇跟喜好風格與閱讀性比較有關。</p>
<p>另外記得字串是 UTF-8 編碼的，所以我們可以包含任何正確編碼的資料，如範例 8-14 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שָׁלוֹם&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-14：用字串儲存各種語言打招呼的文字</span></p>
<p>以上全是合理的 <code>String</code> 數值。</p>
<h3 id="更新字串"><a class="header" href="#更新字串">更新字串</a></h3>
<p>就和 <code>Vec&lt;T&gt;</code> 一樣，如果你插入更多資料的話，<code>String</code> 可以增長大小並變更其內容。除此之外你也可以使用 <code>+</code> 運算子或 <code>format!</code> 巨集來串接 <code>String</code> 數值。</p>
<h4 id="使用-push_str-和-push-追加字串"><a class="header" href="#使用-push_str-和-push-追加字串">使用 <code>push_str</code> 和 <code>push</code> 追加字串</a></h4>
<p>我們可以使用 <code>push_str</code> 方法來追加一個字串切片使字串增長，如範例 8-15 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 追加字串切片</span></p>
<p>在這兩行之後，<code>s</code> 會包含 <code>foobar</code>。<code>push_str</code> 方法取得的是字串切片因為我們並不需要取得參數的所有權。舉例來說，在範例 8-16 我們想在 <code>s2</code> 追加其內容給 <code>s1</code> 之後仍能使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {s2}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-16：在內容追加給 <code>String</code> 後繼續使用字串切片</span></p>
<p>如果 <code>push_str</code> 方法會取得 <code>s2</code> 的所有權，我們就無法在最後一行印出其數值了。幸好這段程式碼是可以執行的！</p>
<p>而 <code>push</code> 方法會取得一個字元作為參數並加到 <code>String</code> 上。範例 8-17 顯示了一個使用 <code>push</code> 方法將字母 &quot;l&quot; 加到 <code>String</code> 的程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-17：使用 <code>push</code> 將一個字元加到 <code>String</code></span></p>
<p>結果就是 <code>s</code> 會包含 <code>lol</code>。</p>
<h4 id="使用--運算子或-format-巨集串接字串"><a class="header" href="#使用--運算子或-format-巨集串接字串">使用 <code>+</code> 運算子或 <code>format!</code> 巨集串接字串</a></h4>
<p>你通常會想要組合兩個字串在一起，其中一種方式是用 <code>+</code> 運算子。如範例 8-18 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // 注意到 s1 被移動因此無法再被使用
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-18：使用 <code>+</code> 運算子組合兩個 <code>String</code> 數值成一個新的 <code>String</code> 數值</span></p>
<p>程式碼最後的字串 <code>s3</code> 就會獲得 <code>Hello, world!</code>。<code>s1</code> 之所以在相加後不再有效，以及 <code>s2</code> 是使用參考的原因，都和我們使用 <code>+</code> 運算子時呼叫的方法簽名有關。<code>+</code> 運算子使用的是 <code>add</code> 方法，其簽名會長得像這樣：</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>在標準函式庫中 <code>add</code> 是用泛型（generics）與關聯型別（associated types）定義。我們在此使用實際型別代替的 <code>add</code> 簽名。我們會在第十章討論到泛型。此簽名給了一些我們需要瞭解 <code>+</code> 運算子的一些線索。</p>
<p>首先 <code>s2</code> 有 <code>&amp;</code> 代表我們是將第二個字串的<strong>參考</strong>與第一個字串相加，因為函式 <code>add</code> 中的參數 <code>s</code> 說明我們只能將 <code>&amp;str</code> 與 <code>String</code> 相加，我們無法將兩個 <code>String</code> 數值相加。但等等 <code>&amp;s2</code> 是 <code>&amp;String</code> 才對，並非 <code>add</code> 第二個參數所指定的 <code>&amp;str</code>。為何範例 8-18 可以編譯呢？</p>
<p>我們可以在 <code>add</code> 的呼叫中使用 <code>&amp;s2</code> 的原因是因為編譯器可以<strong>強制（coerce）</strong> <code>&amp;String</code> 引數轉換成 <code>&amp;str</code>。當我們我們呼叫 <code>add</code> 方法時，Rust <strong>強制解參考</strong>（deref coercion）讓 <code>&amp;s2</code> 變成 <code>&amp;s2[..]</code>。我們會在第十五章深入探討強制解參考。因為 <code>add</code> 不會取得 <code>s</code> 參數的所有權，<code>s2</code> 在此運算後仍然是個有效的 <code>String</code>。</p>
<p>再來，我們可以看到 <code>add</code> 的簽名會取得 <code>self</code> 的所有權，因為 <code>self</code> <strong>沒有</strong> <code>&amp;</code>。這代表範例 8-18 的 <code>s1</code> 會移動到 <code>add</code> 的呼叫內，在之後就不再有效。所以雖然 <code>let s3 = s1 + &amp;s2;</code> 看起來像是它拷貝了兩個字串的值並產生了一個新的，但此陳述式實際上是取得 <code>s1</code> 的所有權、追加一份 <code>s2</code> 的複製內容、然後回傳最終結果的所有權。換句話說，雖然它看起來像是產生了很多拷貝，但實際上並不是。此實作反而比較有效率。</p>
<p>如果我們需要串接數個字串的話，<code>+</code> 運算子的行為看起來就顯得有點笨重了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>此時 <code>s</code> 會是 <code>tic-tac-toe</code>。有這麼多的 <code>+</code> 和 <code>&quot;</code> 字元，我們很難看清楚發生什麼事。如果要完成更複雜的字串組合的話，我們可以改使用 <code>format!</code> 巨集：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{s1}-{s2}-{s3}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼一樣能設置 <code>s</code> 為 <code>tic-tac-toe</code>。<code>format!</code> 巨集運作的方式和 <code>println!</code> 類似，但不會將輸出結果顯示在螢幕上，它做的是回傳內容的 <code>String</code>。使用 <code>format!</code> 的程式碼版本看起來比較好讀懂，而且 <code>format!</code> 產生的程式碼使用的是參考，所以此呼叫不會取走任何參數的所有權。</p>
<h3 id="索引字串"><a class="header" href="#索引字串">索引字串</a></h3>
<p>在其他許多程式語言中，使用索引參考字串來取得獨立字元是有效且常見的操作。然而在 Rust 中如果你嘗試對 <code>String</code> 使用索引語法的話，你會得到錯誤。請看看範例 8-19 這段無效的程式碼。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 8-19：嘗試在字串使用索引語法</span></p>
<p>此程式會有以下錯誤結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
  = help: the following other types implement trait `Index&lt;Idx&gt;`:
            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeFull&gt;&gt;
            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;
            &lt;str as Index&lt;I&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</code></pre>
<p>錯誤訊息與提示告訴了我們 Rust 字串並不支援索引。但為何不支援呢？要回答此問題，我們需要先討論 Rust 如何儲存字串進記憶體的。</p>
<h4 id="內部呈現"><a class="header" href="#內部呈現">內部呈現</a></h4>
<p><code>String</code> 基本上就是 <code>Vec&lt;u8&gt;</code> 的封裝。讓我們看看範例 8-14 中一些正確編碼為 UTF-8 字串的例子，像是這一個：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>在此例中 <code>len</code> 會是 4，也就是向量儲存的字串「Hola」長度為 4 個位元組。每個字母在用 UTF-8 編碼時長度均為 1 個位元組。但接下來這行可能就會讓你感到驚訝了（請注意字串的開頭是西里爾字母 Ze 的大寫，而不是阿拉伯數字 3）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span>    let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>你可能會以為這字串的長度為 12，事實上 Rust 給的答案卻是 24。這是將「Здравствуйте」用 UTF-8 編碼後的位元組長度，因為該字串的每個 Unicode 純量都佔據兩個位元組。因此字串位元組的索引不會永遠都能對應到有效的 Unicode 純量數值。我們用以下無效的 Rust 程式碼進一步說明：</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>你已經知道第一個字母 <code>answer</code> 不會是 <code>З</code>。當經過 UTF-8 編碼時，<code>З</code> 的第一個位元組會是 <code>208</code> 然後第二個是 <code>151</code>。所以 <code>answer</code> 實際上會拿到 <code>208</code>，但 <code>208</code> 本身又不是個有效字元。回傳 <code>208</code> 可能不會是使用者想要的，他們希望的應該是此字串的第一個字母，但這是 Rust 在位元組索引 0 唯一能回傳的資料。就算字串都只包含拉丁字母，使用者通常也不會希望看到位元組數值作為回傳值。如果 <code>&amp;&quot;hello&quot;[0]</code> 是有效程式碼且會回傳位元組數值的話，它會回傳的是 <code>104</code> 並非 <code>h</code>。</p>
<p>為了預防回傳意外數值進而導致無法立刻察覺的錯誤，Rust 不會成功編譯這段程式碼，並在開發過程前期就杜絕誤會發生。</p>
<h4 id="位元組純量數值與形素群集我的天啊"><a class="header" href="#位元組純量數值與形素群集我的天啊">位元組、純量數值與形素群集！我的天啊！</a></h4>
<p>UTF-8 還有一個重點是在 Rust 中我們實際上可以有三種觀點來理解字串：位元組、純量數值（scalar values）以及形素群集（grapheme clusters，最接近人們常說的「<strong>字母</strong>」）。</p>
<p>如果我們觀察用天成體寫的印度語「नमस्ते」，它存在向量中的 <code>u8</code> 數值就會長這樣：</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>這 18 個位元組是電腦最終儲存的資料？如果我們用 Unicode 純量數值觀察的話，也就是 Rust 的 <code>char</code> 型別，這些位元組會組成像這樣：</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>這邊有六個 <code>char</code> 數值，但第四個和第六個卻不是字母，它們是單獨存在不具任何意義的變音符號。最後如果我們以形素群集的角度來看的話，我們就會得到一般人所說的構成此印度語的四個字母：</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust 提供多種不同的方式來解釋電腦中儲存的原始字串資料，讓每個程式無論是何種人類語言的資料，都可以選擇它們需要的呈現方式。</p>
<p>Rust 還有一個不允許索引 <code>String</code> 來取得字元的原因是因為，索引運算必須永遠預期是花費常數時間（O(1)）。但在 <code>String</code> 上無法提供這樣的效能保證，因為 Rust 會需要從索引的開頭遍歷每個內容才能決定多少有效字元存在。</p>
<h3 id="字串切片-1"><a class="header" href="#字串切片-1">字串切片</a></h3>
<p>索引字串通常不是個好點子，因為字串索引要回傳的型別是不明確的，是要一個位元組數值、一個字元、一個形素群集還是一個字串切片呢。因此如果你真的想要使用索引建立字串切片的話，Rust 會要你更明確些。要明確指定你的索引與你想要的字串切片。</p>
<p>與其在 <code>[]</code> 只使用一個數字來索引，你可以在 <code>[]</code> 指定一個範圍來建立包含特定位元組的字串切片：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p><code>s</code> 在此會是 <code>&amp;str</code> 並包含字串前 4 個位元組。稍早我們提過這些字元各佔 2 個位元組，所以這裡的 <code>s</code> 就是 <code>Зд</code>。</p>
<p>如果我們嘗試只用 <code>&amp;hello[0..1]</code> 來取得字元部分的位元組的話，Rust 會和在向量中取得無效索引一樣在執行時恐慌：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>你在使用範圍來建立字串切片時要格外小心，因為這樣做有可能會使你的程式崩潰。</p>
<h3 id="遍歷字串的方法"><a class="header" href="#遍歷字串的方法">遍歷字串的方法</a></h3>
<p>要對字串的部分進行操作最好的方式是明確表達你想要的是字元還是位元組。對獨立的 Unicode 純量型別來說的話，就是使用 <code>chars</code> 方法。對「Зд」呼叫 <code>chars</code> 會將兩個擁有 <code>char</code> 型別的數值拆開並回傳，這樣一來你就可以遍歷每個元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;Зд&quot;.chars() {
    println!(&quot;{c}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會顯示以下輸出：</p>
<pre><code class="language-text">З
д
</code></pre>
<p>而 <code>bytes</code> 方法會回傳每個原始位元組，可能會在某些場合適合你：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出此字串的四個位元組：</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>請確定你已經瞭解有效的 Unicode 純量數值可能不止佔 1 個位元組。</p>
<p>而要從天成體組成的字串取得形素群集的話就非常複雜了，所以標準函式庫並未提供這項功能。如果你需要的話，<a href="https://crates.io/">crates.io</a><!-- ignore --> 上會有提供這項功能的 crate。</p>
<h3 id="字串並不簡單"><a class="header" href="#字串並不簡單">字串並不簡單</a></h3>
<p>總結來說，字串是很複雜的。不同的程式語言會選擇不同的決定來呈現給程式設計師。Rust 選擇正確處理 <code>String</code> 的方式作為所有 Rust 程式的預設行為，這也代表開發者在處理 UTF-8 資料時需要多加考量。這樣的取捨的確對比其他程式語言來說，增加了不少字串的複雜程度，但是這能讓你在開發週期免於處理非 ASCII 字元相關的錯誤。</p>
<p>好消息是標準函式庫針對 <code>String</code> 與 <code>&amp;str</code> 型別提供了許多功能，來幫助正確處理這些複雜的情況。別忘了翻翻技術文件來學習這些實用的方法，像是 <code>contains</code> 能搜尋字串，而 <code>replace</code> 能替換部份字串成另一個字串。</p>
<p>讓我們接下去看一個較簡單地集合吧：雜湊映射（hash maps）！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過雜湊映射儲存鍵值配對"><a class="header" href="#透過雜湊映射儲存鍵值配對">透過雜湊映射儲存鍵值配對</a></h2>
<p>我們最後一個常見的集合是<strong>雜湊映射（hash map）</strong>，<code>HashMap&lt;K, V&gt;</code> 型別會儲存一個鍵（key）型別 <code>K</code> 對應到一個數值（value）型別 <code>V</code>。它透過<strong>雜湊函式</strong>（hashing function）來決定要將這些鍵與值放在記憶體何處。許多程式語言都有支援這種類型的資料結構，不過通常它們會提供不同的名稱，像是 hash、map、object、hash table、dictionary 或 associative array 等等。</p>
<p>雜湊映射適合用於當你不想像向量那樣用索引搜尋資料，而是透過一個可以為任意型別的鍵來搜尋的情況。舉例來說，在比賽中我們可以使用雜湊映射來儲存每隊的分數，每個鍵代表隊伍名稱，而每個值代表隊伍分數。給予一個隊伍名稱，你就能取得該隊伍分數。</p>
<p>我們會在此段落介紹雜湊映射的基本 API，但還有很多實用的函式定義在標準函式庫的 <code>HashMap&lt;K, V&gt;</code> 中，所以別忘了查閱標準函式庫的技術文件來瞭解更多資訊。</p>
<h3 id="建立新的雜湊映射"><a class="header" href="#建立新的雜湊映射">建立新的雜湊映射</a></h3>
<p>其中一種建立空的雜湊映射的方式是使用 <code>new</code> 並透過 <code>insert</code> 加入新元素。在範例 8-20 我們追蹤兩支隊伍的分數，分別為藍隊與黃隊。藍隊初始分數有 10 分，黃隊則有 50 分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;藍隊&quot;), 10);
    scores.insert(String::from(&quot;黃隊&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-20：建立新的雜湊映射並插入一些鍵值</span></p>
<p>注意到我們需要先使用 <code>use</code> 將標準函式庫的 <code>HashMap</code> 集合引入。在我們介紹的三個常見集合中，此集合是最少被用到的，所以它並沒有包含在 prelude 內讓我們能自動參考。雜湊映射也沒有像前者那麼多標準函式庫提供的支援，像是內建建構它們的巨集。</p>
<p>和向量一樣，雜湊映射會將它們的資料儲存在堆積上。此 <code>HashMap</code> 的鍵是 <code>String</code> 型別而值是 <code>i32</code> 型別。和向量一樣，雜湊函式宣告後就都得是同類的，所有的鍵都必須是同型別，且所有的值也都必須是同型別。</p>
<h3 id="取得雜湊映射的數值"><a class="header" href="#取得雜湊映射的數值">取得雜湊映射的數值</a></h3>
<p>我們可以透過 <code>get</code> 方法並提供鍵來取得其在雜湊映射對應的值，如範例 8-21 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;藍隊&quot;), 10);
    scores.insert(String::from(&quot;黃隊&quot;), 50);

    let team_name = String::from(&quot;藍隊&quot;);
    let score = scores.get(&amp;team_name).copied().unwrap_or(0);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-21：取得雜湊映射中藍隊的分數</span></p>
<p><code>score</code> 在此將會是對應藍隊的分數，而且結果會是 <code>Some(&amp;10)</code>。結果是使用 <code>Some</code> 的原因是因為 <code>get</code> 回傳的是 <code>Option&lt;&amp;V&gt;</code>。如果雜湊映射中該鍵沒有對應值的話，<code>get</code> 就會回傳 <code>None</code>。所以程式會需要透過我們在第六章談到的方式處理 <code>Option</code>。</p>
<p>我們也可以使用 <code>for</code> 迴圈用類似的方式來遍歷雜湊映射中每個鍵值配對：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;藍隊&quot;), 10);
    scores.insert(String::from(&quot;黃隊&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{key}: {value}&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式會以任意順序印出每個配對：</p>
<pre><code class="language-text">黃隊: 50
藍隊: 10
</code></pre>
<h3 id="雜湊映射與所有權"><a class="header" href="#雜湊映射與所有權">雜湊映射與所有權</a></h3>
<p>像是 <code>i32</code> 這種有實作 <code>Copy</code> 特徵的型別其數值可以被拷貝進雜湊映射之中。但對於像是 <code>String</code> 這種擁有所有權的數值則會被移動到雜湊映射，並成為該數值新的擁有者，如範例 8-22 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;藍隊&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name 和 field_value 在這之後就不能使用了，你可以試著使用它們並看看編譯器回傳什麼錯誤
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-22：展示當鍵值插入雜湊映射後就會擁有它們</span></p>
<p>我們之後就無法使用變數 <code>field_name</code> 和 <code>field_value</code>，因為它們的值已經透過呼叫 <code>insert</code> 被移入雜湊映射之中。</p>
<p>如果我們插入雜湊映射的數值是參考的話，該值就不會被移動到雜湊映射之中。不過該值的參考就必須一直有效，至少直到該雜湊映射離開作用域為止。我們會在第十章的<a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">「透過生命週期驗證參考」</a><!-- ignore -->段落討落更多細節。</p>
<h3 id="更新雜湊映射"><a class="header" href="#更新雜湊映射">更新雜湊映射</a></h3>
<p>雖然鍵值配對的數量可以增加，但每個鍵同一時間就只能有一個對應的值而已。（反之並不成立：比如藍隊黃隊可以同時都在 <code>scores</code> 雜湊映射內儲存 10 分）</p>
<p>當你想要改變雜湊映射的資料的話，你必須決定如何處理當一個鍵已經有一個值的情況。你可以不管舊的值，直接用新值取代。你也可以保留舊值、忽略新值，只有在該鍵<strong>尚未</strong>擁有對應數值時才賦值給它。或者你也可以將舊值與新值組合起來。讓我們看看分別怎麼處理吧！</p>
<h4 id="覆蓋數值"><a class="header" href="#覆蓋數值">覆蓋數值</a></h4>
<p>如果我們在雜湊映射插入一個鍵值配對，然後又在相同鍵插入不同的數值的話，該鍵相對應的數值就會被取代。如範例 8-23 雖然我們呼叫了兩次 <code>insert</code>，但是雜湊映射只會保留一個鍵值配對，因為我們向藍隊的鍵插入了兩次數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;藍隊&quot;), 10);
    scores.insert(String::from(&quot;藍隊&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-23：替換某個特定鍵對應的數值</span></p>
<p>此程式碼會印出 <code>{&quot;藍隊&quot;: 25}</code>，原本的數值 <code>10</code> 會被覆蓋。</p>
<h4 id="只在鍵不存在的情況下插入鍵值"><a class="header" href="#只在鍵不存在的情況下插入鍵值">只在鍵不存在的情況下插入鍵值</a></h4>
<p>通常檢查雜湊映射有沒有存在某個特定的鍵值是很常見的。我們接下來的動作通常就是檢查如果鍵存在於雜湊映射的話，就不改變其值。但如果鍵不存在的話，就插入數值給它。</p>
<p>雜湊映射提供了一個特別的 API 叫做 <code>entry</code> 讓你可以用想要檢查的鍵作為參數。<code>entry</code> 方法的回傳值是一個枚舉叫做 <code>Entry</code>，它代表了一個可能存在或不存在的數值。假設我們想要檢查黃隊的鍵有沒有對應的數值。如果沒有的話，我們想插入 50。而對藍隊也一樣。使用 <code>entry</code> API 的話，程式碼會長得像範例 8-24。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;藍隊&quot;), 10);

    scores.entry(String::from(&quot;黃隊&quot;)).or_insert(50);
    scores.entry(String::from(&quot;藍隊&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-24：使用 <code>entry</code> 方法在只有該鍵尚無任何數值時插入數值</span></p>
<p><code>Entry</code> 中的 <code>or_insert</code> 方法定義了如果 <code>Entry</code> 的鍵有對應的數值的話，就回傳該值的可變參考；如果沒有的話，那就插入參數作為新數值，並回傳此值的可變參考。這樣的技巧比我們親自寫邏輯還來的清楚，而且更有利於借用檢查器的檢查。</p>
<p>執行範例 8-25 的程式碼會印出 <code>{&quot;黃隊&quot;: 50, &quot;藍隊&quot;: 10}</code>。第一次 <code>entry</code> 的呼叫會對黃隊插入數值 50，因為黃隊尚未有任何數值。第二次 <code>entry</code> 的呼叫則不會改變雜湊映射，因為藍隊已經有數值 10。</p>
<h4 id="依據舊值更新數值"><a class="header" href="#依據舊值更新數值">依據舊值更新數值</a></h4>
<p>雜湊映射還有另一種常見的用法是，依照鍵的舊數值來更新它。舉例來說，範例 8-25 展示了一支如何計算一些文字內每個單字各出現多少次的程式碼。我們使用雜湊映射，鍵為單字然後值為我們每次追蹤計算對應單字出現多少次的次數。如果我們是第一次看到該單字的話，我們插入數值 0。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-25：使用雜湊映射儲存單字與次數來計算每個字出現的次數</span></p>
<p>此程式碼會印出 <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>。你可能會看到鍵值配對的順序不太一樣，回想一下<a href="ch08-03-hash-maps.html#accessing-values-in-a-hash-map">「取得雜湊映射的數值」</a><!-- ignore -->段落中提過遍歷雜湊映射的順序是任意的。</p>
<p><code>split_whitespace</code> 方法會遍歷 <code>text</code> 中被空格分開來的切片。<code>or_insert</code> 方法會回傳該鍵對應數值的可變參考（<code>&amp;mut V</code>）。在此我們將可變參考儲存在 <code>count</code> 變數中，所以要賦值的話，我們必須先使用 <code>*</code> 來解參考（dereference）<code>count</code>。可變參考會在 <code>for</code> 結束時離開作用域，所以所有的改變都是安全的且符合借用規則。</p>
<h3 id="雜湊函式"><a class="header" href="#雜湊函式">雜湊函式</a></h3>
<p><code>HashMap</code> 預設是使用一種叫做 SipHash 的雜湊函式（hashing function），這可以透過 <sup class="footnote-reference"><a href="#siphash">1</a></sup><!-- ignore --> 雜湊表（hash table）抵禦阻斷服務（Denial of Service, DoS）的攻擊。這並不是最快的雜湊演算法，但為了提升安全性而犧牲一點效能是值得的。如果你做評測時覺得預設的雜湊函式太慢無法滿足你的需求的話，你可以指定不同的 <em>hasher</em> 來切換成其他雜湊函式。Hasher 是一個有實作 <code>BuildHasher</code> 特徵的型別。我們會在第十章討論到特徵以及如何實作它們。你不必從頭自己實作一個 hasher，<a href="https://crates.io/">crates.io</a><!-- ignore --> 上有其他 Rust 使用者分享的函式庫，其中就有不少提供許多常見雜湊演算法的 hasher 實作。</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a></p>
</div>
<h2 id="總結-7"><a class="header" href="#總結-7">總結</a></h2>
<p>當你的程式需要儲存、取得、修改資料時，向量、字串與雜湊映射可以提供大量的功能。以下是一些你應該能夠解決的練習題：</p>
<ul>
<li>給予一個整數列表，請使用向量並回傳中位數（排序列表後正中間的值）以及眾數（出現最多次的值，雜湊映射在此應該會很有用）。</li>
<li>將字串轉換成 pig latin。每個單字的第一個字母為子音的話，就將該字母移到單字後方，並加上「ay」，所以「first」會變成「irst-fay」。而單字第一個字母為母音的話，就在單字後方加上「hay」，所以「apple」會變成「apple-hay」。請注意要考慮到 UTF-8 編碼！</li>
<li>使用雜湊映射與向量來建立文字介面，讓使用者能新增員工名字到公司內的一個部門。舉來來說「將莎莉加入工程部門」或「將阿米爾加入業務部門」。然後讓使用者可以索取一個部門所有的員工列表，或是依據部門用字典順序排序，取得公司內所有的員工。</li>
</ul>
<p>標準函式庫的 API 技術文件有詳細介紹向量、字串與雜湊映射的所有方法，這對於這些練習題應該會很有幫助！</p>
<p>我們現在已經開始遇到有可能會運作失敗的複雜程式了，所以接下來正是來討論錯誤處理的時候！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="錯誤處理"><a class="header" href="#錯誤處理">錯誤處理</a></h1>
<p>錯誤是軟體開發中不可避免的一環，所以 Rust 有一些特色能夠處理發生錯誤的情形。在許多情況下，Rust 要求你要能知道可能出錯的地方，並在編譯前採取行動。這樣的要求能讓你的程式更穩定，確保你能發現錯誤並在程式碼發佈到生產環境前妥善處理它們！</p>
<p>Rust 將錯誤分成兩大類：<strong>可復原的</strong>（recoverable）和<strong>不可復原的</strong>（unrecoverable）錯誤。像是<strong>找不到檔案</strong>這種可復原的錯誤，我們通常很可能只想回報問題給使用者並重試。而不可復原的錯誤就會是程式錯誤的跡象，像是嘗試取得陣列結尾之後的位置。</p>
<p>許多語言不會區分這兩種錯誤，並以相同的方式處理，使用像是例外（exceptions）這樣統一的機制處理。Rust 沒有例外處理機制，取而代之的是它對可復原的錯誤提供 <code>Result&lt;T, E&gt;</code> 型別，對不可復原的錯誤使用 <code>panic!</code> 將程式停止執行。本章節會先介紹 <code>panic!</code> 再來討論 <code>Result&lt;T, E&gt;</code> 數值的回傳。除此之外，我們也將探討何時該從錯誤中復原，何時該選擇停止程式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="對無法復原的錯誤使用-panic"><a class="header" href="#對無法復原的錯誤使用-panic">對無法復原的錯誤使用 <code>panic!</code></a></h2>
<p>有時候壞事就是會發生在你的程式中，這本來就是你沒辦法全部避免的。在這種情況，Rust 有提供 <code>panic!</code> 巨集。在實際情況下我們有兩種方式可以造成恐慌：做出確定會讓程式碼恐慌的動作（像是存取陣列範圍外的元素），或是直接呼叫 <code>panic!</code> 巨集。在這兩種狀況下，我們都對程式造成了恐慌。這些恐慌預設會印出程式出錯的訊息，展開並清理堆疊，然後離開程式。再加上環境變數的話，你還可以讓 Rust 顯示恐慌時呼叫的堆疊，讓你能更簡單地追蹤恐慌的源頭。</p>
<blockquote>
<h3 id="恐慌時該解開堆疊還是直接終止"><a class="header" href="#恐慌時該解開堆疊還是直接終止">恐慌時該解開堆疊還是直接終止</a></h3>
<p>當恐慌（panic）發生時，程式預設會開始做<strong>解開</strong>（unwind）堆疊的動作，這代表 Rust 會回溯整個堆疊，並清理每個它遇到的函式資料。但是這樣回溯並清理的動作很花力氣。另一種方式是直接<strong>終止</strong>（abort）程式而不清理，程式使用的記憶體會需要由作業系統來清理。</p>
<p>如果你需要你的專案產生的執行檔越小越好，你可以從解開切換成終止，只要在 <em>Cargo.toml</em> 檔案中的 <code>[profile]</code> 段落加上 <code>panic = 'abort'</code> 就好。舉例來說，如果你希望在發佈模式（release mode）恐慌時直接終止，那就加上：</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>讓我們先在小程式內試試呼叫 <code>panic!</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;◢▆▅▄▃ 崩╰(〒皿〒)╯潰▃▄▅▆◣&quot;);
}
</code></pre></pre>
<p>當你執行程式時，你會看到像這樣的結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at '◢▆▅▄▃ 崩╰(〒皿〒)╯潰▃▄▅▆◣', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>panic!</code> 的呼叫導致印出了最後兩行的錯誤訊息。第一行顯示了我們的恐慌訊息以及該恐慌是在原始碼何處發生的：<em>src/main.rs:2:5</em> 指的是它發生在我們的 <em>src/main.rs</em> 檔案第二行第五個字元。</p>
<p>在此例中，該行指的就是我們寫的程式碼。如果我們查看該行，我們會看到 <code>panic!</code> 巨集的呼叫。在其他情形，<code>panic!</code> 的呼叫可能會發生在我們呼叫的程式碼內，所以錯誤訊息回報的檔案名稱與行數可能就會是其他人呼叫 <code>panic!</code> 巨集的程式碼，而不是因為我們的程式碼才導致 <code>panic!</code> 的呼叫。我們可以在呼叫 <code>panic!</code> 程式碼的地方使用 backtrace 來找出出現問題的地方。接下來我們就會深入瞭解 backtrace。</p>
<h3 id="使用-panic-backtrace"><a class="header" href="#使用-panic-backtrace">使用 <code>panic!</code> Backtrace</a></h3>
<p>讓我們看看另一個例子，這是函式庫發生錯誤而呼叫 <code>panic!</code>，而不是來自於我們在程式碼自己呼叫的巨集。範例 9-1 是個嘗試從向量有效範圍外取得索引的例子。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">範例 9-1：嘗試取得超出向量長度的元素，進而導致 <code>panic!</code> 被呼叫</span></p>
<p>我們在這邊嘗試取得向量中第 100 個元素（不過因為索引從零開始，所以是索引 99），但是該向量只有 3 個元素。在此情況下，Rust 就會恐慌。使用 <code>[]</code> 會回傳元素，但是如果你傳遞了無效的索引，Rust 就回傳不了正確的元素。</p>
<p>在 C 中，嘗試讀取資料結構結束之後的元素屬於未定義行為。你可能會得到該記憶體位置對應其資料結構的元素，即使該記憶體完全不屬於該資料結構。這就稱做<strong>緩衝區過讀</strong>（buffer overread）而且會導致安全漏洞。攻擊者可能故意操縱該索引來取得在資料結構後面他們原本不應該讀寫的值。</p>
<p>為了保護你的程式免於這樣的漏洞，如果你嘗試用一個不存在的索引讀取元素的話，Rust 會停止執行並拒絕繼續運作下去。讓我們嘗試執行並看看會如何：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>此錯誤指向 <code>main.rs</code> 的第四行，也就是我們嘗試存取索引 99 的地方。下一行提示告訴我們可以設置 <code>RUST_BACKTRACE</code> 環境變數來取得 backtrace 以知道錯誤發生時到底發生什麼事。<em>backtrace</em> 是一個函式列表，指出得到此錯誤時到底依序呼叫了哪些函式。Rust 的 backtraces 運作方式和其他語言一樣：讀取 backtrace 關鍵是從最一開始讀取直到你看到你寫的檔案。那就會是問題發生的源頭。那行以上的行數就是你所呼叫的程式，而以下則是其他呼叫你的程式碼的程式。這些行數可能還會包含 Rust 核心程式碼、標準函式庫程式碼，或是你所使用的 crate。我們設置 <code>RUST_BACKTRACE</code> 環境變數的值不為 0，來嘗試取得 backtrace 吧。你應該會看到和範例 9-2 類似的結果。</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><span class="caption">範例 9-2：當 <code>RUST_BACKTRACE</code> 設置時，透過呼叫 <code>panic!</code> 產生的 backtrace</span></p>
<p>輸出結果有點多啊！你看到的實際輸出可能會因你的作業系統與 Rust 版本而有所不同。要取得這些資訊的 backtrace，除錯符號（debug symbols）必須啟用。當我們在使用 <code>cargo build</code> 或 <code>cargo run</code> 且沒有加上 <code>--release</code> 時，除錯符號預設是啟用的。</p>
<p>在範例 9-2 的輸出結果中，第 6 行的 backtrace 指向了我們專案中產生問題的地方：<em>src/main.rs</em> 中的第四行。如果我們不想讓程式恐慌，我們就要來調查我們所寫的程式中第一個被錯誤訊息指向的位置。在範例 9-1 中，我們故意寫出會恐慌的程式碼。要修正的方法就是不要索取超出向量索引範圍的元素。當在未來你的程式碼恐慌時，你會需要知道是程式碼中的什麼動作造成的、什麼數值導致恐慌以及正確的程式碼該怎麼處理。</p>
<p>我們會在本章節<a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">「要 <code>panic!</code> 還是不要 <code>panic!</code>」</a><!-- ignore -->的段落中再回來看 <code>panic!</code> 並研究何時該與不該使用 <code>panic!</code> 來處理錯誤條件。接下來，我們要看如何使用 <code>Result</code>來處理可回復的錯誤。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="result-與可復原的錯誤"><a class="header" href="#result-與可復原的錯誤"><code>Result</code> 與可復原的錯誤</a></h2>
<p>大多數的錯誤沒有嚴重到需要讓整個程式停止執行。有時候當函式失敗時，你是可以輕易理解並作出反應的。舉例來說，如果你嘗試開啟一個檔案，但該動作卻因為沒有該檔案而失敗的話，你可能會想要建立檔案，而不是終止程序。</p>
<p>回憶一下第二章的<a href="ch02-00-guessing-game-tutorial.html#%E4%BD%BF%E7%94%A8-result-%E8%99%95%E7%90%86%E5%8F%AF%E8%83%BD%E7%9A%84%E9%8C%AF%E8%AA%A4">「使用 <code>Result</code> 型別可能的錯誤」</a><!-- ignore -->提到 <code>Result</code> 枚舉的定義有兩個變體 <code>Ok</code> 和 <code>Err</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> 和 <code>E</code> 是泛型型別參數，我們會在第十章深入討論泛型。你現在需要知道的是 <code>T</code> 代表我們在成功時會在 <code>Ok</code> 變體回傳的型別，而 <code>E</code> 則代表失敗時在 <code>Err</code> 變體會回傳的錯誤型別。因為 <code>Result</code> 有這些泛型型別參數，我們可以將 <code>Result</code> 型別和它的函式用在許多不同場合，讓成功與失敗時回傳的型別不相同。</p>
<p>讓我們呼叫一個可能會失敗的函式並回傳 <code>Result</code> 型別。在範例 9-3 我們嘗試開啟一個檔案。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 9-3：嘗試開啟一個檔案</span></p>
<p><code>File::open</code> 的回傳型別為 <code>Result&lt;T, E&gt;</code>。泛型參數 <code>T</code> 在此已經被 <code>File::open</code> 指明成功時會用到的型別 <code>std::fs::File</code>，也就是檔案的控制代碼（handle）。用於錯誤時的 <code>E</code> 型別則是 <code>std::io::Error</code>。這樣的回傳型別代表 <code>File::open</code> 的呼叫在成功時會回傳我們可以讀寫的檔案控制代碼，但該函式呼叫也可能失敗。舉例來說，該檔案可能會不存在，或者我們沒有檔案的存取權限。<code>File::open</code> 需要有某種方式能告訴我們它的結果是成功或失敗，並回傳檔案控制代碼或是錯誤資訊。這樣的資訊正是 <code>Result</code> 枚舉想表達的。</p>
<p>如果 <code>File::open</code> 成功的話，變數 <code>greeting_file_result</code> 的數值就會獲得包含檔案控制代碼的 <code>Ok</code> 實例。如果失敗的話，<code>greeting_file_result</code> 的值就會是包含為何產生該錯誤的資訊的 <code>Err</code> 實例。</p>
<p>我們需要讓範例 9-3 的程式碼依據 <code>File::open</code> 回傳不同的結果採取不同的動作。範例 9-4 展示了其中一種處理 <code>Result</code> 的方式，我們使用第六章提到的 <code>match</code> 表達式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;開啟檔案時發生問題：{:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">範例 9-4：使用 <code>match</code> 表達式來處理回傳的 <code>Result</code> 變體</span></p>
<p>和 <code>Option</code> 枚舉一樣，<code>Result</code> 枚舉與其變體都會透過 prelude 引入作用域，所以我們不需要指明 <code>Result::</code>，可以直接在 <code>match</code> 的分支中使用 <code>Ok</code> 和 <code>Err</code> 變體。</p>
<p>當結果是 <code>Ok</code> 時，這裡的程式碼就會回傳 <code>Ok</code> 變體中內部的 <code>file</code>，然後我們就可以將檔案控制代碼賦值給變數 <code>greeting_file</code>。在 <code>match</code> 之後，我們就可以使用檔案控制代碼來讀寫。</p>
<p><code>match</code> 的另一個分支則負責處理我們從 <code>File::open</code> 中取得的 <code>Err</code> 數值。在此範例中，我們選擇呼叫 <code>panic!</code> 巨集。如果檔案 <em>hello.txt</em> 不存在我們當前的目錄的話，我們就會執行此程式碼，接著就會看到來自 <code>panic!</code> 巨集的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at '開啟檔案時發生問題：Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>如往常一樣，此輸出告訴我們哪裡出錯了。</p>
<h3 id="配對不同種的錯誤"><a class="header" href="#配對不同種的錯誤">配對不同種的錯誤</a></h3>
<p>範例 9-4 的程式碼不管 <code>File::open</code> 為何失敗都會呼叫 <code>panic!</code>。不過我們想要依據不同的錯誤原因採取不同的動作，如果 <code>File::open</code> 是因為檔案不存在的話，我們想要建立檔案並回傳新檔案的控制代碼。如果 <code>File::open</code> 是因為其他原因失敗的話，像是我們沒有開啟檔案的權限，我們仍然要像範例 9-4 這樣呼叫 <code>panic!</code>。對此我們可以加上 <code>match</code> 表達式，如範例 9-5 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open(&quot;hello.txt&quot;);

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;建立檔案時發生問題：{:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;開啟檔案時發生問題：{:?}&quot;, other_error);
            }
        },
    };
}
</code></pre>
<p><span class="caption">範例 9-5：針對不同種類的錯誤採取不同動作</span></p>
<p><code>File::open</code> 在 <code>Err</code> 變體的回傳型別為 <code>io::Error</code>，這是標準函式庫提供的結構體。此結構體有個 <code>kind</code> 方法讓我們可以取得 <code>io::ErrorKind</code> 數值。標準函式庫提供的枚舉 <code>io::ErrorKind</code> 有從 <code>io</code> 運算可能發生的各種錯誤。我們想處理的變體是 <code>ErrorKind::NotFound</code>，這指的是我們嘗試開啟的檔案還不存在。所以我們對 <code>greeting_file_result</code> 配對並在用 <code>error.kind()</code> 繼續配對下去。</p>
<p>我們從內部配對檢查 <code>error.kind()</code> 的回傳值是否是 <code>ErrorKind</code> 枚舉中的 <code>NotFound</code> 變體。如果是的話，我們就嘗試使用 <code>File::create</code> 建立檔案。不過 <code>File::create</code> 也可能會失敗，所以我們需要第二個內部 <code>match</code> 表達式來處理。如果檔案無法建立的話，我們就會印出不同的錯誤訊息。第二個分支的外部 <code>match</code> 分支保持不變，如果程式遇到其他錯誤的話就會恐慌。</p>
<blockquote>
<h3 id="除了使用-match-配對-resultt-e-以外的方式"><a class="header" href="#除了使用-match-配對-resultt-e-以外的方式">除了使用 <code>match</code> 配對 <code>Result&lt;T, E&gt;</code> 以外的方式</a></h3>
<p>我們用的 <code>match</code> 的確有點多！<code>match</code> 表達式雖然很實用，不過它的行為非常基本。在第十三章你會學到閉包（closure），<code>Result&lt;T, E&gt;</code> 型別有很多接收閉包的方法。使用這些方法可以讓你的程式碼更簡潔。</p>
<p>舉例來說，以下是另一種能寫出與範例 9-5 邏輯相同的程式碼，這次則是使用到閉包與 <code>unwrap_or_else</code> 方法：</p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;建立檔案時發生問題：{:?}&quot;, error);
            })
        } else {
            panic!(&quot;開啟檔案時發生問題：{:?}&quot;, error);
        }
    });
}
</code></pre>
<p>雖然此程式碼的行為和範例 9-5 一樣，但他沒有包含任何 <code>match</code> 表達式而且更易閱讀。當你讀完第十三章後，別忘了回來看看此範例，並查閱標準函式庫中的 <code>unwrap_or_else</code> 方法。除此方法以外，還有更多方法可以來解決處理錯誤時龐大的 <code>match</code> 表達式。</p>
</blockquote>
<h3 id="錯誤發生時產生恐慌的捷徑unwrap-與-expect"><a class="header" href="#錯誤發生時產生恐慌的捷徑unwrap-與-expect">錯誤發生時產生恐慌的捷徑：<code>unwrap</code> 與 <code>expect</code></a></h3>
<p>雖然 <code>match</code> 已經足以勝任指派的任務了，但它還是有點冗長，而且可能無法正確傳遞錯誤的嚴重性。<code>Result&lt;T, E&gt;</code> 型別有非常多的輔助方法來執行不同的特定任務。<code>unwrap</code> 就和我們在範例 9-4 所寫的 <code>match</code> 表達式一樣，擁有類似效果的捷徑方法。如果 <code>Result</code> 的值是 <code>Ok</code> 變體，<code>unwrap</code>會回傳 <code>Ok</code> 裡面的值；如果 <code>Result</code> 是 <code>Err</code> 變體的話，<code>unwrap</code> 會呼叫 <code>panic!</code> 巨集。以下是使用 <code>unwrap</code> 的方式：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>如果我們沒有 <em>hello.txt</em> 這個檔案並執行此程式碼的話，我們會看到從 <code>unwrap</code> 方法所呼叫的 <code>panic!</code> 回傳訊息：</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-04-unwrap
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:4:49
</code></pre>
<p>還有另一個方法 <code>expect</code> 和 <code>unwrap</code> 類似，不過能讓我們選擇 <code>panic!</code> 回傳的錯誤訊息。使用 <code>expect</code> 而非 <code>unwrap</code> 並提供完善的錯誤訊息可以表明你的意圖，讓追蹤恐慌的源頭更容易。<code>expect</code> 的語法看起來就像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)
        .expect(&quot;hello.txt 應該要存在此專案中&quot;);
}
</code></pre></pre>
<p>我們使用 <code>expect</code> 的方式和 <code>unwrap</code> 一樣，不是回傳檔案控制代碼就是呼叫 <code>panic!</code> 巨集。使用 <code>expect</code> 呼叫 <code>panic!</code> 時的錯誤訊息會是我們傳遞給 <code>expect</code> 的參數，而不是像 <code>unwrap</code> 使用 <code>panic!</code> 預設的訊息。訊息看起來就會像這樣：</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/no-listing-05-expect
cargo run
copy and paste relevant text
-->
<pre><code class="language-text">thread 'main' panicked at 'hello.txt 應該要存在此專案中: Os {
code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }',
src/main.rs:5:10
</code></pre>
<p>在正式環境等級的程式碼，大多數 Rustaceans 會選擇 <code>expect</code> 而不是 <code>unwrap</code>，這樣能在出錯時提供更多資訊，告訴我們為何預期該動作永遠成功。這樣一來就算你的假設證明錯誤，你都能夠在除錯時有足夠的資訊來理解。</p>
<h3 id="傳播錯誤"><a class="header" href="#傳播錯誤">傳播錯誤</a></h3>
<p>當函式實作呼叫的程式碼可能會失敗時，與其直接在該函式本身處理錯誤，你可以回傳錯誤給呼叫此程式的程式碼，由它們決定如何處理。這稱之為<strong>傳播</strong>（propagating）錯誤並讓呼叫者可以有更多的控制權，因為比起你程式碼當下的內容，回傳的錯誤可能提供更多資訊與邏輯以利處理。</p>
<p>舉例來說，範例 9-6 展示了一個從檔案讀取使用者名稱的函式。如果檔案不存在或無法讀取的話，此函式會回傳該錯誤給呼叫該函式的程式碼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open(&quot;hello.txt&quot;);

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-6：使用 <code>match</code> 回傳錯誤給呼叫者的函式</span></p>
<p>此函式還能再更簡化，但我們要先繼續手動處理來進一步探討錯誤處理，最後我們會展示最精簡的方式。讓我們先看看此函式的回傳型別 <code>Result&lt;String, io::Error&gt;</code>。這代表此函式回傳的型別為 <code>Result&lt;T, E&gt;</code>，其中泛型型別 <code>T</code> 已經指明為實際型別 <code>String</code>，而泛型型別 <code>E</code> 則指明為實際型別 <code>io::Error</code>。</p>
<p>如果函式正確無誤的話，程式碼會呼叫此函式並收到擁有 <code>String</code> 的 <code>Ok</code> 數值。如果程式遇到任何問題的話，呼叫此函式的程式碼就會獲得擁有包含相關問題發生資訊的 <code>io::Error</code> 實例的 <code>Err</code> 數值。我們選擇 <code>io::Error</code> 作為函式的回傳值是因為它正是 <code>File::open</code> 函式和 <code>read_to_string</code> 方法失敗時的回傳的錯誤型別。</p>
<p>函式本體從呼叫 <code>File::open</code> 開始，然後我們使用 <code>match</code> 回傳 <code>Result</code> 數值，就和範例 9-4 的 <code>match</code> 類似。如果 <code>File::open</code> 成功的話，變數 <code>file</code> 中的檔案控制代碼賦值給可變變數 <code>username_file</code> 並讓函式繼續執行下去。但在 <code>Err</code> 的情形時，與其呼叫 <code>panic!</code>，我們使用 <code>return</code> 關鍵字來讓函式提早回傳，並將 <code>File::open</code> 的錯誤值，也就是模式中的變數 <code>e</code>，作為此函式的錯誤值回傳給呼叫的程式碼。</p>
<p>所以如果我們在 <code>username_file</code> 有拿到檔案控制代碼的話，接著函式就會在變數 <code>username</code> 建立新的 <code>String</code> 並對檔案控制代碼 <code>username_file</code> 呼叫 <code>read_to_string</code> 方法來讀取檔案內容至 <code>username</code>。<code>read_to_string</code> 也會回傳 <code>Result</code> 因為它也可能失敗，就算 <code>File::open</code> 是執行成功的。所以我們需要另一個 <code>match</code> 來處理該 <code>Result</code>，如果 <code>read_to_string</code> 成功的話，我們的函式就是成功的，然後在 <code>Ok</code> 回傳 <code>username</code> 中該檔案的使用者名稱。如果 <code>read_to_string</code> 失敗的話，我們就像處理 <code>File::open</code> 的 <code>match</code> 一樣回傳錯誤值。不過我們不需要顯式寫出 <code>return</code>，因為這是函式中的最後一個表達式。</p>
<p>呼叫此程式碼的程式就會需要處理包含使用者名稱的 <code>Ok</code> 數值以及包含 <code>io::Error</code> 的 <code>Err</code> 數值。這交給呼叫的程式碼來決定如何處理這些數值。舉例來說，如果呼叫此程式碼而獲得錯誤的話，它可能選擇呼叫 <code>panic!</code> 讓程式崩潰，或者使用預設的使用者名稱從檔案以外的地方尋找該使用者。所以我們傳播所有成功或錯誤的資訊給呼叫者，讓它們能妥善處理。</p>
<p>這樣傳播錯誤的模式是非常常見的，所以 Rust 提供了 <code>?</code> 來簡化流程。</p>
<h4 id="傳播錯誤的捷徑-運算子"><a class="header" href="#傳播錯誤的捷徑-運算子">傳播錯誤的捷徑：<code>?</code> 運算子</a></h4>
<p>範例 9-7 是另一個 <code>read_username_from_file</code>的實作，擁有和範例 9-6 一樣的效果，不過這次使用了 <code>?</code> 運算子。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-7：使用 <code>?</code> 運算子回傳錯誤給呼叫者的函式</span></p>
<p>定義在 <code>Result</code> 數值後的 <code>?</code> 運作方式幾乎與範例 9-6 的 <code>match</code> 表達式處理 <code>Result</code> 的方式一樣。如果 <code>Result</code> 的數值是 <code>Ok</code> 的話，<code>Ok</code> 內的數值就會從此表達式回傳，然後程式就會繼續執行。如果數值是 <code>Err</code> 的話，<code>Err</code> 就會使用 <code>return</code> 關鍵字作為整個函式的回傳值回傳，讓錯誤數值可以傳遞給呼叫者的程式碼。</p>
<p>不過範例 9-6 的 <code>match</code> 表達式做的事和 <code>?</code> 運算子做的事還是有不同的地方：<code>?</code> 運算子呼叫所使用的錯誤數值會傳遞到 <code>from</code> 函式中，這是定義在標準函式庫的 <code>From</code> 特徵中，用來將數值從一種型別轉換另一種型別。當 <code>?</code> 運算子呼叫 <code>from</code> 函式時，接收到的錯誤型別會轉換成目前函式回傳值的錯誤型別。這在當函式要回傳一個錯誤型別來代表所有函式可能的失敗是很有用的，即使可能會失敗的原因有很多種。</p>
<p>舉例來說，我們可以將範例 9-7 的函式 <code>read_username_from_file</code> 改成回傳一個我們自訂的錯誤型別叫做 <code>OurError</code>。如果我們有定義 <code>impl From&lt;io::Error&gt; for OurError</code> 能從 <code>io::Error</code> 建立一個 <code>OurError</code> 實例的話，那麼 <code>read_username_from_file</code> 本體中的 <code>?</code> 運算就會呼叫 <code>from</code> 然後轉換錯誤型別，不必在函式那多加任何程式碼。</p>
<p>在範例 9-7 中，在 <code>File::open</code> 的結尾中 <code>?</code> 回傳 <code>Ok</code> 中的數值給變數 <code>username_file</code>。如果有錯誤發生時，<code>?</code> 運算子會提早回傳整個函式並將 <code>Err</code> 的數值傳給呼叫的程式碼。同理也適用在呼叫 <code>read_to_string</code> 結尾的 <code>?</code>。</p>
<p><code>?</code> 運算子可以消除大量樣板程式碼並讓函式實作更簡單。我們還可以再進一步將方法直接串接到 <code>?</code> 後來簡化程式碼，如範例 9-8 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;

    Ok(username)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-8：在 <code>?</code> 運算子後方串接方法呼叫</span></p>
<p>我們將建立新 <code>String</code> 的變數 <code>username</code> 移到函式的開頭，這部分沒有任何改變。再來與建立變數 <code>username_file</code> 的地方不同的是，我們直接將 <code>read_to_string</code> 串接到 <code>File::open(&quot;hello.txt&quot;)?</code> 的結果後方。我們在 <code>read_to_string</code> 呼叫的結尾還是有 <code>?</code>，然後我們還是在 <code>File::open</code> 和 <code>read_to_string</code> 成功沒有失敗時，回傳包含 <code>username</code> 的 <code>Ok</code> 數值。函式達成的效果仍然與範例 9-6 與 9-7 相同。這只是一個比較不同但慣用的寫法。</p>
<p>說到此函式不同的寫法，範例 9-9 展示了使用 <code>fs::read_to_string</code> 更短的寫法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-9：使用 <code>fs::read_to_string</code> 而不是開啟檔案後才讀取</span></p>
<p>讀取檔案至字串中算是個常見動作，所以標準函式庫提供了一個方便的函式 <code>fs::read_to_string</code> 來開啟檔案、建立新的 <code>String</code>、讀取檔案內容、將內容放入該 <code>String</code> 並回傳它。不過使用 <code>fs::read_to_string</code> 就沒有機會讓我們來解釋所有的錯誤處理，所以我們一開始才用比較長的寫法。</p>
<h4 id="-運算子可以用哪裡"><a class="header" href="#-運算子可以用哪裡"><code>?</code> 運算子可以用哪裡？</a></h4>
<p><code>?</code> 運算子只能用在有函式的回傳值相容於 <code>?</code> 使用的值才行。這是因為 <code>?</code> 運算子會在函式中提早回傳數值，就像我們在範例 9-6 那樣用 <code>match</code> 表達式提早回傳一樣。在範例 9-6 中，<code>match</code> 使用的是 <code>Result</code> 數值，函式的回傳值必須是 <code>Result</code> 才能相容於此 <code>return</code>。</p>
<p>讓我們看看在範例 9-10 的 <code>main</code> 函式中的回傳值要是不兼容於我們用在 <code>?</code> 的型別，如果我們使用 <code>?</code> 運算子會發生什麼事：</p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<p><span class="caption">範例 9-10：嘗試在回傳 <code>()</code> 的 <code>main</code> 函式中使用 <code>?</code> 會無法編譯</span></p>
<p>此程式法會開啟檔案，所以可能會失敗。<code>?</code> 運算子會拿到 <code>File::open</code> 回傳的 <code>Result</code> 數值，但是此 <code>main</code> 函式的回傳值為<code>()</code> 而非 <code>Result</code>。當我們編譯此程式碼時，我們會得到以下錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open(&quot;hello.txt&quot;)?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling` due to previous error
</code></pre>
<p>此錯誤告訴我們只能在回傳型別為 <code>Result</code> 或 <code>Option</code> 或其他有實作 <code>FromResidual</code> 的型別的函式才能使用 <code>?</code> 運算子。</p>
<p>要修正此錯誤的話，你有兩種選擇。其中一種是如果你沒有任何限制的話，你可以將函式回傳值變更成與 <code>?</code> 運算子兼容的型別。另一種則是依照可能的情境使用 <code>match</code> 或 <code>Result&lt;T, E&gt;</code> 其中一種方法來處理 <code>Result&lt;T, E&gt;</code>。</p>
<p>錯誤訊息還提到了 <code>?</code> 也能用在 <code>Option&lt;T&gt;</code> 的數值。就像 <code>?</code> 能用在 <code>Result</code>一樣，你只能在有回傳 <code>Option</code> 的函式中，對 <code>Option</code> 的值使用 <code>?</code>。在 <code>Option&lt;T&gt;</code> 呼叫 <code>?</code> 的行為與在 <code>Result&lt;T, E&gt;</code> 上呼叫類似：如果數值為 <code>None</code>，<code>None</code> 就會在函式該處被提早回傳；如果數值為 <code>Some</code>，<code>Some</code> 中的值就會是表達式的結果數值，且程式會繼續執行下去。以下範例 9-11 的函式會尋找給予文字的第一行中最後一個字元：</p>
<pre><pre class="playground"><code class="language-rust">fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(
</span><span class="boring">        last_char_of_first_line(&quot;Hello, world\nHow are you today?&quot;),
</span><span class="boring">        Some('d')
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;&quot;), None);
</span><span class="boring">    assert_eq!(last_char_of_first_line(&quot;\nhi&quot;), None);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-11：<code>Option&lt;T&gt;</code> 的數值上使用在 <code>?</code> 運算子</span></p>
<p>此函式會回傳 <code>Option&lt;char&gt;</code>，因為它可能會在此真的找到字元，或者可能根本沒有半個字存在。此程式碼接受引數 <code>text</code> 字串切片，並呼叫它的 <code>lines</code> 方法，這會回傳一個遍歷字串每一行的疊代器。因為此函式想要的是第一行，它對疊代器只呼叫 <code>next</code> 來取得疊代器的第一個數值。如果 <code>text</code> 是空字串的話，這裡 <code>next</code> 的呼叫就會回傳 <code>None</code>。我們這裡就可以使用 <code>?</code> 來中斷 <code>last_char_of_first_line</code> 並回傳 <code>None</code>。如果 <code>text</code> 不是空字串的話，<code>next</code> 會用 <code>Some</code> 數值來回傳 <code>text</code> 的第一行字串切片。</p>
<p><code>?</code> 會取出字串切片，然後我們可以對字串切片呼叫 <code>chars</code> 來取得它的疊代器。我們在意的是第一行的最後一個字元，所以我們呼叫 <code>last</code> 來取得疊代器的最後一個值。這也是個 <code>Option</code> 因為第一行可能是個空字串。如果 <code>text</code> 開頭就換行，但在下一行有字元的話，它可能就會是 <code>&quot;\nhi&quot;</code>。不過如果第一行真的有最後一個字元的話，它就會回傳 <code>Some</code> 變體。在這過程中的 <code>?</code> 運算子讓我們能簡潔地表達此邏輯，並讓我們能只用一行就能實作出來。如果我們對 <code>Option</code> 無法使用 <code>?</code> 運算子的話，我們使用更多方法呼叫或 <code>match</code> 表達式才能實作此邏輯。</p>
<p>請注意你可以在有回傳 <code>Result</code> 的函式對 <code>Result</code> 的值使用 <code>?</code> 運算子，你可以在有回傳 <code>Option</code> 的函式對 <code>Option</code> 的值使用 <code>?</code> 運算子，但你無法混合使用。<code>?</code> 運算子無法自動轉換 <code>Result</code> 與 <code>Option</code> 之間的值。在這種狀況下會需要顯式表達，<code>Result</code> 的話有提供 <code>ok</code> 方法，<code>Option</code> 的話有提供 <code>ok_or</code> 方法。</p>
<p>目前為止，所有我們使用過的 <code>main</code> 函式都是回傳 <code>()</code>。<code>main</code> 是個特別的函式，因為它是可執行程式的進入點與出口點，而要讓程式可預期執行的話，它的回傳型別就得要有些限制。</p>
<p>幸運的是 <code>main</code> 也可以回傳 <code>Result&lt;(), E&gt;</code>。範例 9-12 取自範例 9-10，不過我們更改 <code>main</code> 的回傳型別為<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，並在結尾的回傳數值加上 <code>Ok(())</code>。這樣的程式碼是能編譯的：</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><span class="caption">範例 9-12：將 <code>main</code> 改成回傳 <code>Result&lt;(), E&gt;</code> 就能允許在 <code>Result</code> 數值上使用 <code>?</code> 運算子</span></p>
<p><code>Box&lt;dyn Error&gt;</code> 型別使用了<strong>特徵物件</strong>（trait object）我們會在第十七章的<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">「允許不同型別數值的特徵物件」</a><!-- ignore -->討論到。現在你可以將 <code>Box&lt;dyn Error&gt;</code> 視為它是「任何種類的錯誤」。在有 <code>Box&lt;dyn Error&gt;</code> 錯誤型別的 <code>main</code> 函式中的 <code>Result</code> 使用 <code>?</code> 是允許的，因為現在 <code>Err</code> 數值可以被提早回傳。盡管此 <code>main</code> 函式本的只會回傳錯誤型別 <code>std::io::Error</code>，但有了 <code>Box&lt;dyn Error&gt;</code> 的話，此簽名就能允許其他錯誤型別加入 <code>main</code> 本體中。</p>
<p>當 <code>main</code> 函式回傳 <code>Result&lt;(), E&gt;</code> 時，如果 <code>main</code> 回傳 <code>Ok(())</code> 的話，執行檔就會用 <code>0</code> 退出；如果 <code>main</code> 回傳 <code>Err</code> 數值的話，就會用非零數值退出。用 C 語言寫的執行檔在退出時會回傳整數：程式成功退出的話會回傳整數 <code>0</code>，而程式退出錯誤的話則會回傳不是 <code>0</code> 的其他整數。而 Rust 執行檔也遵循相容這項規則。</p>
<p><code>main</code> 函式可以回傳任何有實作 <a href="../std/process/trait.Termination.html"><code>std::process::Termination</code></a><!-- ignore --> 特徵的型別，該特徵包含了一個函式 <code>report</code> 來回傳 <code>ExitCode</code>。你可以查閱標準函式庫技術文件來了解如何對你的型別實作 <code>Termination</code> 特徵。</p>
<p>現在我們已經討論了呼叫 <code>panic!</code> 與回傳 <code>Result</code> 的細節。現在讓我們回到何時該使用何種辦法的主題上吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="要-panic-還是不要-panic"><a class="header" href="#要-panic-還是不要-panic">要 panic! 還是不要 panic!</a></h2>
<p>所以你該如何決定何時要呼叫 <code>panic!</code> 還是要回傳 <code>Result</code> 呢？當程式碼恐慌時，就沒有任何恢復的方式。你可以在任何錯誤場合呼叫 <code>panic!</code>，無論是可能或不可能復原的情況。不過這樣你就等於替呼叫你的程式碼的呼叫者做出決定，讓情況變成無法復原的錯誤了。當你選擇回傳 <code>Result</code> 數值，你將決定權交給呼叫者的程式碼。呼叫者可能會選擇符合當下場合的方式嘗試復原錯誤，或者它可以選擇 <code>Err</code> 內的數值是不可恢復的，所以它就呼叫 <code>panic!</code> 讓你原本可恢復的錯誤轉成不可恢復。因此，當你定義可能失敗的函式時預設回傳 <code>Result</code> 是不錯的選擇。</p>
<p>在像是範例、草稿與測試的情況下，程式碼恐慌會比回傳 <code>Result</code> 來得恰當。讓我們來探討為何比較好。然後我們再來討論編譯器無法辨別出不可能失敗，但身為人類的你卻可以的情況。本章節會總結一些通用指導原則來決定何時在函式庫程式碼中恐慌。</p>
<h3 id="範例程式碼原型與測試"><a class="header" href="#範例程式碼原型與測試">範例、程式碼原型與測試</a></h3>
<p>當你在寫解釋一些概念的範例時，寫出完善錯誤處理的範例，反而會讓範例變得較不清楚。在範例中，使用像是 <code>unwrap</code> 這樣會恐慌的方法可以被視為是一種要求使用者自行決定如何處理錯誤的表現，因為他們可以依據程式碼執行的方式來修改此方法。</p>
<p>同樣地 <code>unwrap</code> 與 <code>expect</code> 方法也很適用在試做原型，你可以在決定準備開始處理錯誤前使用它們。它們會留下清楚的痕跡，當你準備好要讓程式碼更穩固時，你就能回來修改。</p>
<p>如果有方法在測試內失敗時，你會希望整個測試都失敗，就算該方法不是要測試的功能。因為 <code>panic!</code> 會將測試標記為失敗，所以在此呼叫 <code>unwrap</code> 或 <code>expect</code> 是很正確的。</p>
<h3 id="當你知道的比編譯器還多的時候"><a class="header" href="#當你知道的比編譯器還多的時候">當你知道的比編譯器還多的時候</a></h3>
<p>如果你知道一些編譯器不知道的邏輯的話，直接在 <code>Result</code> 呼叫 <code>unwrap</code> 或 <code>expect</code> 來直接取得 <code>Ok</code> 的數值是很有用的。你還是會有個 <code>Result</code> 數值需要做處理，你呼叫的程式碼還是有機會失敗的，就算在你的特定場合中邏輯上是不可能的。如果你能保證在親自審閱程式碼後，你絕對不可能會有 <code>Err</code> 變體的話，那麼呼叫 <code>unwrap</code> 是完全可以接受的。而更好的話，用 <code>expect</code> 說明為何你一定不會遇到 <code>Err</code> 變體。以下範例就是如此：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;
        .parse()
        .expect(&quot;寫死的 IP 位址應該要有效&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>我們傳遞寫死的字串來建立 <code>IpAddr</code> 的實例。我們可以看出 <code>127.0.0.1</code> 是完全合理的 IP 位址，所以這邊我們可以直接 <code>expect</code>。不過使用寫死的合理字串並不會改變 <code>parse</code> 方法的回傳型別，我們還是會取得 <code>Result</code> 數值，編譯器仍然會要我們處理 <code>Result</code> 並認為 <code>Err</code> 變體是有可能發生的。因為編譯器並沒有聰明到可以看出此字串是個有效的 IP 位址。如果 IP 位址的字串是來自使用者輸入而非我們寫死進程式的話，它<strong>的確</strong>有可能會失敗，這時我們就得要認真處理 <code>Result</code> 了。註明該 IP 位址是寫死的能在未來我們想拿掉 <code>expect</code> 並改善錯誤處理時，幫助我們理解需要如何從其他來源處理 IP 位址。</p>
<h3 id="錯誤處理的指導原則"><a class="header" href="#錯誤處理的指導原則">錯誤處理的指導原則</a></h3>
<p>當你的程式碼可能會導致嚴重狀態的話，就建議讓你的程式恐慌。這裡的嚴重狀態是指一些假設、保證、協議或不可變性被打破時的狀態，像是當你的程式碼有無效的數值、互相矛盾的數值或缺少數值。另外還加上以下情形：</p>
<ul>
<li>該嚴重狀態並非預期會發生的，而不是像使用者輸入了錯誤格式這種偶而可能會發生的。</li>
<li>你的程式在此時需要避免這種嚴重狀態，而不是在每一步都處理此問題。</li>
<li>你所使用的型別沒有適合的方式能夠處理此嚴重狀態。我們會在第十七章的<a href="ch17-03-oo-design-patterns.html#%E5%AE%9A%E7%BE%A9%E7%8B%80%E6%85%8B%E8%88%87%E8%A1%8C%E7%82%BA%E6%88%90%E5%9E%8B%E5%88%A5">「定義狀態與行為成型別」</a><!-- ignore -->段落用範例解釋我們指的是什麼。</li>
</ul>
<p>如果有人呼叫了你的程式碼卻傳遞了不合理的數值，如果可以的話最好的辦法是回傳個錯誤，這樣函式庫的使用者可以決定在該情況下該如何處理。不過要是繼續執行下去可能會造成危險或不安全的話，最好的辦法是呼叫 <code>panic!</code> 並警告使用函式庫的人他們程式碼錯誤發生的位置，好讓他們在開發時就能修正。同樣地，<code>panic!</code> 也適合用於如果你呼叫了你無法掌控的外部程式碼，然後它回傳了你無法修正的無效狀態。</p>
<p>不過如果失敗是可預期的，回傳 <code>Result</code> 就會比呼叫 <code>panic!</code> 來得好。類似的例子有，語法分析器（parser）收到格式錯誤的資訊，或是 HTTP 請求回傳了一個狀態，告訴你已經達到請求上限了。在這樣的案例，回傳 <code>Result</code> 代表失敗是預期有時會發生的，而且呼叫者必須決定如何處理。</p>
<p>當你的程式碼可能會因為進行運算時輸入無效數值，而造成使用者安危的話，你的程式需要先驗證該數值，如果數值無效的話就要恐慌。這是基於安全原則，嘗試對無效資料做運算的話可能會導致你的程式碼產生漏洞。這也是標準函式庫在你嘗試取得超出界限的記憶體存取會呼叫 <code>panic!</code> 的主要原因。嘗試取得不屬於當前資料結構的記憶體是常見的安全問題。函式通常都會訂下一些<strong>合約（contracts）</strong>，它們的行為只有在輸入資料符合特定要求時才帶有保障。當違反合約時恐慌是十分合理的，因為違反合約就代表這是呼叫者的錯誤，這不是你的程式碼該主動處理的錯誤。事實上，呼叫者也沒有任何合理的理由來復原這樣的錯誤。函式的合約應該要寫在函式的技術文件中解釋，尤其是違反時會恐慌的情況。</p>
<p>然而要在你的函式寫一大堆錯誤檢查有時是很冗長且麻煩的。幸運的是你可以利用 Rust 的型別系統（以及編譯器的型別檢查）來幫你完成檢驗。如果你的函式用特定型別作為參數的話，你就可以認定你的程式邏輯是編輯器已經幫你確保你拿到的數值是有效的。舉例來說，如果你有一個型別而非 <code>Option</code> 的話，你的程式就會預期取得<strong>某個值</strong>而不是<strong>沒拿到值</strong>。你的程式就不必處理 <code>Some</code> 和 <code>None</code> 這兩個變體情形，它只會有一種情況並絕對會拿到數值。要是有人沒有傳遞任何值給你的函式會根本無法編譯，所以你的函式就不需要在執行時做檢查。另一個例子是使用非帶號整數像是 <code>u32</code> 來確保參數不會是負數。</p>
<h3 id="建立自訂型別來驗證"><a class="header" href="#建立自訂型別來驗證">建立自訂型別來驗證</a></h3>
<p>讓我們來試著使用 Rust 的型別系統來進一步確保我們擁有有效數值，並建立自訂型別來驗證。回想一下第二章的猜謎遊戲，我們的程式碼要使用者從 1 到 100 之間猜一個數字。在開始與祕密數字做比較之前，我們從未驗證使用者輸入的值，我們只驗證了它是否為正的。在這種情況帶來的後果還不算嚴重：我們還是會顯示「太大」或「太小」。但是我們可以改善這段來引導使用者輸入有效數值，並在使用者輸入時猜了超出範圍的數字或字母時呈現不同行為。</p>
<p>我們可以將輸入的猜測分析改成 <code>i32</code> 而非 <code>u32</code> 來允許負數，並檢查數字是否在範圍內，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span>    loop {
        // --省略--

<span class="boring">        println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;讀取行數失敗&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;祕密數字介於 1 到 100 之間。&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --省略--
<span class="boring">            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;獲勝！&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<p><code>if</code> 表達式檢查我們的數值是否超出範圍，如果是的話就告訴使用者問題原因，並呼叫 <code>continue</code> 來進行下一次的猜測循環，要求再猜一次。在 <code>if</code> 表達式之後我們就能用已經知道範圍是在 1 到 100 的 <code>guess</code> 與祕密數字做比較。</p>
<p>不過這並非理想解決方案：如果程式必定要求數值一定要是 1 到 100，而且我們有很多函式都有此需求的話，在每個函式都檢查就太囉唆了（而且可能會影響效能）。</p>
<p>對此我們可以建立一個新的型別，並且建立一個驗證產生實例的函式，這樣我們就不必在每個地方都做驗證。這樣一來函式就可以安全地以這個新型別作為簽名，並放心地使用收到的數值。範例 9-13 顯示了定義 <code>Guess</code> 型別的例子，它的 <code>new</code> 函式只會在接收值為 1 到 100 時才會建立 <code>Guess</code> 實例。</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;猜測數字必須介於 1 到 100 之間，你輸入的是 {}。&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-13：只會擁有 1 到 100 的 <code>Guess</code> 型別</span></p>
<p>首先我們定義了一個結構體叫做 <code>Guess</code>，其欄位叫做 <code>value</code> 並會持有 <code>i32</code>。這就是數字會被儲存的地方。</p>
<p>接著我們實作一個 <code>Guess</code> 的關聯函式叫做 <code>new</code> 來建立 <code>Guess</code> 的值。<code>new</code> 函式定義的參數叫做 <code>value</code> 並擁有型別 <code>i32</code>，且最後會回傳 <code>Guess</code>。函式 <code>new</code> 本體中的程式碼會驗證 <code>value</code> 確保它位於 1 到 100 之間。如果 <code>value</code> 沒有通過驗證，我們呼叫 <code>panic!</code> 來警告呼叫此程式碼的開發者，他們可能有需要修正的程式錯誤，因為使用超出範圍的 <code>value</code> 來建立 <code>Guess</code> 違反了 <code>Guess::new</code> 的合約。<code>Guess::new</code> 會恐慌的情況需要在公開的 API 技術文件中提及。我們會在第十四章討論如何寫出技術文件並在 API 技術文件中指出可能發生 <code>panic!</code> 的情形。如果 <code>value</code> 通過驗證的話，我們就建立一個新的 <code>Guess</code> 並將參數 <code>value</code> 賦值給 <code>value</code> 欄位，最後回傳 <code>Guess</code>。</p>
<p>接著我們實作了個方法叫做 <code>value</code>，它會借用 <code>self</code> 且沒有任何參數，並會回傳 <code>i32</code>。這種方法有時會被稱為 <em>getter</em>，因為它的目的是從它的欄位中取得一些資料並回傳它。此公開方法是必要的，因為 <code>Guess</code> 結構體中的 <code>value</code> 欄位是私有的。將 <code>Guess</code> 結構體的 <code>value</code> 欄位設為私有是很重要的，這樣就無法直接設置 <code>value</code> ，模組外的程式碼<strong>必須</strong>使用 <code>Guess::new</code> 函式來建立 <code>Guess</code> 的實例，因而確保 <code>Guess</code> 不可能會有沒有經過 <code>Guess::new</code> 函式驗證的 <code>value</code>。</p>
<p>這樣當函式的參數或回傳值只能是數字 1 到 100 的話，它的簽名就能使用或回傳 <code>Guess</code> 而不是 <code>i32</code>，因此就不必在它的本體內做任何額外檢查。</p>
<h2 id="總結-8"><a class="header" href="#總結-8">總結</a></h2>
<p>Rust 的錯誤檢查功能的設計旨在協助你寫出可靠的程式碼。<code>panic!</code> 巨集告訴你的程式遇到了它無法處理的狀態，並讓你告訴程序停止，而不是繼續嘗試使用無效或不正確的數值。<code>Result</code> 枚舉使用 Rust 的型別系統來指出可能會失敗的運算，並讓你的程式碼有辦法恢復。你可以使用 <code>Result</code> 來告訴使用你的程式碼的呼叫者，他們需要處理可能成功與失敗的情形。在適當的場合使用 <code>panic!</code> 與 <code>Result</code> 能讓你的程式碼在不可避免的問題中更加可靠。</p>
<p>現在你已經看過標準函式庫中 <code>Option</code> 與 <code>Result</code> 使用泛型的優勢了，就讓我們來討論泛型如何運作的，以及你如何在程式碼中使用它們。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型型別特徵與生命週期"><a class="header" href="#泛型型別特徵與生命週期">泛型型別、特徵與生命週期</a></h1>
<p>每個程式語言都有能夠高效處理概念複製的工具。在 Rust 此工具就是<strong>泛型（generics）</strong>：實際型別或其他屬性的抽象替代。我們可以表達泛型的行為，或是它們與其他泛型有何關聯，而不必在編譯與執行程式時知道它們實際上是什麼。</p>
<p>函式也可以接受一些泛型型別參數，而不是實際型別像是 <code>i32</code> 或 <code>String</code>，就像函式有辦法能接收多種未知數值作為參數來執行相同程式碼。事實上我們已經在第六章的 <code>Option&lt;T&gt;</code>、第八章的 <code>Vec&lt;T&gt;</code> 和 <code>HashMap&lt;K, V&gt;</code> 以及第九章的 <code>Result&lt;T, E&gt;</code> 使用過泛型了。在本章節，你將會探索如何用泛型定義你自己的型別、函式與方法！</p>
<p>首先我們會先檢視如何提取參數來減少重複的程式碼。接著我們會以相同的技巧使用泛型將兩個只有參數型別不同的函式轉變成泛型函式。我們還會解釋如何在結構體和枚舉使用泛型型別。</p>
<p>再來你會學會如何使用**特徵（traits）**來定義共同行為。你可以組合特徵與泛型型別來限制泛型型別只適用在有特定行為的型別，而不是任意型別。</p>
<p>最後我們會來介紹<strong>生命週期（lifetimes）</strong>：一種能讓編譯器知道參考如何互相關聯的泛型。生命週期讓我們能提供給編譯器更多關於借用數值的資訊，好讓它在更多情況下可以確保參考是有效的。</p>
<h2 id="提取函數來減少重複性"><a class="header" href="#提取函數來減少重複性">提取函數來減少重複性</a></h2>
<p>泛型讓我們可以用佔位符（placeholder）替代特定型別，來表示多重型別並減少程式碼的重複性。在我們深入泛型語法之前，讓我們先來看如何不用泛型型別的情況下，用提取函式的方式減少重複的程式碼。之後我們就會用相同的方式來提取泛型函式！和你透過找出重複的程式碼來提取程式一樣，你也將找出重複的函式來轉成泛型。</p>
<p>我們先從範例 10-1 中一支尋找列表中最大數字的小程式開始。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;最大數字為 {}&quot;, largest);
<span class="boring">    assert_eq!(*largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-1：在數字列表中尋找最大數字的程式碼</span></p>
<p>我們儲存整數列表到變數 <code>number_list</code> 並將列表第一個數字的參考放入變數 <code>largest</code>。接著我們遍歷列表中的所有元素，如果目前數字比 <code>largest</code> 內儲存的數字還大的話，就會替代成該變數的參考。不過如果目前數值小於或等於最大值的話，變數就不會被改變，程式會接續檢查列表中的下一個數字。在考慮完列表中的所有數字後，<code>largest</code> 就應該會指向最大數字，在此例就是 100。</p>
<p>現在我們要從兩個不同的數字列表中找到最大值，我們可以重複範例 10-1 的程式碼，然後在程式中兩個不同的地方使用相同的邏輯，如範例 10-2 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;最大數字為 {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &amp;number_list[0];

    for number in &amp;number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;最大數字為 {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">範例 10-2：在<strong>兩個</strong>數字列表中尋找最大值</span></p>
<p>雖然這樣的程式碼能執行，寫出重複的程式碼很囉唆而且容易出錯。我們還得記住每次更新時就得一起更新的各個地方。</p>
<p>要去除重複的部分，我們可以建立一層抽象，定義一個可以處理任意整數列表作為參數的函式。這樣的解決辦法讓我們的程式更清晰，而且讓我們能抽象表達出從列表中尋找最大值這樣的概念。</p>
<p>在範例 10-3 我們提取了尋找最大值的程式碼成一個函式叫做 <code>largest</code>。然後我們呼叫函式來尋找範例 10-2 兩個列表中最大的數字。我們還可以在未來對其他任何 <code>i32</code> 的列表使用此函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;最大數字為 {}&quot;, result);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;最大數字為 {}&quot;, result);
<span class="boring">    assert_eq!(*result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-3：抽象出尋找最大值的概念並用在兩個不同的列表</span></p>
<p><code>largest</code> 函式有個參數 <code>list</code> 可以代表我們傳遞給函式的 <code>i32</code> 型別切片。所以當我們呼叫此函式時，程式可以依據我們傳入的特定數值執行。</p>
<p>總結來說，以下是我們將範例 10-2 的程式碼轉換成範例 10-3 的步驟：</p>
<ol>
<li>找出重複的程式碼。</li>
<li>將重複的程式碼提取置函式本體內，並指定函式簽名輸入與回傳數值。</li>
<li>更新重複使用程式碼的實例，改呼叫我們定義的函式。</li>
</ol>
<p>接著我們將以相同的步驟來使用泛型來減少重複的程式碼。就像函式本體可以抽象出 <code>list</code> 而不用特定數值，泛型允許程式碼執行抽象型別。</p>
<p>舉例來說，假設我們有兩個函式：一個會找出 <code>i32</code> 型別切片中的最大值而另一個會找出 <code>char</code> 型別切片的最大值。我們要如何刪除重複的部分呢？讓我們拭目以待！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="泛型資料型別"><a class="header" href="#泛型資料型別">泛型資料型別</a></h2>
<p>我們使用泛型（generics）來建立項目的定義，像是函式簽名或結構體，讓我們在之後可以使用在不同的實際資料型別。讓我們先看看如何使用泛型定義函式、枚舉與方法。然後我們會在來看泛型對程式碼的效能影響如何。</p>
<h3 id="在函式中定義"><a class="header" href="#在函式中定義">在函式中定義</a></h3>
<p>當要使用泛型定義函數時，我們通常會將泛型置於函式簽名中指定參數與回傳值資料型別的位置。這樣做能讓我們的程式碼更具彈性並向呼叫者提供更多功能，同時還能防止重複程式碼。</p>
<p>接續我們 <code>largest</code> 函式的例子，範例 10-4 展示了兩個都在切片上尋找最大值的函式。我們要使用泛型將它們融合成一個函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;最大數字為 {}&quot;, result);
<span class="boring">    assert_eq!(*result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;最大字元為 {}&quot;, result);
<span class="boring">    assert_eq!(*result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-4：兩個名稱與其簽名中的型別都不同的函式</span></p>
<p><code>largest_i32</code> 函式和我們在範例 10-3 提取的函式一樣都是尋找切片中最大的 <code>i32</code>。而 <code>largest_char</code> 函式則尋找切片中最大的 <code>char</code>。函式本體都擁有相同的程式碼，讓我以讓我們來開始用泛型型別參數來消除重複的部分，轉變成只有一個函式吧。</p>
<p>要在新定義的函式中參數化型別的話，我們需要為參數型別命名，就和我們在函式中的參數數值所做的一樣。你可以用任何標識符來命名型別參數名稱。但我們習慣上會用 <code>T</code>，因為 Rust 的型別參數名稱都盡量很短，常常只會有一個字母，而且 Rust 對於型別命名的慣用規則是駝峰式大小寫（CamelCase）。所以 <code>T</code> 作為「type」的簡稱是大多數 Rust 程式設計師的選擇。</p>
<p>當我們在函式本體使用參數時，我們必須在簽名中宣告參數名稱，編譯器才能知道該名稱代表什麼。同樣地，當我們要在函式簽名中使用型別參數名稱，我們必須在使用前宣告該型別參數名稱。要定義泛型 <code>largest</code> 函式的話，我們在函式名稱與參數列表之間加上尖括號，其內就是型別名稱的宣告，如以下所示：</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
</code></pre>
<p>我們可以這樣理解定義：函式 <code>largest</code> 有泛型型別 <code>T</code>，此函式有一個參數叫做 <code>list</code>，它的型別為數值 <code>T</code> 的切片。<code>largest</code> 函式會回傳與型別 <code>T</code> 相同型別的參考數值。</p>
<p>範例 10-5 顯示了使用泛型資料型別於函式簽名組合出的 <code>largest</code> 函式。此範例還展示了我們如何依序用 <code>i32</code> 和 <code>char</code> 的切片呼叫函式。注意此程式碼尚未能編譯，不過我們會在本章之後修改它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;最大數字為 {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;最大字元為 {}&quot;, result);
}
</code></pre>
<p><span class="caption">範例 10-5：使用泛型型別參數的 <code>largest</code> 函式，但現在還不能編譯</span></p>
<p>如果我們現在就編譯程式碼的話，我們會得到此錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- &amp;T
  |            |
  |            &amp;T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>提示文字中提到了 <code>std::cmp::PartialOrd</code> 這個<strong>特徵（trait）</strong>。我們會在下個段落來討論特徵。現在只需要知道 <code>largest</code> 本體無法適用於所有可能的 <code>T</code> 型別，因為我們想要在本體中比較型別 <code>T</code> 的數值，我們只能在能夠排序的型別中做比較。要能夠比較的話，標準函式庫有提供 <code>std::cmp::PartialOrd</code> 特徵讓你可以針對你的型別來實作（請查閱附錄 C 來瞭解更多此特徵的細節）。照著提示文字的建議，我們限制 <code>T</code> 只對有實作 <code>PartialOrd</code> 的型別有效。這樣此範例就能編譯，因為標準函式庫有對 <code>i32</code> 與 <code>char</code> 實作 <code>PartialOrd</code>。</p>
<h3 id="在結構體中定義"><a class="header" href="#在結構體中定義">在結構體中定義</a></h3>
<p>我們一樣能以 <code>&lt;&gt;</code> 語法來對結構體中一或多個欄位使用泛型型別參數。範例 10-6 展示了定義 <code>Point&lt;T&gt;</code> 結構體並讓 <code>x</code> 與 <code>y</code> 可以是任意型別數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">範例 10-6：<code>Point&lt;T&gt;</code> 結構體的 <code>x</code> 與 <code>y</code> 會有型別 <code>T</code> 的數值</span></p>
<p>在結構體定義使用泛型的語法與函式定義類似。首先，我們在結構體名稱後方加上尖括號，並在其內宣告型別參數名稱。接著我們能在原本指定實際資料型別的地方，使用泛型型別來定義結構體。</p>
<p>注意到我們使用了一個泛型型別來定義 <code>Point&lt;T&gt;</code>，此定義代表 <code>Point&lt;T&gt;</code> 是某型別 <code>T</code> 下之通用的，而且欄位 <code>x</code> 與 <code>y</code> 擁有<strong>相同</strong>型別，無論最終是何種型別。如果我們用不同的型別數值來建立 <code>Point&lt;T&gt;</code> 實例，我們的程式碼會無法編譯，如範例 10-7 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">範例 10-7：欄位 <code>x</code> 與 <code>y</code> 必須是相同型別，因為它們擁有相同的泛型資料型別 <code>T</code></span></p>
<p>在此例中，當我們賦值 5 給 <code>x</code> 時，我們讓編譯器知道 <code>Point&lt;T&gt;</code> 實例中的泛型型別 <code>T</code> 會是整數。然後我們將 4.0 賦值給 <code>y</code>，這應該要和 <code>x</code> 有相同型別，所以我們會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>要將結構體 <code>Point</code> 的 <code>x</code> 與 <code>y</code> 定義成擁有不同型別卻仍然是泛型的話，我們可以使用多個泛型型別參數。舉例來說，在範例 10-8 我們改變了 <code>Point</code> 的定義為擁有兩個泛型型別 <code>T</code> 與 <code>U</code>，<code>x</code> 擁有型別 <code>T</code> 而 <code>y</code> 擁有型別 <code>U</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">範例 10-8：<code>Point&lt;T, U&gt;</code> 擁有兩個泛型型別，所以 <code>x</code> 和 <code>y</code> 可以有不同的型別數值</span></p>
<p>現在這些所有的 <code>Point</code> 實例都是允許的了！你要在定義中使用多少泛型型別參數都沒問題，但用太多的話會讓你的程式碼難以閱讀。如果你發現你的程式碼需要使用大量泛型的話，這通常代表你的程式碼需要重新組織成更小的元件。</p>
<h3 id="在枚舉中定義"><a class="header" href="#在枚舉中定義">在枚舉中定義</a></h3>
<p>如同結構體一樣，我們可以定義枚舉讓它們的變體擁有泛型資料型別。讓我們看看我們在第六章標準函式庫提供的 <code>Option&lt;T&gt;</code> 枚舉：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>此定義現在對你來說應該就說得通了。如同你所看到的 <code>Option&lt;T&gt;</code> 枚舉有個泛型型別參數 <code>T</code> 以及兩個變體：<code>Some</code> 擁有型別 <code>T</code> 的數值；而 <code>None</code> 則是不具任何數值的變體。使用 <code>Option&lt;T&gt;</code> 枚舉我們可以表達出一個可能擁有的數值這樣的抽象概念。而且因為 <code>Option&lt;T&gt;</code> 是泛型，不管可能的數值型別為何，我們都能使用此抽象。</p>
<p>枚舉也能有數個泛型型別。我們在第九章所使用枚舉 <code>Result</code> 的定義就是個例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code> 枚舉有兩個泛型型別 <code>T</code> 和 <code>E</code> 且有兩個變體：<code>Ok</code> 擁有型別 <code>T</code> 的數值；而 <code>Err</code> 擁有型別 <code>E</code> 的數值。這樣的定義讓我們很方便能表達 <code>Result</code> 枚舉可能擁有一個成功的數值（回傳型別 <code>T</code> 的數值）或失敗的數值（回傳型別為 <code>E</code> 的錯誤值）。事實上這就是我們在範例 9-3 開啟檔案的方式，當我們成功開啟檔案時的 <code>T</code> 就會是型別 <code>std::fs::File</code>，然後當開啟檔案會發生問題時 <code>E</code> 就會是型別 <code>std::io::Error</code>。</p>
<p>當你發現你的程式碼有許多結構體或枚舉都只有儲存的值有所不同時，你可以使用泛型型別來避免重複。</p>
<h3 id="在方法中定義"><a class="header" href="#在方法中定義">在方法中定義</a></h3>
<p>我們可以對結構體或枚舉定義方法（如第五章所述）並也可以使用泛型型別來定義。範例 10-9 展示了我們在範例 10-6 定義的結構體 <code>Point&lt;T&gt;</code> 並實作了一個叫做 <code>x</code> 的方法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">範例 10-9：在 <code>Point&lt;T&gt;</code> 結構體實作一個方法叫做 <code>x</code>，其會回傳 <code>x</code> 欄位中型別為 <code>T</code> 的參考</span></p>
<p>我們在這 <code>Point&lt;T&gt;</code> 定義了一個方法叫做 <code>x</code> 並回傳欄位 <code>x</code> 的資料參考。</p>
<p>注意到我們需要在 <code>impl</code> 宣告 <code>T</code>，才有 <code>T</code> 可以用來標明我們在替型別 <code>Point&lt;T&gt;</code> 實作其方法。在 <code>impl</code> 之後宣告泛型型別 <code>T</code>，Rust 可以識別出 <code>Point</code> 尖括號內的型別為泛型型別而非實際型別。我們其實可以選用不同的泛型參數名稱，而不用和結構體定義的泛型參數一樣，不過通常使用相同名稱還是比較常見。無論該泛型型別最終會是何種實際型別，任何方法在有宣告泛型型別的 <code>impl</code> 內，都會被定義成適用於各種型別實例。 </p>
<p>當我們在定義方法時，我們也可以對泛型型別加上些限制。舉例來說，我們可以只針對 <code>Point&lt;f32&gt;</code> 的實例來實作方法，而非適用於任何泛型型別的 <code>Point&lt;T&gt;</code> 實例。在範例 10-10 我們使用了實例型別 <code>f32</code> 而沒有在 <code>impl</code> 宣告任何型別。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-10：一個只適用於擁有泛型 <code>T</code> 結構體其中的特定實際型別的 <code>impl</code> 區塊</span></p>
<p>此程式碼代表 <code>Point&lt;f32&gt;</code> 會有個方法 <code>distance_from_origin</code>，其他 <code>Point&lt;T&gt;</code> 只要 <code>T</code> 不是型別 <code>f32</code> 的實例都不會定義此方法。此方法測量我們的點距離座標 (0.0, 0.0) 有多遠並使用只有浮點數型別能使用的數學運算。</p>
<p>在結構體定義中的泛型型別參數不會總是和結構體方法簽名中的相同。舉例來說，範例 10-11 在 <code>Point</code> 結構體中使用泛型型別 <code>X1</code> 和 <code>Y1</code>，但在 <code>mixup</code> 方法中就使用 <code>X2</code> <code>Y2</code> 以便清楚辨別。該方法用 <code>self</code> <code>Point</code> 的 <code>x</code> 值（型別為 <code>X1</code>）與參數傳進來的 <code>Point</code> 的 <code>y</code> 值（型別為 <code>Y2</code>）來建立新的 <code>Point</code> 實例。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">範例 10-11：結構體定義中使用不同的泛型型別的方法</span></p>
<p>在 <code>main</code> 中，我們定義了一個 <code>Point</code>，其 <code>x</code> 型別為 <code>i32</code>（數值為 <code>5</code>），<code>y</code> 型別為 <code>f64</code>（數值為 <code>10.4</code>）。變數 <code>p2</code> 是個 <code>Point</code> 結構體，<code>x</code> 為字串切片（數值為 <code>&quot;Hello&quot;</code>），<code>y</code> 為 <code>char</code>（數值為 <code>c</code>）。在 <code>p1</code> 呼叫 <code>mixup</code> 並加上引數 <code>p2</code> 的話會給我們 <code>p3</code>，它的 <code>x</code> 會有型別 <code>i32</code>，因為 <code>x</code> 來自 <code>p1</code>。而且變數 <code>p3</code> 還會有型別為 <code>char</code> 的 <code>y</code>，因為 <code>y</code> 來自 <code>p2</code>。<code>println!</code> 巨集的呼叫就會顯示 <code>p3.x = 5, p3.y = c</code>。</p>
<p>此例是是為了展示一些泛型參數是透過 <code>impl</code> 宣告而有些則是透過方法定義來取得。泛型參數 <code>X1</code> 和 <code>Y1</code> 是宣告在 <code>impl</code> 之後，因為它們與結構體定義有關聯。泛型參數 <code>X2</code> 和 <code>Y2</code> 則是宣告在 <code>fn mixup</code> 之後，因為它們只與方法定義有關聯。</p>
<h3 id="使用泛型的程式碼效能"><a class="header" href="#使用泛型的程式碼效能">使用泛型的程式碼效能</a></h3>
<p>你可能會好奇當你使用泛型型別參數會不會有執行時的消耗。好消息是使用泛型型別不會比使用實際型別還來的慢。</p>
<p>Rust 在編譯時對使用泛型的程式碼進行單態化（monomorphization）。<strong>單態化</strong>是個讓泛型程式碼轉換成特定程式碼的過程，在編譯時填入實際的型別。在此過程中，編譯器會做與我們在範例 10-5 建立泛型函式相反的事：編譯器檢查所有泛型程式碼被呼叫的地方，並依據泛型程式碼被呼叫的情況產生實際型別的程式碼。</p>
<p>讓我們看看這在標準函式庫的泛型枚舉 <code>Option&lt;T&gt;</code> 中是怎麼做到的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>當 Rust 編譯此程式碼時中，他會進行單態化。在此過程中，會讀取 <code>Option&lt;T&gt;</code> 實例中使用的數值並識別出兩種 <code>Option&lt;T&gt;</code>：一種是 <code>i32</code> 而另一種是 <code>f64</code>。接著它就會將 <code>Option&lt;T&gt;</code> 的泛型定義展開為兩種定義 <code>i32</code> 與 <code>f64</code>，以此替換函式定義為特定型別。</p>
<p>單態化的版本看起來會像這樣（編譯器實際使用的名稱會和我們這邊示範的不同）：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>泛型 <code>Option&lt;T&gt;</code> 會被替換成編譯器定義的特定定義。因為 Rust 會編譯泛型程式碼成個別實例的特定型別，我們使用泛型就不會造成任何執行時消耗。當程式執行時，它就會和我們親自寫重複定義的版本一樣。單態化的過程讓 Rust 的泛型在執行時十分有效率。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="特徵定義共同行為"><a class="header" href="#特徵定義共同行為">特徵：定義共同行為</a></h2>
<p><strong>特徵</strong>（trait）會定義特定型別與其他型別共享的功能。我們可以使用特徵定義來抽象出共同行為。我們可以使用<strong>特徵界限</strong>（trait bounds）來指定泛型型別為擁有特定行為的任意型別。</p>
<blockquote>
<p>注意：特徵類似於其他語言常稱作<strong>介面</strong>（interfaces）的功能，但還是有些差異。</p>
</blockquote>
<h3 id="定義特徵"><a class="header" href="#定義特徵">定義特徵</a></h3>
<p>一個型別的行為包含我們對該型別可以呼叫的方法。如果我們可以對不同型別呼叫相同的方法，這些型別就能定義共同行為了。特徵定義是一個將方法簽名統整起來，來達成一些目的而定義一系列行為的方法。</p>
<p>舉例來說，如果我們有數個結構體各自擁有不同種類與不同數量的文字：結構體 <code>NewsArticle</code> 儲存特定地點的新聞故事，然後 <code>Tweet</code> 則有最多 280 字元的內容，且有個欄位來判斷是全新的推文、轉推或其他推文的回覆。</p>
<p>我們想要建立個多媒體資料庫來顯示可能存在 <code>NewsArticle</code> 或 <code>Tweet</code> 實例的資料總結。要達成此目的的話，我們需要每個型別的總結，且我們會呼叫該實例的 <code>summarize</code> 方法來索取總結。範例 10-12 顯示了表達此行為的 <code>Summary</code> 特徵定義。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p><span class="caption">範例 10-12：<code>Summary</code> 特徵包含 <code>summarize</code> 方法所定義的行為</span></p>
<p>我們在此使用 <code>trait</code> 關鍵字定義一個特徵，其名稱為 <code>Summary</code>。我們也將特徵宣告成 <code>pub</code> 所以其他會依賴此函式庫的 crate 也能用到此特徵，我們之後會在看到其他範例。在大括號中，我們宣告方法簽名來描述有實作此特徵的型別行為，在此例就是 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>在方法簽名之後，我們並沒有加上大括號提供實作細節，而是使用分號。每個有實作此特徵的型別必須提供其自訂行為的方法本體。編譯器會強制要求任何有 <code>Summary</code> 特徵的型別都要有定義相同簽名的 <code>summarize</code> 方法。</p>
<p>特徵本體中可以有多個方法，每行會有一個方法簽名並都以分號做結尾。</p>
<h3 id="為型別實作特徵"><a class="header" href="#為型別實作特徵">為型別實作特徵</a></h3>
<p>現在我們已經用 <code>Summary</code> 特徵定義了所需的方法簽名。我們可以在我們多媒體資料庫的型別中實作它。範例 10-13 顯示了 <code>NewsArticle</code> 結構體實作 <code>Summary</code> 特徵的方式，其使用頭條、作者、位置來建立 <code>summerize</code> 的回傳值。至於結構體 <code>Tweet</code>，我們使用使用者名稱加上整個推文的文字來定義 <code>summarize</code>，因為推文的內容長度已經被限制在 280 個字元以內了。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{} {} 著 ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<p><span class="caption">範例 10-13：在型別 <code>NewsArticle</code> 與 <code>Tweet</code> 實作 <code>Summary</code> 特徵</span></p>
<p>為一個型別實作一個特徵類似於實作一般的方法。不同的地方在於在 <code>impl</code> 之後我們加上的是想要實作的特徵，然後在用 <code>for</code> 關鍵字加上我們想要實作特徵的型別名稱。在 <code>impl</code> 的區塊內我們置入該特徵所定義的方法簽名，我們使用大括號並填入方法本體來為對特定型別實作出特徵方法的指定行為。</p>
<p>現在，我們就能像呼叫正常方法一樣，來呼叫 <code>NewsArticle</code> 和 <code>Tweet</code> 實例的方法，如以下所示：
現在函式庫已經對 <code>NewsArticle</code> 和 <code>Tweet</code> 實作 <code>Summary</code> 特徵了，crate 的使用者能像我們平常呼叫方法那樣，對 <code>NewsArticle</code> 和 <code>Tweet</code> 的實例呼叫特徵方法。唯一的不同是使用者必須將特徵也加入作用域中。以下的範例展示執行檔 crate 如何使用我們的 <code>aggregator</code> 函式庫 crate：</p>
<pre><code class="language-rust ignore">use aggregator::{self, Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 則新推文：{}&quot;, tweet.summarize());
}
</code></pre>
<p>此程式碼會印出「1 則新推文：horse_ebooks: of course, as you probably already know, people」。</p>
<p>其他依賴 <code>aggregator</code> 函式庫的 crate 也能將 <code>Summary</code> 特徵引入作用域並對他們自己的型別實作 <code>Summary</code> 特徵。不過實作特徵時有一個限制，那就是我們只能在該特徵或該型別位於我們的 crate 時，才能對型別實作特徵。舉例來說，我們可以對自訂型別像是 <code>Tweet</code> 來實作標準函式庫的 <code>Display</code> 特徵來為我們 crate <code>aggregator</code> 增加更多功能。因為 <code>Tweet</code> 位於我們的 <code>aggregator</code> crate 裡面。我們也可以在我們的 crate <code>aggregator</code> 內對 <code>Vec&lt;T&gt;</code> 實作 <code>Summary</code>。因為特徵 <code>Summary</code> 也位於我們的 <code>aggregator</code> crate 裡面。</p>
<p>但是我們無法對外部型別實作外部特徵。舉例來說我們無法在我們的 <code>aggregator</code> crate 裡面對 <code>Vec&lt;T&gt;</code> 實作 <code>Display</code> 特徵。因為 <code>Display</code> 與 <code>Vec&lt;T&gt;</code> 都定義在標準函式庫中，並沒有在我們 <code>aggregator</code> crate 裡面。此限制叫做「連貫性（coherence）」是程式屬性的一部分。更具體來說我們會稱作「孤兒原則（orphan rule）」，因為上一代（parent）型別不存在。此原則能確保其他人的程式碼不會破壞你的程式碼，反之亦然。沒有此原則的話，兩個 crate 可以都對相同型別實作相同特徵，然後 Rust 就會不知道該用哪個實作。</p>
<h3 id="預設實作"><a class="header" href="#預設實作">預設實作</a></h3>
<p>有時候對特徵內的一些或所有方法定義預設行為是很實用的，而不必要求每個型別都實作所有方法。然後當我們對特定型別實作特徵時，我們可以保留或覆蓋每個方法的預設行為。</p>
<p>在範例 10-14 我們在 <code>Summary</code> 特徵內指定  <code>summarize</code> 方法的預設字串，而不必像範例 10-12 只定義了方法簽名。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(閱讀更多...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 10-14：<code>Summary</code> 特徵定義了 <code>summarize</code> 方法的預設實作</span></p>
<p>要使用預設實作來總結 <code>NewsArticle</code> 的話，我們可以指定一個空的 <code>impl</code> 區塊，像是 <code>impl Summary for NewsArticle {}</code>。</p>
<p>我們沒有直接對 <code>NewsArticle</code> 定義 <code>summarize</code> 方法，因為我們使用的是預設實作並聲明對 <code>NewsArticle</code> 實作 <code>Summary</code> 特徵。所以最後我們仍然能在 <code>NewsArticle</code> 實例中呼叫 <code>summarize</code>，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;有新文章發佈！{}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>此程式碼會印出 <code>有新文章發佈！(閱讀更多...)</code>。</p>
<p>建立預設實作不會影響範例 10-13 中 <code>Tweet</code> 實作的 <code>Summary</code>。因為要取代預設實作的語法，與當沒有預設實作時實作特徵方法的語法是一樣的。</p>
<p>預設實作也能呼叫同特徵中的其他方法，就算那些方法沒有預設實作。這樣一來，特徵就可以提供一堆實用的功能，並要求實作者只需處理一小部分就好。舉例來說，我們可以定義 <code>Summary</code> 特徵，使其擁有一個必須要實作的<code>summarize_author</code> 方法，以及另一個擁有預設實作會呼叫 <code>summarize_author</code> 的方法：</p>
<pre><code class="language-rust noplayground">pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(從 {} 閱讀更多...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>要使用這個版本的 <code>Summary</code>，我們只需要在對型別實作特徵時定義 <code>summarize_author</code> 就好：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(從 {} 閱讀更多...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>在我們定義 <code>summarize_author</code> 之後，我們可以在結構體 <code>Tweet</code> 的實例呼叫 <code>summarize</code>，然後 <code>summarize</code> 的預設實作會呼叫我們提供的 <code>summarize_author</code>。因為我們已經定義了<code>summarize_author</code>，且 <code>Summary</code> 特徵有提供 <code>summarize</code> 方法的預設實作，所以我們不必再寫任何程式碼。</p>
<pre><code class="language-rust ignore"><span class="boring">use aggregator::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 則新推文：{}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>此程式碼會印出 <code>1 則新推文：(從 @horse_ebooks 閱讀更多...)</code>。</p>
<p>注意要是對相同方法覆寫實作的話，就無法呼叫預設實作。</p>
<h3 id="特徵作為參數"><a class="header" href="#特徵作為參數">特徵作為參數</a></h3>
<p>現在你知道如何定義與實作特徵，我們可以來探討如何使用特徵來定義函式來接受多種不同的型別。我們會使用範例 10-13 中 <code>NewsArticle</code> 與 <code>Tweet</code> 實作的 <code>Summary</code> 特徵，來定義一個函式 <code>notify</code> 使用它自己的參數 <code>item</code> 來呼叫 <code>summarize</code> 方法，所以此參數的型別預期有實作 <code>Summary</code> 特徵。
為此我們可以使用 <code>impl Trait</code> 語法，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} {} 著 ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;頭條新聞！{}&quot;, item.summarize());
}
</code></pre>
<p>與其在 <code>item</code> 參數指定實際型別，我們用的是 <code>impl</code> 關鍵字並加上特徵名稱。這樣此參數就會接受任何有實作指定特徵的型別。在 <code>notify</code> 本體中我們就可以用 <code>item</code> 呼叫 <code>Summary</code> 特徵的任何方法，像是 <code>summarize</code>。我們可以呼叫 <code>notify</code> 並傳遞任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的實例。但如果用其他型別像是 <code>String</code> 或 <code>i32</code> 來呼叫此程式碼的話會無法編譯，因為那些型別沒有實作 <code>Summary</code>。</p>
<h4 id="特徵界限語法"><a class="header" href="#特徵界限語法">特徵界限語法</a></h4>
<p><code>impl Trait</code> 語法看起來很直觀，不過它其實是一個更長格式的語法糖，這個格式稱之為「特徵界限（trait bound）」，它長得會像這樣：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;頭條新聞！{}&quot;, item.summarize());
}
</code></pre>
<p>此格式等同於之前段落的範例，只是比較長一點。我們將特徵界限置於泛型型別參數的宣告中，在尖括號內接在冒號之後。</p>
<p><code>impl Trait</code> 語法比較方便，且在簡單的案例中可以讓程式碼比較簡潔；而特徵界限語法則適合用於其他比較複雜的案例。舉例來說我們可以有兩個有實作 <code>Summary</code> 的參數，使用 <code>impl Trait</code> 語法看起來會像這樣：</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>如果我們想要此函式允許 <code>item1</code> 和 <code>item2</code> 是不同型別的話，使用 <code>impl Trait</code> 的確是正確的（只要它們都有實作 <code>Summary</code>）。不過如果我們希望兩個參數都是同一型別的話，我們就得使用特徵界限來表達，如以下所示：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>泛型型別 <code>T</code> 作為 <code>item1</code> 和 <code>item2</code> 的參數會限制函式，讓傳遞給 <code>item1</code> 和 <code>item2</code> 參數的數值型別必須相同。</p>
<h4 id="透過--來指定多個特徵界限"><a class="header" href="#透過--來指定多個特徵界限">透過 <code>+</code> 來指定多個特徵界限</a></h4>
<p>我們也可以指定不只一個特徵界限。假設我們還想要 <code>notify</code> 中的 <code>item</code> 不只能夠呼叫 <code>summarize</code> 方法，還能顯示格式化訊息的話，我們可以在 <code>notify</code> 定義中指定 <code>item</code> 必須同時要有 <code>Display</code> 和
<code>Summary</code>。這可以使用 <code>+</code> 語法來達成：</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p><code>+</code> 也能用在泛型型別的特徵界限中：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>有了這兩個特徵界限，<code>notify</code> 本體就能呼叫 <code>summarize</code> 以及使用 <code>{}</code> 來格式化 <code>item</code>。</p>
<h4 id="透過-where-來使特徵界限更清楚"><a class="header" href="#透過-where-來使特徵界限更清楚">透過 <code>where</code> 來使特徵界限更清楚</a></h4>
<p>使用太多特徵界限也會帶來壞處。每個泛型都有自己的特徵界限，所以有數個泛型型別的函式可以在函式名稱與參數列表之間包含大量的特徵界限資訊，讓函式簽名難以閱讀。因此 Rust 有提供另一個在函式簽名之後指定特徵界限的語法 <code>where</code>。所以與其這樣寫：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>我們可以這樣寫 <code>where</code> 的語法，如以下所示：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
<span class="boring">    unimplemented!()
</span><span class="boring">}
</span></code></pre>
<p>此函式簽名就沒有這麼複雜了，函式名稱、參數列表與回傳型別能靠得比較近，就像沒有一堆特徵界限的函式一樣。</p>
<h3 id="回傳有實作特徵的型別"><a class="header" href="#回傳有實作特徵的型別">回傳有實作特徵的型別</a></h3>
<p>我們也能在回傳的位置使用 <code>impl Trait</code> 語法來回傳某個有實作特徵的型別數值，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} {} 著 ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>將 <code>impl Summary</code> 作為回傳型別的同時，我們在函式 <code>returns_summarizable</code> 指定回傳有實作 <code>Summary</code> 特徵的型別而不必指出實際型別。在此例中，<code>returns_summarizable</code> 回傳 <code>Tweet</code>，但呼叫此函式的程式碼不需要知道。</p>
<p>回傳一個只有指定所需實作特徵的型別在閉包（closures）與疊代器（iterators）中非常有用，我們會在第十三章介紹它們。閉包與疊代器能建立只有編譯器知道的型別，或是太長而難以指定的型別。<code>impl Trait</code> 語法允許你不用寫出很長的型別，而是只要指定函數會回傳有實作 <code>Iterator</code> 特徵的型別就好。</p>
<p>然而如果你使用 <code>impl Trait</code> 的話，你就只能回傳單一型別。舉例來說此程式碼指定回傳型別為 <code>impl Summary</code> ，但是寫說可能會回傳 <code>NewsArticle</code> 或 <code>Tweet</code> 的話就會無法執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{} {} 著 ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>寫說可能回傳 <code>NewsArticle</code> 或 <code>Tweet</code> 的話是不被允許的，因為 <code>impl Trait</code> 語法會限制在編譯器中最終決定的型別。我們會在第十七章的<a href="ch17-02-trait-objects.html">「允許不同型別數值的特徵物件」</a><!-- ignore -->來討論如何寫出這種行為的函式。</p>
<h3 id="透過特徵界限來選擇性實作方法"><a class="header" href="#透過特徵界限來選擇性實作方法">透過特徵界限來選擇性實作方法</a></h3>
<p>在有使用泛型型別參數 <code>impl</code> 區塊中使用特徵界限，我們可以選擇性地對有實作特定特徵的型別來實作方法。舉例來說，範例 10-15 的 <code>Pair&lt;T&gt;</code> 對所有 <code>T</code> 實作了 <code>new</code> 函式來回傳新的 <code>Pair&lt;T&gt;</code> 實例（回想一下第五章的<a href="ch05-03-method-syntax.html#%E5%AE%9A%E7%BE%A9%E6%96%B9%E6%B3%95">「定義方法」</a><!-- ignore -->段落，<code>Self</code> 是 <code>impl</code> 區塊內的型別別名，在此例就是 <code>Pair&lt;T&gt;</code>）。但在下一個 <code>impl</code> 區塊中，只有在其內部型別 <code>T</code> 有實作能夠做比較的 <code>PartialOrd</code> 特徵<strong>以及</strong>能夠顯示在螢幕的 <code>Display</code> 特徵的話，才會實作 <code>cmp_display</code> 方法。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;最大的是 x = {}&quot;, self.x);
        } else {
            println!(&quot;最大的是 y = {}&quot;, self.y);
        }
    }
}
</code></pre>
<p><span class="caption">範例 10-15：依據特徵界限來選擇性地在泛型型別實作方法</span></p>
<p>我們還可以對有實作其他特徵的型別選擇性地來實作特徵。對滿足特徵界限的型別實作特徵會稱之為<strong>全面實作（blanket implementations）</strong>，這被廣泛地用在 Rust 標準函式庫中。舉例來說，標準函式庫會對任何有實作 <code>Display</code> 特徵的型別實作 <code>ToString</code>。標準函式庫中的 <code>impl</code> 區塊會有類似這樣的程式碼：</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --省略--
}
</code></pre>
<p>因為標準函式庫有此全面實作，我們可以在任何有實作 <code>Display</code> 特徵的型別呼叫 <code>ToString</code> 特徵的 <code>to_string</code> 方法。舉例來說，我們可以像這樣將整數轉變成對應的 <code>String</code> 數值，因為整數有實作 <code>Display</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>全面實作在特徵技術文件的「Implementors」段落有做說明。</p>
<p>特徵與特徵界限讓我們能使用泛型型別參數來減少重複的程式碼的同時，告訴編譯器該泛型型別該擁有何種行為。編譯器可以利用特徵界限資訊來檢查程式碼提供的實際型別有沒有符合特定行為。在動態語言中，我們要是呼叫一個該型別沒有的方法的話，我們會在執行時才發生錯誤。但是 Rust 將此錯誤移到編譯期間，讓我們必須在程式能夠執行之前確保有修正此問題。除此之外，我們還不用寫在執行時檢查此行為的程式碼，因為我們已經在編譯時就檢查了。這麼做我們可以在不失去泛型彈性的情況下，提升效能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過生命週期驗證參考"><a class="header" href="#透過生命週期驗證參考">透過生命週期驗證參考</a></h2>
<p>生命週期（lifetime）是另一種我們已經使用過的泛型。不同於確保一個型別有沒有我們要的行為，生命週期確保我們在需要參考的時候，它們都是有效的。</p>
<p>我們在第四章的<a href="ch04-02-references-and-borrowing.html#%E5%8F%83%E8%80%83%E8%88%87%E5%80%9F%E7%94%A8">「參考與借用」</a><!-- ignore -->段落沒談到的是，Rust 中的每個參考都有個<strong>生命週期</strong>，這是決定該參考是否有效的作用域。大多情況下生命週期是隱式且可推導出來的，就像大多情況下型別是可推導出來的。當多種型別都有可能時，我們就得詮釋型別。同樣地，當生命週期的參考能以不同方式關聯的話，我們就得詮釋生命週期。Rust 要求我們用泛型生命週期參數來詮釋參考之間的關係，以確保實際在執行時的參考絕對是有效的。</p>
<p>詮釋生命週期在大多數的程式語言中都沒有這個概念，所以這段可能會有點讓你覺得陌生。雖然我們不會在此章涵蓋所有生命週期的內容，但是我們會講些你可能遇到生命週期的常見場景，好讓你更加熟悉這個概念。</p>
<h3 id="透過生命週期預防迷途參考"><a class="header" href="#透過生命週期預防迷途參考">透過生命週期預防迷途參考</a></h3>
<p>生命週期最主要的目的就是要預防<strong>迷途參考</strong>（dangling references），其會導致程式參考到其他資料，而非它原本想要的參考。請看一下範例 10-16 的程式，它有一個外部作用域與內部作用域。</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">範例 10-16：嘗試使用其值已經離開作用域的參考</span></p>
<blockquote>
<p>注意：範例 10-16、10-17 與 10-23 宣告變數時都沒有給予初始數值，所以變數名稱可以存在於外部作用域。乍看之下這似乎違反 Rust 不存在空值的原則。但是如果我們嘗試在賦值前使用變數的話，我們就會獲得編譯期錯誤，這證明 Rust 的確不允許空值。</p>
</blockquote>
<p>外部作用域宣告了一個沒有初始值的變數 <code>r</code>，然後內部作用域宣告了一個初始值為 5 的變數 <code>x</code>。在內部作用域中，我們嘗試將 <code>x</code> 的參考賦值給 <code>r</code>。然後內部作用域結束後，我們嘗試印出 <code>r</code>。此程式碼不會編譯成功，因為數值 <code>r</code> 指向的數值在我們嘗試使用它時已經離開作用域。以下是錯誤訊息。</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
 --&gt; src/main.rs:6:13
  |
6 |         r = &amp;x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!(&quot;r: {}&quot;, r);
  |                       - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>變數 <code>x</code> 「存在的不夠久」。原因是因為當內部作用域在第 7 行結束時，<code>x</code> 會離開作用域。但是 <code>r</code> 卻還在外部作用域中有效，我們會說的「活得比較久」。如果 Rust 允許此程式碼可以執行的話，<code>r</code> 就會參考到 <code>x</code> 離開作用域後被釋放的記憶體位置，然後我們嘗試對 <code>r</code> 做的事情都不會是正確的了。所以 Rust 如何決定此程式碼無效呢？它使用了借用檢查器。</p>
<h3 id="借用檢查器"><a class="header" href="#借用檢查器">借用檢查器</a></h3>
<p>Rust 編譯器有個<strong>借用檢查器</strong>（borrow checker）會比較作用域來檢測所有的借用是否有效。範例 10-17 顯示了範例 10-16 的程式碼，但加上了變數生命週期的詮釋。</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">範例 10-17：變數 <code>r</code> 與 <code>x</code> 的生命週期詮釋，分別以 <code>'a</code> 和 <code>'b</code> 作為表示</span></p>
<p>我們在此定義 <code>r</code> 的生命週期詮釋為 <code>'a</code> 而 <code>x</code> 的生命週期為 <code>'b</code>。如同你所見，內部的 <code>'b</code> 區塊比外部的 <code>'a</code> 生命週期區塊還小。在編譯期間，Rust 會比較兩個生命週期的大小，並看出 <code>r</code> 有生命週期 <code>'a</code> 但它參考的記憶體有生命週期 <code>'b</code>。程式被回絕的原因是因為 <code>'b</code> 比 <code>'a</code> 還短：被參考的對象比參考者存在的時間還短。</p>
<p>範例 10-18 修正了此程式碼讓它不會存在迷途參考，並能夠正確編譯。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
</code></pre></pre>
<p><span class="caption">範例 10-18：一個有效參考，因為資料比參考的生命週期還長</span></p>
<p><code>x</code> 在此有生命週期 <code>'b</code>，此時它比 <code>'a</code> 還長。這代表 <code>r</code> 可以參考 <code>x</code>，因為 Rust 知道 <code>r</code> 的參考在 <code>x</code> 是有效的時候永遠是有效的。</p>
<p>現在你知道參考的生命週期，以及 Rust 如何分析生命週期以確保參考永遠有效了。讓我們來探索函式中參數與回傳值的泛型生命週期。</p>
<h3 id="函式中的泛型生命週期"><a class="header" href="#函式中的泛型生命週期">函式中的泛型生命週期</a></h3>
<p>讓我們寫個回傳兩個字串切片中較長者的函式。此函式會接收兩個字串切片並回傳一個字串切片。在我們實作 <code>longest</code> 函式後，範例 10-19 的程式碼應該要印出 <code>最長的字串為 abcd</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;最長的字串為 {}&quot;, result);
}
</code></pre>
<p><span class="caption">範例 10-19：<code>main</code> 函式呼叫 <code>longest</code> 函式來找出兩個字串切片中較長的</span></p>
<p>注意我們想要函式接收的是字串切片的參考，而不是字串，因為我們不希望 <code>longest</code> 函式會取得它參數的所有權。第四章的<a href="ch04-03-slices.html#%E5%AD%97%E4%B8%B2%E5%88%87%E7%89%87%E4%BD%9C%E7%82%BA%E5%8F%83%E6%95%B8">「字串切片作為參數」</a><!-- ignore -->段落有提到為何範例 10-19 的參數正是我們所想要使用的參數。</p>
<p>如果我們嘗試實作 <code>longest</code> 函式時，如範例 10-20 所示，它不會編譯過。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;最長的字串為 {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">範例 10-20：回傳兩個字串中較長者的 <code>longest</code> 函式實作，不過無法編譯成功</span></p>
<p>我們會看到以下關於生命週期的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>提示文字表示回傳型別需要有一個泛型生命週期參數，因為 Rust 無法辨別出回傳的參考指的是 <code>x</code> 還是 <code>y</code>。事實上，我們也不知道，因為函式本體中的 <code>if</code> 區塊會回傳 <code>x</code> 的參考而 <code>else</code> 區塊會回傳 <code>y</code> 的參考！</p>
<p>當我們定義函式時，我們不知道傳遞進此函式的實際數值會是什麼，所以我們不知道到底是 <code>if</code> 或 <code>else</code> 的區塊會被執行。我們也不知道傳遞進來的參考實際的生命週期為何，所以我們無法像範例 10-17 和 10-18 那樣觀察作用域，來判定我們回傳的參考會永遠有效。要修正此錯誤，我們要加上泛型生命週期參數來定義參考之間的關係，讓借用檢查器能夠進行分析。</p>
<h3 id="生命週期詮釋語法"><a class="header" href="#生命週期詮釋語法">生命週期詮釋語法</a></h3>
<p>生命週期詮釋（Lifetime Annotation）不會改變參考能存活多久，它們僅描述了數個參考的生命週期之間互相的關係，而不會影響其生命週期。就像當函式簽名指定了一個泛型型別參數時，函式便能夠接受任意型別一樣。函式可以指定一個泛型生命週期參數，這樣函式就能接受任何生命週期。</p>
<p>生命週期詮釋的語法有一點不一樣：生命週期參數的名稱必須以撇號（<code>'</code>）作為開頭，通常全是小寫且很短，就像泛型型別一樣。大多數的人會使用名稱 <code>'a</code> 作為第一個生命週期詮釋。我們將生命週期參數置於參考的 <code>&amp;</code> 之後，並使用空格區隔詮釋與參考的型別。</p>
<p>以下是一些例子：沒有生命週期參數的 <code>i32</code> 參考、有生命週期 <code>'a</code> 的 <code>i32</code> 參考以及有生命週期 <code>'a</code> 的 <code>i32</code> 可變參考。</p>
<pre><code class="language-rust ignore">&amp;i32        // 一個參考
&amp;'a i32     // 一個有顯式生命週期的參考
&amp;'a mut i32 // 一個有顯式生命週期的可變參考
</code></pre>
<p>只有自己一個生命週期本身沒有多少意義，因為該詮釋是為了告訴 Rust 數個參考的泛型生命週期參數之間互相的關係。讓我們來研究生命週期詮釋如何在 <code>longest</code> 函式中相互關聯吧。</p>
<h3 id="函式簽名中的生命週期詮釋"><a class="header" href="#函式簽名中的生命週期詮釋">函式簽名中的生命週期詮釋</a></h3>
<p>要在函式簽名使用生命週期詮釋的話，我們需要在函式名稱與參數列表之間的尖括號內宣告泛型<strong>生命週期</strong>參數，就像泛型<strong>型別</strong>參數那樣。</p>
<p>我們想在此簽名表達這樣的限制：只要所有參數都要是有效的，那麼回傳的參考才也會是有效的。也就是參數的生命週期與回傳參考的生命週期是相關的。我們會將生命週期命名為 <code>'a</code> 然後將它加到每個參考，如範例 10-21 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;最長的字串為 {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">範例 10-21：<code>longest</code> 函式定義指定所有簽名中的參考必須有相同的生命週期 <code>'a</code></span></p>
<p>此程式碼能夠編譯成功並產生我們希望在範例 10-19 的 <code>main</code> 函式中得到的結果。</p>
<p>此函式簽名告訴 Rust 它有個生命週期 <code>'a</code>，函式的兩個參數都是字串切片，並且會有生命週期<code>'a</code>。此函式簽名還告訴了 Rust 從函式回傳的字串切片也會和生命週期 <code>'a</code> 存活的一樣久。實際上它代表 <code>longest</code> 函式回傳參考的生命週期與函式引數傳入時字串長度較短的參考的生命週期一樣。這樣的關係正是我們想讓 Rust 知道以便分析這段程式碼。</p>
<p>注意當我們在此函式簽名指定生命週期參數時，我們不會變更任何傳入或傳出數值的生命週期。我們只是告訴借用檢查器應該要拒絕任何沒有服從這些約束的數值。注意到 <code>longest</code> 函式不需要知道 <code>x</code> 和 <code>y</code> 實際上會活多久，只需要知道有某個作用域會用 <code>'a</code> 取代來滿足此簽名。</p>
<p>當要在函式詮釋生命週期時，詮釋會位於函式簽名中，而不是函式本體。就像型別會寫在簽名中一樣，生命週期詮釋會成為函式的一部份。在函式簽名加上生命週期能讓 Rust 編譯器的分析工作變得更輕鬆。如果當函式的詮釋或呼叫的方式出問題時，編譯器錯誤就能限縮到我們的程式碼中指出來。如果都改讓 Rust 編譯器去推到可能的生命週期關係的話，編譯器可能會指到程式碼真正出錯之後的好幾步之後。</p>
<p>當我們向 <code>longest</code> 傳入實際參考時，<code>'a</code> 實際替代的生命週期為 <code>x</code> 作用域與 <code>y</code> 作用域重疊得部分。換句話說，泛型生命週期 <code>'a</code> 取得的生命週期會等於 <code>x</code> 與 <code>y</code> 的生命週期中較短的。因為我們將回傳的參考詮釋了相同的生命週期參數 <code>'a</code>，回傳參考的生命週期也會保證在 <code>x</code> 和 <code>y</code> 的生命週期較短的結束前有效。</p>
<p>讓我們來看看如何透過傳入不同實際生命週期的參考來使生命週期詮釋能約束 <code>longest</code> 函式，如範例 10-22 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;很長的長字串&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;最長的字串為 {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-22 使用 <code>longest</code> 函式並傳入 <code>String</code> 數值的參考，但兩個參數的實際生命週期均不相同</span></p>
<p>在此例中 <code>string1</code> 在外部作用域結束前都有效，而 <code>string2</code> 在內部作用域結束前都有效，然後 <code>result</code> 會取得某個有效參考直到內部作用域結束為止。執行此程式的話，你會看到借用檢查器認可此程式碼，它會編譯成功然後印出 <code>最長的字串為 很長的長字串</code>。</p>
<p>接下來，讓我們寫一個範例能要求 <code>result</code> 生命週期的參考必須是兩個引數中較短的才行。我們會移動變數 <code>result</code> 的宣告到外部作用域，但保留變數 <code>result</code> 的賦值與 <code>string2</code> 一樣在內部作用域。然後我們也將使用到 <code>result</code> 的 <code>println!</code> 移到外部作用域，緊接在內部作用域結束之後。如範例 10-23 所示，此程式碼會編譯不過。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;很長的長字串&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;最長的字串為 {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 10-23：嘗試在 <code>string2</code> 離開作用域後使用 <code>result</code></span></p>
<p>當我們嘗試編譯此程式碼，我們會看到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;最長的字串為 {}&quot;, result);
  |                               ------ borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>錯誤訊息表示要讓 <code>result</code> 在 <code>println!</code> 陳述式有效的話，<code>string2</code> 必須在外部作用域結束前都是有效的。Rust 會知道是因為我們在函式的參數與回傳值使用相同的生命週期 <code>'a</code> 來詮釋。</p>
<p>身為人類我們能看出此程式碼的 <code>string1</code> 字串長度的確比 <code>string2</code> 長，因此 <code>result</code> 會包含 <code>string1</code> 的參考。因為 <code>string1</code> 尚未離開作用域，所以 <code>string1</code> 的參考在 <code>println!</code> 陳述式中仍然是有效的才對。然而編譯器在此情形會無法看出參考是有效的。所以我們才告訴 Rust <code>longest</code> 函式回傳參考的生命週期等同於傳入參考中較短的生命週期。這樣一來借用檢查器就會否決範例 10-23 的程式碼，因為它可能會有無效的參考。</p>
<p>歡迎嘗試設計更多採用不同數值與不同生命週期的參考作為 <code>longest</code> 函式參數與回傳值的實驗，並在編譯前假設你的實驗會不會通過借用檢查器，然後看看你的理解是不是正確的！</p>
<h3 id="深入理解生命週期"><a class="header" href="#深入理解生命週期">深入理解生命週期</a></h3>
<p>你要指定生命週期參數的方式取決於函式的行為。舉例來說如果我們改變函式 <code>longest</code> 的實作為永遠只回傳第一個參數而不是最長的字串切片，我們就不需要在參數 <code>y</code> 指定生命週期。以下的程式碼就能編譯：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;最長的字串為 {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>我們指定生命週期參數 <code>'a</code> 給參數 <code>x</code> 與回傳型別，但參數 <code>y</code> 則沒有，因為 <code>y</code> 的生命週期與 <code>x</code> 和回傳型別的生命週期之間沒有任何關係。</p>
<p>當函式回傳參考時，回傳型別的生命週期參數必須符合其中一個參數的生命週期參數。如果回傳參考<strong>沒有</strong>和任何參數有關聯的話，代表它參考的是函式本體中的數值。但這會是迷途參考，因為該數值會在函式結尾離開作用域。請看看以下嘗試在函式 <code>longest</code> 的實作做法，它並不會編譯成功：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;最長的字串為 {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;超長的字串&quot;);
    result.as_str()
}
</code></pre>
<p>我們在這邊雖然有對回傳型別指定生命週期參數 <code>'a</code>，但此實作還是會失敗，因為回傳值的生命週期與參數的生命週期完全無關。以下是我們獲得的錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>問題在於 <code>result</code> 會離開作用域並在 <code>longest</code> 函式結尾被清除。我們卻嘗試從函式中回傳 <code>result</code> 的參考。我們無法指定生命週期參數來改變迷途參考，而且 Rust 不會允許我們將建立迷途參考。在此例中，最好的解決辦法是回傳有所有權的資料型別而非參考，並讓呼叫的函式自行決定如何清理數值。</p>
<p>總結來說，生命週期語法是用來連接函式中不同參數與回傳值的生命週期。一旦連結起來，Rust 就可以獲得足夠的資訊來確保記憶體安全的運算並防止會產生迷途指標或違反記憶體安全的操作。</p>
<h3 id="結構體定義中的生命週期詮釋"><a class="header" href="#結構體定義中的生命週期詮釋">結構體定義中的生命週期詮釋</a></h3>
<p>目前為止，我們定義過的結構體都持有型別的所有權。結構體其實也能持有參考，不過我們會需要在結構體定義中每個參考加上生命週期詮釋。範例 10-24 有個持有字串切片的結構體 <code>ImportantExcerpt</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;無法找到 '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">範例 10-24：擁有參考的結構體需要加上生命週期詮釋</span></p>
<p>此結構體有個欄位 <code>part</code> 並擁有字串切片參考。如同泛型資料型別，我們在結構體名稱之後的尖括號內宣告泛型生命週期參數，所以我們就可以在結構體定義的本體中使用生命週期參數。此詮釋代表 <code>ImportantExcerpt</code> 的實例不能比它持有的欄位 <code>part</code> 活得還久。</p>
<p><code>main</code> 函式在此產生一個結構體 <code>ImportantExcerpt</code> 的實例並持有一個參考，其為變數 <code>novel</code> 所擁有的 <code>String</code> 中的第一個句子的參考。<code>novel</code> 的資料是在 <code>ImportantExcerpt</code> 實例之前建立的。除此之外，<code>novel</code> 在 <code>ImportantExcerpt</code> 離開作用域之前不會離開作用域，所以 <code>ImportantExcerpt</code> 實例中的參考是有效的。</p>
<h3 id="生命週期省略"><a class="header" href="#生命週期省略">生命週期省略</a></h3>
<p>你已經學到了每個參考都有個生命週期，而且你需要在有使用參考的函式與結構體中指定生命週期參數。然而在第四章的範例 4-9 我們有函式可以不詮釋生命週期並照樣編譯成功，我們在範例 10-25 再展示一次。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word 能用在`String` 的切片
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word 能用在字串字面值
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 因為字串字面值已經是字串切片了
</span><span class="boring">    // 所以也可以不用加上字串語法！
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-25：在範例 4-9 定義過的函式，雖然其參數與回傳值均為參考，卻仍可編譯成功</span></p>
<p>此函式可以不用生命週期詮釋仍照樣編譯過是有歷史因素的：在早期版本的 Rust（1.0 之前），此程式碼是無法編譯的，因為每個參考都得有顯式生命週期。在當時的情況下，此函式簽名會長得像這樣：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>在寫了大量的 Rust 程式碼後，Rust 團隊發現 Rust 開發者會在特定情況反覆輸入同樣的生命週期詮釋。這些情形都是可預期的，而且可以遵循一些明確的模式。開發者將這些模式加入編譯器的程式碼中，所以借用檢查器可以依據這些情況自行推導生命週期，而讓我們不必顯式詮釋。</p>
<p>這樣的歷史值得提起的原因是因為很可能會有更多明確的模式被找出來並加到編譯器中，意味著未來對於生命週期詮釋的要求會更少。</p>
<p>被寫進 Rust 參考分析的模式被稱作<strong>生命週期省略規則（lifetime elision rules）</strong>。這些不是程式設計師要遵守的規則，而是一系列編譯器能去考慮的情形。而如果你的程式碼符合這些情形時，你就不必顯式寫出生命週期。</p>
<p>省略規則無法提供完整的推導。如果 Rust 能明確套用規則，但在這之後還是有參考存在模棱兩可的生命週期，編譯器就無法猜出剩餘參考的生命週期。編譯器不會亂猜，它會回傳錯誤給你，說明你需要指定生命週期詮釋。</p>
<p>在函式或方法參數上的生命週期稱為<strong>輸入生命週期（input lifetimes）</strong>，而在回傳值的生命週期則稱為<strong>輸出生命週期（output lifetimes）</strong>。</p>
<p>當參考沒有顯式詮釋生命週期時，編譯器會用三項規則來推導它們。第一個規則適用於輸入生命週期，而第二與第三個規則適用於輸出生命週期。如果編譯器處理完這三個規則，卻仍有參考無法推斷出生命週期時，編譯器就會停止並回傳錯誤。適用於 <code>fn</code> 定義的規則一樣適用於 <code>impl</code> 區塊。</p>
<p>第一個規則是編譯器會給予每個參考參數一個生命週期參數。換句話說，一個函式只有一個參數的話，就只會有一個生命週期：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>；一個函式有兩個參數的話，就會有分別兩個生命週期參數：<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，以此類推。</p>
<p>第二個規則是如果剛好只有一個輸入生命週期參數，該參數就會賦值給所有輸出生命週期參數：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<p>第三個規則是如果有多個輸入生命週期參數，但其中一個是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，由於這是方法，<code>self</code> 的生命週期會賦值給所有輸出生命週期參數。此規則讓方法更容易讀寫，因為不用寫更多符號出來。</p>
<p>讓我們假裝我們是編譯器。我們會檢查這些規則並找出範例 10-25 中函式 <code>first_word</code> 簽名中參考的生命週期。簽名的參考一開始沒有任何生命週期：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>接著編譯器檢查第一個規則，指明每個參數都有自己的生命週期。我們如往常一樣指定 <code>'a</code>，所以簽名就會變成：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>然後第二個規則也適用因為這裡剛好就一個輸入生命週期而已。第二個規則指明只有一個輸入生命週期的話，就會賦值給所有其他輸出生命週期。所以簽名現在變成這樣：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>現在此函式所有的參考都有生命週期了，而且編譯器可以繼續分析，不必要求程式設計師在此詮釋函式簽名的生命週期。</p>
<p>讓我們再看看一個例子，這次是範例 10-20 一開始沒有任何生命週期參數的 <code>longest</code> 函式：</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>讓我們先檢查第一項規則：每個參數都有自己的生命週期。這次我們有兩個參數，所以我們有兩個生命週期：</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>你可以看出來第二個規則並不適用，因為我們有不止一個輸入生命週期。而第三個也不適用，因為 <code>longest</code> 是函式而非方法，其參數不會有 <code>self</code> 。遍歷這三個規則下來，我們仍然無法推斷出回傳型別的生命週期。這就是為何我們嘗試編譯範例 10-20 的程式碼會出錯的原因：編譯器遍歷生命週期省略規則，但仍然無法推導出簽名中所有參考的生命週期。</p>
<p>因為第三個規則僅適用於方法簽名，我們接下來就會看看這種情況時的生命週期，看看為何第三個規則讓我們不必常常在方法簽名詮釋生命週期。</p>
<h3 id="在方法定義中的生命週期詮釋"><a class="header" href="#在方法定義中的生命週期詮釋">在方法定義中的生命週期詮釋</a></h3>
<p>當我們在有生命週期的結構體上實作方法時，其語法類似於我們在範例 10-11 中泛型型別參數的語法。宣告並使用生命週期參數的地方會依據它們是否與結構體欄位或方法參數與回傳值相關。</p>
<p>結構體欄位的生命週期永遠需要宣告在 <code>impl</code> 關鍵字後方以及結構體名稱後方，因為這些生命週期是結構體型別的一部分。</p>
<p>在 <code>impl</code> 區塊中方法簽名的參考可能會與結構體欄位的參考生命週期綁定，或者它們可能是互相獨立的。除此之外，生命週期省略規則常常可以省略方法簽名中的生命週期詮釋。讓我們看看範例 10-24 定義過的 <code>ImportantExcerpt</code> 來作為範例。</p>
<p>首先我們使用一個方叫做 <code>level</code> 其參數只有 <code>self</code> 的參考而回傳值是 <code>i32</code>，這不是任何參考：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;請注意：{}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;叫我以實瑪利。多年以前...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;找不到'.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>我們必須在 <code>impl</code> 之後宣告生命週期參數，並在型別名稱後使用該生命週期。但是我們不必在 <code>self</code> 的參考加上生命週期詮釋，因為其適用於第一個省略規則。</p>
<p>以下是第三個生命週期省略規則適用的地方：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;請注意：{}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;叫我以實瑪利。多年以前...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;找不到'.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>這裡有兩個輸入生命週期，所以 Rust 用第一個生命週期省略規則給予 <code>&amp;self</code> 和 <code>announcement</code> 它們自己的生命週期。然後因為其中一個參數是 <code>&amp;self</code>，回傳型別會取得 <code>&amp;self</code> 的生命週期，如此一來所有的生命週期都推導出來了。</p>
<h3 id="靜態生命週期"><a class="header" href="#靜態生命週期">靜態生命週期</a></h3>
<p>其中有個特殊的生命週期 <code>'static</code> 我們需要進一步討論，這是指該參考<strong>可以</strong>存活在整個程式期間。所有的字串字面值都有 <code>'static</code> 生命週期，我們可以這樣詮釋：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;我有靜態生命週期。&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>此字串的文字會直接儲存在程式的執行檔中，所以永遠有效。因此所有的字串字面值的生命週期都是 <code>'static</code>。</p>
<p>你有時可能會看到錯誤訊息建議使用 <code>'static</code> 生命週期。但在你對參考指明 <code>'static</code> 生命週期前，最好想一下該參考的生命週期是否真的會存在於整個程式期間，以及是否真的該活得這麼久。大多數錯誤訊息會建議 <code>'static</code> 生命週期的情況都來自於嘗試建立迷途參考或可用的生命週期不符。這樣的情況下，應該是要實際嘗試解決問題，而不是指明 <code>'static</code> 生命週期。</p>
<h2 id="組合泛型型別參數特徵界限與生命週期"><a class="header" href="#組合泛型型別參數特徵界限與生命週期">組合泛型型別參數、特徵界限與生命週期</a></h2>
<p>讓我們用一個函式來總結泛型型別參數、特徵界限與生命週期的語法！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;最長的字串為 {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;公告！{}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>這是範例 10-21 會回傳兩個字串切片較長者的 <code>longest</code> 函式。不過現在它有個額外的參數 <code>ann</code>，使用的是泛型型別 <code>T</code>，它可以是任何在 <code>where</code> 中所指定有實作 <code>Display</code> 特徵的型別。此額外參數會在 <code>{}</code> 的地方印出來，這正是為何 <code>Display</code> 的特徵界限是必須的。因為生命週期也是一種泛型，生命週期參數 <code>'a</code> 與泛型型別參數 <code>T</code> 都宣告在函式名稱後的尖括號內。</p>
<h2 id="總結-9"><a class="header" href="#總結-9">總結</a></h2>
<p>我們在此章節涵蓋了許多內容！現在你已經知道泛型型別參數、特徵與特徵界限以及泛型生命週期參數，你已經準備好能寫出適用於許多不同情況且不重複的程式碼了。泛型型別參數讓你可以讓程式碼適用於不同型別；特徵與特徵界限確保就算型別為泛型，它們都會有相同的行為。你還學到了使用生命週期詮釋確保此如此彈性的程式碼不會造成迷途參考。而且這些分析都發生在編譯期間，完全不影響執行時效能！</p>
<p>不管你信不信，本章節還有很多延伸主題可以導論，像是第十七章就會討論特徵物件（trait objects），這是另一個使用特徵的方法。另外還有一些更複雜的場合會涉及到更進階的生命週期詮釋。對此你可能就會想閱讀 <a href="https://doc.rust-lang.org/stable/reference/index.html">Rust Reference</a>。接下來，你將學習如何在 Rust 寫測試，讓你可以確保程式碼能如期執行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="編寫自動化測試"><a class="header" href="#編寫自動化測試">編寫自動化測試</a></h1>
<p>Edsger W. Dijkstra 曾在 1972 年的演講「謙遜的程式設計師」中提到：「程式測試是個證明程式錯誤存在非常有效的方法，但要證明它不存在卻反而顯得十分無力。」這不代表我們不應該盡可能地做測試！</p>
<p>程式碼的正確性意謂著我們的程式碼可以如我們的預期執行。Rust 就被設計為特別注重程式的正確性，但正確性是很複雜且難以證明的。Rust 的型別系統就承擔了很大一部分的負擔，但是型別系統還是沒辦法抓到全部。所以 Rust 在語言內提供了編寫自動化程式測試的支援。</p>
<p>假設我們要寫個程式叫做 <code>add_two</code>，其會將傳入任意數字加上 2。此函式簽名接受整數作為參數並回傳一個整數作為結果。當我們實作並編譯函式時，Rust 會做所有你已經學過的型別檢查與借用檢查，來確保像是我們不會中傳入 <code>String</code> 數值或任意無效參考至此函式。但 Rust <strong>無法</strong>檢查其是否能執行我們預期此函式會完成的任務，也就是回傳加上 2 的參數。說不定它會將參數加上 10 或減 50！這就是我們要做測試的地方。</p>
<p>舉例來說，我們可以寫測試來判定當我們傳入 <code>3</code> 給函式 <code>add_two</code> 時，回傳值是不是 <code>5</code>。我們可以再變更我們的程式碼時來執行這些測試，以確保原本就正確的行為不會被改變。</p>
<p>測試是個複雜的技能，雖然我們無法在一個章節就涵蓋如何寫出好測試的細節，但我們還是會討論 Rust 測試功能機制。我們會介紹當你寫測試時可以用的詮釋與巨集、執行測試時的預設行為與選項以及如何組織測試成單元測試與整合測試。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="如何寫測試"><a class="header" href="#如何寫測試">如何寫測試</a></h2>
<p>測試是一種 Rust 函式來驗證非測試程式碼是否以預期的方式執行。測試函式的本體通常會做三件動作：</p>
<ol>
<li>設置任何所需要的資料或狀態。</li>
<li>執行你希望測試的程式碼</li>
<li>判定結果是否與你預期的相符。</li>
</ol>
<p>讓我們看看 Rust 特地提供給測試的功能：包含 <code>test</code> 屬性（attribute）、一些巨集以及 <code>should_panic</code> 屬性。</p>
<h3 id="測試函式剖析"><a class="header" href="#測試函式剖析">測試函式剖析</a></h3>
<p>最簡單的形式來看，測試在 Rust 中就是附有 <code>test</code> 屬性的函式。屬性是一種關於某段 Rust 程式碼的詮釋資料（metadata），其中一個例子是我們在第五章使用的 <code>derive</code> 屬性。要將一個函式轉換成測試函式，在 <code>fn</code> 前一行加上 <code>#[test]</code> 即可。當你用 <code>cargo test</code> 命令來執行你的測試時，Rust 會建構一個測試執行檔並執行被標注的函式，並回報每個測試函式是否通過或失敗。</p>
<p>當我們用 Cargo 建立新的函式庫專案時，同時會自動建立一個擁有測試函式的測試模組。此模組能協助我們開始寫測試，讓你不必在每次建立新專案時，尋找特定結構體與測試函式的語法。你可以新增多少測試函式與多少測試模組都沒問題！</p>
<p>在實際測試任何程式碼之前，我們將會透過實驗測試產生的樣板，來探索測試如何運作的每個環節。然後我們會寫些現實世界會寫的測試，呼叫我們寫的程式碼並判定其行為是否正確。</p>
<p>讓我們建立個會相加兩個數字的函式庫專案 <code>adder</code>：</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>函式庫專案 <code>adder</code> 中的 <em>src/lib.rs</em> 檔案內容會長得像範例 11-1 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
cargo test
git co output.txt
cd ../../..
-->
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p><span class="caption">範例 11-1：透過 <code>cargo new</code> 自動產生的測試模組與函式</span></p>
<p>現在我們先忽略開頭前兩行並專注在函式。先注意到 <code>#[test]</code> 詮釋：此屬性指出這是測試函式，所以測試者會知道此函式是用來測試的。我們也可以在 <code>tests</code> 模組中加入非測試函式來協助設置常見場景或是執行常見運算，所以我們需要標注哪些是想要測試的函式。</p>
<p>範例函式本體使用 <code>assert_eq!</code> 巨集來判定該 <code>result</code>，也就是 2 + 2 的結果是否等於 4。此判定是作為典型測試的範例格式。讓我們執行它來看看此測試是否會通過。</p>
<p><code>cargo test</code> 命令會執行專案中的所有測試，如範例 11-2 所示。</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">範例 11-2：執行自動產生的測試的輸出結果</span></p>
<p>Cargo 會編譯並執行測試。在 <code>running 1 test</code> 這行之後會顯示自動產生的測試函式 <code>it_works</code> 以及測試執行的結果 <code>ok</code>。再來可以看到整體總結，<code>test result: ok.</code> 代表所有測試都有通過，然後 <code>1 passed; 0 failed</code> 指出所有測試成功或失敗的數量。</p>
<p>我們可以選擇忽略測試，讓它在特定情形不會執行，我們會在本章的<a href="ch11-02-running-tests.html#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%B8%AC%E8%A9%A6%E9%99%A4%E9%9D%9E%E7%89%B9%E5%88%A5%E6%8C%87%E5%AE%9A">「忽略某些測試除非特別指定」</a><!-- ignore -->段落再做說明。因為我們尚未有任何會忽略的程式碼，所以總結會顯示 <code>0 ignored</code>。我們也可以在 <code>cargo test</code> 傳入引數，只執行名稱符合字串的測試。這叫做<strong>過濾</strong>（filtering），我們會在<a href="ch11-02-running-tests.html#%E9%80%8F%E9%81%8E%E5%90%8D%E7%A8%B1%E4%BE%86%E5%9F%B7%E8%A1%8C%E9%83%A8%E5%88%86%E6%B8%AC%E8%A9%A6">「透過名稱來執行部分測試」</a><!-- ignore -->段落做說明。我們也沒有過濾會執行的測試，所以總結最後顯示 <code>0 filtered out</code>。</p>
<p><code>0 measured</code> 的統計數值是指評測效能的效能測試。效能測試（Benchmark tests）在本書撰寫時，仍然僅在 nightly Rust 可用。請查閱<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">效能測試的技術文件</a>來瞭解詳情。</p>
<p>測試輸出結果的下一部分，也就是 <code>Doc-tests adder</code>，是指任何技術文件測試的結果。我們還沒有任何技術文件測試，但是 Rust 可以編譯在 API 技術文件中的任何程式碼範例。此功能能幫助我們將技術文件與程式碼保持同步！我們會在第十四章的 <a href="ch14-02-publishing-to-crates-io.html#%E5%B0%87%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6%E8%A8%BB%E8%A7%A3%E4%BD%9C%E7%82%BA%E6%B8%AC%E8%A9%A6">「將技術文件註解作為測試」</a><!-- ignore -->段落討論如何寫技術文件測試。現在我們會先忽略 <code>Doc-tests</code> 的輸出結果。</p>
<p>讓我們變更程式碼的名稱來看看測試輸出會變成什麼。將 <code>it_works</code> 函式變更名稱，像是以下改成 <code>exploration</code> 這樣：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>然後再執行一次 <code>cargo test</code>，輸出會顯示 <code>exploration</code> 而非 <code>it_works</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>讓我們再加上另一個測試，不過這次我們要讓測試失敗！測試會在測試函式恐慌時失敗，每個測試會跑在新的執行緒（thread）上，然後當主執行緒看到測試執行緒死亡時，就會將該測試標記為失敗的。我們有在第九章提及引發恐慌最簡單的辦法，那就是呼叫 <code>panic!</code> 巨集。將它寫入新的測試 <code>another</code> 中，所以你在 <em>src/lib.rs</em> 的檔案中會看到向範例 11-3 這樣。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;此測試會失敗&quot;);
    }
}
</code></pre>
<p><span class="caption">範例 11-3：新增第二個會失敗的測試，因為我們會呼叫 <code>panic!</code> 巨集</span></p>
<p>使用 <code>cargo test</code> 再執行一次測試，輸出結果應該會像範例 11-4 這樣，顯示出我們的 <code>exploration</code> 測試通過但 <code>another</code> 失敗。</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at '此測試會失敗', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p><span class="caption">範例 11-4：其中一個測試通過，而另一個失敗的輸出結果</span></p>
<p><code>test tests::another</code> 這行會顯示 <code>FAILED</code> 而非 <code>ok</code>。在獨立結果與總結之間出現了兩個新的段落，第一個段落會顯示每個測試失敗的原因細節。在此例中，我們會收到 <code>another</code> 失敗的緣由，因為 <em>src/lib.rs</em> 檔案中第十行的恐慌 <code>panicked at '此測試會失敗'</code>。下一個段落則是會列出所有失敗的測試，要是測試很多且失敗測試輸出結果很長的話，此資訊就很實用。我們可以使用失敗測試的名稱來只執行這個測試以便除錯。我們會在<a href="ch11-02-running-tests.html#%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F%E5%A6%82%E4%BD%95%E5%9F%B7%E8%A1%8C">「控制程式如何執行」</a><!-- ignore -->段落討論更多執行測試的方法。</p>
<p>總結會顯示在最後一行，在此例中它表示我們有一個測試結果是 <code>FAILED</code>。也就是我們有一個測試通過，一個測試失敗。</p>
<p>現在你知道測試結果在不同場合看起來的樣子，讓我們來看看除了 <code>panic!</code> 以外對測試也很有幫助的巨集吧。</p>
<h3 id="透過-assert-巨集檢查結果"><a class="header" href="#透過-assert-巨集檢查結果">透過 <code>assert!</code> 巨集檢查結果</a></h3>
<p>標準函式庫提供的 <code>assert!</code> 巨集可以在你要確保測試中的一些條件評估為 <code>true</code> 時使用。我們給予 <code>assert!</code> 巨集一個引數來計算出布林值。如果數值為 <code>true</code>，<code>assert!</code> 不會做任何動作然後測試就會通過。如果數值為 <code>false</code>，<code>assert!</code> 巨集會呼叫 <code>panic!</code> 巨集導致測試失敗。使用 <code>assert!</code> 巨集能幫助我們檢查我們的程式碼是否以我們預期的方式運作。</p>
<p>在第五章的範例 5-15，我們有結構體 <code>Rectangle</code> 與方法 <code>can_hold</code>，我們在範例 11-5 再看一次。讓我們將此程式碼寫入 <em>src/lib.rs</em> 檔案中，並寫些對它使用 <code>assert!</code> 巨集的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
<p><span class="caption">範例 11-5：第五章中的結構體 <code>Rectangle</code> 與其方法 <code>can_hold</code></span></p>
<p><code>can_hold</code> 方法會回傳布林值，這代表它是 <code>assert!</code> 巨集的絕佳展示機會。在範例 11-6 中，我們寫了個測試來練習 <code>can_hold</code> 方法，我們建立了一個寬度為 8 長度為 7 的 <code>Rectangle</code> 實例，並判定它可以包含另一個寬度為 5 長度為 1 的 <code>Rectangle</code> 實例。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre>
<p><span class="caption">範例 11-6：一支檢查一個大長方形是否能包含一個小長方形的 <code>can_hold</code> 測試</span></p>
<p>注意到我們已經在 <code>tests</code> 模組中加了一行 <code>use super::*;</code>。<code>tests</code> 和一般的模組一樣都遵循我們在第七章<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">「參考模組項目的路徑」</a><!-- ignore -->提及的常見能見度規則。因為 <code>tests</code> 模組是內部模組，我們需要將外部模組的程式碼引入內部模組的作用域中。我們使用全域運算子（glob）讓外部模組定義的所有程式碼在此 <code>tests</code> 模組都可以使用。</p>
<p>我們將我們的測試命名為 <code>larger_can_hold_smaller</code>，然後我們建立兩個我們需要用到的 <code>Rectangle</code> 實例。然後我們呼叫 <code>assert!</code> 巨集並將 <code>larger.can_hold(&amp;smaller)</code> 的結果傳給它。此表達式應該要回傳 <code>true</code>，所以我們的程式應該會通過。讓我們看看結果吧！</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>它通過了！讓我們再加另一個測試，這是是判定小長方形無法包含大長方形：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --省略--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre>
<p>因為函式 <code>can_hold</code> 的正確結果在此例為 <code>false</code>，我們需要將該結果反轉後才能傳給 <code>assert!</code> 巨集。因此我們的測試在 <code>can_hold</code> 回傳 <code>false</code> 時才會通過：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>兩個測試都過了！現在讓我們看看當我們在程式碼中引入程式錯誤的話，測試結果會為何。讓我們來改變 <code>can_hold</code> 方法的實作將比較時的大於符號改成小於符號：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>執行測試的話現在就會顯示以下結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>我們的測試抓到了錯誤！因為 <code>larger.width</code> 是 8 而 <code>smaller.width</code> 是 5，<code>can_hold</code> 比較寬度時現在會回傳 <code>false</code>，因為 8 沒有比 5 小。</p>
<h3 id="透過-assert_eq-與-assert_ne-macros-測試相等"><a class="header" href="#透過-assert_eq-與-assert_ne-macros-測試相等">透過 <code>assert_eq!</code> 與 <code>assert_ne!</code> Macros 測試相等</a></h3>
<p>有一種常見驗證程式的方式是將程式碼的結果與你預期程式碼會回傳的數值做測試，檢查它們是否相等。你可以使用 <code>assert!</code> 巨集並傳入使用 <code>==</code> 運算子的表達式來辦到。不過這種測試方法是很常見的，所以標準函式庫提供了一對巨集 <code>assert_eq!</code> 與 <code>assert_ne!</code> 來讓你能更方便地測試。這兩個巨集分別比較兩個引數是否相等或不相等。如果判定失敗的話，它們還會印出兩個數值，讓我們能清楚看到<strong>為何</strong>測試失敗。相對地，<code>assert!</code> 巨集只會說明它在 <code>==</code> 表達式中取得 <code>false</code> 值，而不會告訴你導致 <code>false</code> 的那兩個值。</p>
<p>在範例 11-7 中，我們寫了個函式叫做 <code>add_two</code> 並對參數加上 <code>2</code>，然後我們使用 <code>assert_eq!</code> 巨集來測試此函式。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p><span class="caption">範例 11-7：使用 <code>assert_eq!</code> 巨集測試函式 <code>add_two</code></span></p>
<p>讓我們檢查後它的確通過了！</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>我們傳入 <code>assert_eq!</code> 巨集的引數 <code>4</code> 與呼叫 <code>add_two(2)</code> 的結果相等。測試的結果為 <code>test tests::it_adds_two ... ok</code> 而 <code>ok</code> 就代表我們的測試通過了！</p>
<p>讓我們在我們的程式碼引入個錯誤，看看使使用 <code>assert_eq!</code> 的測試失敗時看起來為何。變更函式 <code>add_two</code> 的實作改成加 <code>3</code>：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>再執行一次測試：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>我們的測試抓到了錯誤！<code>it_adds_two</code> 測試失敗了，然後訊息會告訴我們失敗的判斷來自於 <code>assertion failed: `(left == right)`</code>，以及 <code>left</code> 與 <code>right</code> 的數值為何。此訊息能協助我們開始除錯：<code>left</code> 的引數是 <code>4</code> 但是擁有 <code>add_two(2)</code> 的引數 <code>right</code> 卻是 <code>5</code>。你應該能想像這會在有一大堆測試時是非常有幫助的。</p>
<p>注意到在有些語言或測試框架中，判定相等的函式的參數會稱作 <code>expected</code> 和 <code>actual</code>，然後它們會因為指定的引數順序而有差。但在 Rust 中它們被稱為 <code>left</code> 和 <code>right</code>，且我們預期的值與測試中程式碼產生的值之間的順序沒有任何影響。我們可以在此測試這樣寫判定 <code>assert_eq!(add_two(2), 4)</code>，而錯誤訊息一樣會顯示 <code>assertion failed: `(left == right)`</code>。</p>
<p><code>assert_ne!</code> 巨集會在我們給予的兩個值不相等時通過，相等時失敗。此巨集適用於當我們不確定一個數值<strong>會是</strong>什麼樣子，但是我們確定該數值<strong>不該</strong>是某種樣子。舉例來說，如果我們要測試一個保證會以某種形式更改其輸入的函式，但輸入變更的方式是依照我們執行程式時的當天是星期幾來決定，此時最好的判定方式就是檢查函式的輸出不等於輸入。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 巨集底下分別使用了 <code>==</code> 和 <code>!=</code> 運算子。當判定失敗時，巨集會透過除錯格式化資訊來顯示它們的引數，代表要比較的數值必須要實作 <code>PartialEq</code> 和 <code>Debug</code> 特徵。所有的基本型別與大多數標準函式庫中提供的型別都有實作這些特徵。對於你自己定義的結構體與枚舉，你需要實作 <code>PartialEq</code>，這樣該型別的數值才能判定相等或不相等。你需要實作 <code>Debug</code> 來顯示判定失敗時的數值。因為這兩個特徵都是可推導的特徵，就像第五章的範例 5-12 所寫的那樣，我們通常只要在你定義的結構體或枚舉前加上 <code>#[derive(PartialEq, Debug)]</code> 的詮釋就好。你可以查閱附錄 C <a href="appendix-03-derivable-traits.html">「可推導的特徵」</a><!-- ignore --> 來發現更多可推導的特徵。</p>
<h3 id="加入自訂失敗訊息"><a class="header" href="#加入自訂失敗訊息">加入自訂失敗訊息</a></h3>
<p>你可以寫一個一個與失敗訊息一同顯示的自訂訊息，作為 <code>assert!</code>、<code>assert_eq!</code> 與 <code>assert_ne!</code> 巨集的選擇性引數。任何指定在必要引數後方的任何引數都會傳給 <code>format!</code> 巨集（我們在第八章<a href="ch08-02-strings.html#%E4%BD%BF%E7%94%A8--%E9%81%8B%E7%AE%97%E5%AD%90%E6%88%96-format-%E5%B7%A8%E9%9B%86%E4%B8%B2%E6%8E%A5%E5%AD%97%E4%B8%B2">「使用 <code>+</code> 運算子或 <code>format!</code> 巨集串接字串」</a><!-- ignore -->的段落討論過），所以你可以傳入一個包含 <code>{}</code> 佔位符（placeholder）的格式化字串以及其對應的數值。自訂訊息可以用來紀錄判定的意義，當測試失敗時，你可以更清楚知道程式碼的問題。</p>
<p>舉例來說，假設我們有個函式會以收到的名字向人們打招呼，而且我們希望測試我們傳入的名字有出現在輸出：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;哈囉{}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;卡爾&quot;);
        assert!(result.contains(&quot;卡爾&quot;));
    }
}
</code></pre>
<p>此函式的要求還沒完全確定，而我們招呼開頭的文字 <code>哈囉</code> 很可能會在之後改變。我們決定當需求改變時，我們不想要得同時更新測試。所以我們不打算檢查 <code>greeting</code> 函式回傳的整個數值，我們只需要判定輸出有沒有包含輸入參數。</p>
<p>現在讓我們將錯誤引進程式中吧，將 <code>greeting</code> 改成不包含 <code>name</code> 然後看看預設的測試失敗會如何呈現：</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;哈囉！&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;卡爾&quot;);
</span><span class="boring">        assert!(result.contains(&quot;卡爾&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>執行此程式會產生以下錯誤：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(\&quot;卡爾\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>此結果指出判定失敗以及發生的位置。要是錯誤訊息可以提供我們從 <code>greeting</code> 函式取得的數值會更好。讓我們來在測試函式中加入自訂訊息，該訊息會是個格式化字串，並有個佔位符（placeholder）來填入我們從 <code>greeting</code> 函式取得的確切數值：</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;哈囉！&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;卡爾&quot;);
        assert!(
            result.contains(&quot;卡爾&quot;),
            &quot;打招呼時並沒有喊出名稱，其數值為 `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<p>現在當我們執行測試，我們能從錯誤訊息得到更多資訊：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at '打招呼時並沒有喊出名稱，其數值為 `哈囉！`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>我們可以看到我們實際從測試輸出拿到的數值，這能幫助我們除錯找到實際發生什麼，而不只是預期會是什麼。</p>
<h3 id="透過-should_panic-檢查恐慌"><a class="header" href="#透過-should_panic-檢查恐慌">透過 <code>should_panic</code> 檢查恐慌</a></h3>
<p>除了檢查我們的程式碼有沒有回傳我們預期的正確數值，檢查我們的程式碼有沒有如我們預期處理錯誤條件也是很重要的。舉例來說，考慮我們在第九章範例 9-13 建立的 <code>Guess</code> 型別。其他使用 <code>Guess</code> 的程式碼保證會拿到數值為 1 到 100 的 <code>Guess</code> 實例。我們可以寫個會恐慌的程式，嘗試用範圍之外的數字建立 <code>Guess</code> 實例。</p>
<p>為此我們可以加上屬性 <code>should_panic</code> 到我們的測試函式。此屬性讓函式的程式碼恐慌時才會通過測試，反之如果函式的程式碼沒有恐慌的話測試就會失敗。</p>
<p>範例 11-8 展示一支檢查 <code>Guess::new</code> 是否以我們預期的錯誤條件出錯的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;猜測數字必須介於 1 到 100 之間，你輸入的是 {}。&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">範例 11-8：測試造成 <code>panic!</code> 的條件</span></p>
<p>我們將 <code>#[should_panic]</code> 屬性置於 <code>#[test]</code> 屬性之後與測試函式之前。讓我們看看測試通過的結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>看起來不錯！現在讓我們將錯誤引入程式碼中，移除會讓 <code>new</code> 函式在數值大於 100 會恐慌的程式碼：</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;猜測數字必須介於 1 到 100 之間，你輸入的是 {}。&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>當我們執行範例 11-8 的測試，它就會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>我們在此情況得到的訊息並不是很有用，但是當我們查看測試函式，我們會看到它詮釋了 <code>#[should_panic]</code>。這個測試失敗代表測試函式內的程式碼沒有造成恐慌。</p>
<p>使用 <code>should_panic</code> 的測試可能會有點模棱兩可。<code>should_panic</code> 測試只要是有恐慌都會通過，就算是不同於我們預期發生的恐慌而造成的也一樣。要讓測試 <code>should_panic</code> 更精準的話，我們可以加上選擇性的 <code>expected</code> 參數到 <code>should_panic</code> 中。這樣測試就會確保錯誤訊息會包含我們所寫的文字。舉例來說，範例 11-9 更改了 <code>Guess</code> 讓 <code>new</code> 函式會依據數值太大或大小而有不同的錯誤訊息。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;猜測數字必須大於等於 1，取得的數值是 {}。&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;猜測數字必須小於等於 100，取得的數值是 {}。&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;小於等於 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">範例 11-9：<code>panic!</code> 的錯誤訊息包含特定子字串才會通過的測試</span></p>
<p>此測試會通過是因為我們在 <code>should_panic</code> 屬性加上的 <code>expected</code> 就是 <code>Guess::new</code> 函式恐慌時的子字串。我們也可以指定整個恐慌訊息，在此例的話就是 <code>猜測數字必須小於等於 100，取得的數值是 200。</code>。你所指定的預期參數取決於該恐慌訊息是獨特或動態的，以及你希望你的測試要多精準。在此例中，恐慌訊息的子訊息就足以確認測試函式中的程式碼會執行 <code>else if value &gt; 100</code> 的分支。</p>
<p>為了觀察擁有 <code>expected</code> 訊息的 <code>should_panic</code> 失敗時會發生什麼事。讓我同樣再次將錯誤引入程式中，將 <code>if value &lt; 1</code> 與 <code>else if value &gt; 100</code> 的區塊本體對調：</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;猜測數字必須小於等於 100，取得的數值是 {}。&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;猜測數字必須大於等於 1，取得的數值是 {}。&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;小於等於 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>這次當我們執行 <code>should_panic</code> 測試，它就會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at '猜測數字必須大於等於 1，取得的數值是 200。', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;猜測數字必須大於等於 1，取得的數值是 200。&quot;`,
 expected substring: `&quot;小於等於 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>錯誤訊息表示此程式碼的確有如我們預期地恐慌，但是恐慌訊息並沒有包含預期的字串 <code>'猜測數字必須小於等於 100'</code>。在此例我們的會得到的恐慌訊息為 <code>猜測數字必須大於等於 1，取得的數值是 200。</code>這樣我們就能尋找錯誤在哪了！</p>
<h3 id="在測試中使用-resultt-e"><a class="header" href="#在測試中使用-resultt-e">在測試中使用 <code>Result&lt;T, E&gt;</code></a></h3>
<p>我們目前為止的測試在失敗時都會恐慌。我們也可以寫出使用 <code>Result&lt;T, E&gt;</code> 的測試！以下是範例 11-1 的測試，不過重寫成 <code>Result&lt;T, E&gt;</code> 的版本並回傳 <code>Err</code> 而非恐慌：</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;二加二不等於四&quot;))
        }
    }
}
</code></pre>
<p><code>it_works</code> 函式現在有個回傳型別 <code>Result&lt;(), String&gt;</code>。在函式本體中，我們不再呼叫 <code>assert_eq!</code> 巨集，而是當測試成功時回傳 <code>Ok(())</code>，當程式失敗時回傳存有 <code>String</code> 的 <code>Err</code>。</p>
<p>測試中回傳 <code>Result&lt;T, E&gt;</code> 讓你可以在測試本體中使用問號運算子，這樣能方便地寫出任何運算回傳 <code>Err</code> 時該失敗的測試。</p>
<p>不過你就不能將 <code>#[should_panic]</code> 詮釋用在使用 <code>Result&lt;T, E&gt;</code> 的測試。要判斷一個操作是否回傳 <code>Err</code> 的話，不要在 <code>Result&lt;T, E&gt;</code> 數值後加上 <code>?</code>，而是改用 <code>assert!(value.is_err())</code>。</p>
<p>現在你知道了各種寫測試的方法，讓我們看看執行程式時發生了什麼事，並探索我們可以對 <code>cargo test</code> 使用的選項。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="控制程式如何執行"><a class="header" href="#控制程式如何執行">控制程式如何執行</a></h2>
<p>就像 <code>cargo run</code> 會編譯你的程式碼並執行產生的執行檔，<code>cargo test</code> 會在測試模式編譯你的程式碼並執行產生的測試執行檔。<code>cargo test</code> 產生的執行檔預設行為會平行執行所有測試，並獲取測試執行時的輸出，，讓測試各自的輸出結果不會顯示出來，以更容易讀取相關測試的結果。然而你可以指定命令列選項來改變預設行為。</p>
<p>有些命令列選項用於 <code>cargo test</code> 而有些則用於產生的測試執行檔。要分開這兩種引數，你可以先列出要用於 <code>cargo test</code> 的引數然後加上 <code>--</code> 分隔線來區隔要用於測試執行檔的引數。執行 <code>cargo test --help</code> 可以顯示你能用在 <code>cargo test</code> 的選項，而執行 <code>cargo test -- --help</code> 則會顯示你在 <code>--</code> 之後能用的選項。</p>
<h3 id="平行或接續執行測試"><a class="header" href="#平行或接續執行測試">平行或接續執行測試</a></h3>
<p>當你執行數個測試時，它們預設會使用執行緒（thread）來平行執行。這樣測試可以更快完成，讓你可以從你或其他人的程式碼更快獲得回饋。因為測試是同時一起執行的，請確保你的測試並不依賴其他測試或是共享的狀態。這包含共享環境，像是目前的工作目錄或是環境變數。</p>
<p>舉例來說，假設你的每個測試都會執行一些程式碼，用以在硬碟上產生一個檔案叫做 <em>test-output.txt</em> ，並將一些資料寫入檔案中。然後每個測試讀取檔案中的資料，並判定該檔案有沒有包含特定的值，而這個值在每個測試都不相同。因為測試同時執行，其中的測試可能覆蓋其他測試寫入與讀取的內容。這樣其他測試就會失敗，並不是因為程式碼不正確，而是因為平行執行時該測試會被其他測試所影響。其中一個解決辦法是確保每個測試都寫入不同的檔案，或者也可以選擇一次只執行一個測試。</p>
<p>如果你不想平行執行測試，或者你想要能更加掌控使用的執行緒數量，你可以傳遞 <code>--test-threads</code> 的選項以及你希望在測試執行檔使用的執行緒數量。請看一下以下範例：</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>我們將測試執行緒設為 <code>1</code>，告訴程式不要做任何平行化。使用一條執行緒執行測試會比平行執行它們還來的久，但是如果測試有共享狀態的話，它們就會不互相影響到對方了。</p>
<h3 id="顯示函式輸出結果"><a class="header" href="#顯示函式輸出結果">顯示函式輸出結果</a></h3>
<p>如果測試通過的話，Rust 的測試函式庫預設會獲取所有印出的標準輸出。舉例來說，如果我們在測試中呼叫 <code>println!</code> 然後測試通過的話，我們不會在終端機看到 <code>println!</code> 的輸出，我們只會看到一行表達測試通過的訊息。如果測試失敗，我們才會看到所有印出的標準輸出與失敗訊息。</p>
<p>舉例來說，範例 11-10 有個蠢蠢的函式只會印出它的參數並回傳 10，以及一個會通過的測試與一個會失敗的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;我得到的數值為 {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
</code></pre>
<p><span class="caption">範例 11-10：測試會呼叫 <code>println!</code> 的函式</span></p>
<p>當我們使用 <code>cargo test</code> 執行這些程式時，我們會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
我得到的數值為 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>注意到此輸出結果我們看不到 <code>我得到的數值為 4</code>，這是當測試通過時印出的訊息。這個輸出被獲取走了。而測試會失敗的標準輸出 <code>我得到的數值為 8</code> 則會出現在測試總結輸出的段落上，並同時顯示錯誤發生的原因。</p>
<p>如果我們希望在測試通過時也能看到印出的數值，我們可以用 <code>--show-output</code> 告訴 Rust 也在成功的測試顯示輸出結果。</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>當我們使用 <code>--show-output</code> 再次執行範例 11-10 的話，我們就能看到以下輸出：</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
我得到的數值為 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
我得到的數值為 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<h3 id="透過名稱來執行部分測試"><a class="header" href="#透過名稱來執行部分測試">透過名稱來執行部分測試</a></h3>
<p>有時執行完整所有的測試會很花時間。如果你正專注於程式碼的特定部分，你可能會想要只執行與該程式碼有關的測試。你可以向 <code>cargo test</code> 傳遞你想要執行的測試名稱作為引數。</p>
<p>為了解釋如何執行部分測試，我們將為 <code>add_two</code> 函式建立三個測試，如範例 11-11 所示，然後選擇其中一個執行。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre>
<p><span class="caption">範例 11-11：三個名稱不同的測試</span></p>
<p>如果我們沒有傳遞任何引數來執行測試的話，如我們前面看過的一樣，所有測試會平行執行：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<h4 id="執行單獨一個測試"><a class="header" href="#執行單獨一個測試">執行單獨一個測試</a></h4>
<p>我們可以傳遞任何測試函式的名稱給 <code>cargo test</code> 來只執行該測試：</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s

</code></pre>
<p>只有名稱為 <code>one_hundred</code> 的測試會執行，其他兩個的名稱並不符合。測試輸出會在總結的最後顯示 <code>2 filtered out</code> 告訴我們除了命令列執行的測試以外，還有更多其他測試。</p>
<p>我們無法用此方式指定多個測試名稱，只有第一個傳給 <code>cargo test</code> 有用。但我們有其他方式能執行數個測試。</p>
<h4 id="過濾執行數個測試"><a class="header" href="#過濾執行數個測試">過濾執行數個測試</a></h4>
<p>我們可以指定部分測試名稱，然後任何測試名稱中有相符的就會被執行。舉例來說，因為我們有兩個測試的名稱都包含 <code>add</code>，我們可以透過執行 <code>cargo test add</code> 來執行這兩個測試：</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
<p>此命令會執行所有名稱中包含 <code>add</code> 的測試，並過濾掉 <code>one_hundred</code> 的測試名稱。另外測試所在的模組也屬於測試名稱中，所以我們可以透過過濾模組名稱來執行該模組的所有測試。</p>
<h3 id="忽略某些測試除非特別指定"><a class="header" href="#忽略某些測試除非特別指定">忽略某些測試除非特別指定</a></h3>
<p>有時候有些特定的測試執行會花非常多時間，所以你可能希望在執行 <code>cargo test</code> 時能排除它們。與其列出所有你想要的測試作為引數，你可以在花時間的測試前加上 <code>ignore</code> 屬性詮釋來排除它們，如以下所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // 會執行一小時的程式碼
}
</code></pre>
<p>對於想排除的測試，我們在 <code>#[test]</code> 之後我們加上 <code>#[ignore]</code>。現在當我們執行我們的測試時，<code>it_works</code> 會執行但 <code>expensive_test</code> 就不會：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s

</code></pre>
<p><code>expensive_test</code> 函式會列在 <code>ignored</code>，如果我們希望只執行被忽略的測試，我們可以使用 <code>cargo test -- --ignored</code>：</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>透過控制哪些測試能執行，你能夠確保快速執行 <code>cargo test</code>。當你有時間能夠執行 <code>ignored</code> 的測試時，你可以執行 <code>cargo test -- --ignored</code> 來等待結果。如果你想執行所有程式，無論他們是不是被忽略的話，你可以執行 <code>cargo test -- --include-ignored</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="測試組織架構"><a class="header" href="#測試組織架構">測試組織架構</a></h2>
<p>如同本章開頭提到的，測試是個複雜的領域，不同的人可能使用不同的術語與組織架構。Rust 社群將測試分為兩大分類術語：單元測試和整合測試。<strong>單元測試</strong>（unit tests）比較小且較專注，傾向在隔離環境中一次只測試一個模組，且能夠測試私有介面。<strong>整合測試</strong>（integration tests）對於你的函式庫來說是個完全外部的程式碼，所以會如其他外部程式碼一樣使用你的程式碼，只能使用公開介面且每個測試可能會有數個模組。</p>
<p>這兩種測試都很重要，且能確保函式庫每個部分能在分別或一起執行的情況下，如你預期的方式運作。</p>
<h3 id="單元測試"><a class="header" href="#單元測試">單元測試</a></h3>
<p>單元測試的目的是要在隔離其他程式碼的狀況下測試每個程式碼單元，迅速查明程式碼有沒有如預期或非預期的方式運作。你會將單元測試放在 <em>src</em> 目錄中每個你要測試的程式同個檔案下。我們常見的做法是在每個檔案建立一個模組 <code>tests</code> 來包含測試函式，並用 <code>cfg(test)</code> 來詮釋模組。</p>
<h4 id="測試模組與-cfgtest"><a class="header" href="#測試模組與-cfgtest">測試模組與 <code>#[cfg(test)]</code></a></h4>
<p>測試模組上的 <code>#[cfg(test)]</code> 詮釋會告訴 Rust 當你執行 <code>cargo test</code> 才會編譯並執行測試程式碼。而不是當你執行 <code>cargo build</code>。當你想要建構函式庫時，這能節省編譯時間並降低編譯出的檔案所佔的空間，因為這些測試沒有被包含到。整合測試位於不同目錄，所以它們不需要 <code>#[cfg(test)]</code>。但是因為單元測試與程式碼位於相同的檔案下，你需要使用 <code>#[cfg(test)]</code> 來指明它們不應該被包含在編譯結果。</p>
<p>回想一下本章節第一個段落中我們建立了一個新專案 <code>adder</code>，並用 Cargo 為我們產生以下程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
<p>此程式碼是自動產生的測試模組。<code>cfg</code> 屬性代表的是 <em>configuration</em> 並告訴 Rust 以下項目只有在給予特定配置選項時才會被考慮。在此例中配置選項是 <code>test</code>，這是 Rust 提供用來編譯與執行測試的選項。使用 <code>cfg</code> 屬性的話，Cargo 只有在我們透過 <code>cargo test</code> 執行測試時才會編譯我們的測試程式碼。這包含此模組能可能需要的輔助函式，以及用 <code>#[test]</code> 詮釋的測試函式。</p>
<h4 id="測試私有函式"><a class="header" href="#測試私有函式">測試私有函式</a></h4>
<p>在測試領域的社群中對於是否應該直接測試私有函式一直存在著爭議，而且有些其他語言會讓測試私有函式變得很困難，甚至不可能。不管你認為哪個論點比較理想，Rust 的隱私權規則還是能讓你測試私有函式。考慮以下範例 11-12 擁有私有函式 <code>internal_adder</code> 的程式碼。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre>
<p><span class="caption">範例 11-12：測試私有函式</span></p>
<p>注意到函式 <code>internal_adder</code> 沒有標記為 <code>pub</code>。測試也只是 Rust 的程式碼，且 <code>tests</code> 也只是另一個模組。如同我們在<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">參考模組項目的路徑</a><!-- ignore -->段落討論到的，下層模組的項目可以使用該項目以上的模組。在此測試中，我們透過 <code>use super::*</code> 引入 <code>test</code> 模組上層的所有項目，所以測試能呼叫 <code>internal_adder</code>。如果你不認為私有函式應該測試，Rust 也沒有什麼好阻止你的地方。</p>
<h3 id="整合測試"><a class="header" href="#整合測試">整合測試</a></h3>
<p>在 Rust 中，整合測試對你的函式庫來說是完全外部的程式。它們使用你的函式庫的方式與其他程式碼一樣，所以它們只能呼叫屬於函式庫中公開 API 的函式。它們的目的是要測試你的函式庫屬個部分一起運作時有沒有正確無誤。單獨運作無誤的程式碼單元可能會在整合時出現問題，所以整合測試的程式碼的涵蓋率也很重要。要建立整合測試，你需要先有個 <em>tests</em> 目錄。</p>
<h4 id="tests-目錄"><a class="header" href="#tests-目錄"><em>tests</em> 目錄</a></h4>
<p>我們在專案目錄最上層在 <em>src</em> 旁建立一個 <em>tests</em> 目錄。Cargo 知道要從此目錄來尋找整合測試。我們接著就可以建立多少個測試都沒問題，Cargo 會編譯每個檔案成獨立的 crate。</p>
<p>讓我們來建立一個整合測試，將範例 11-12 的程式碼保留在 <em>src/lib.rs</em> 檔案中，然後建立一個 <em>tests</em> 目錄、一個叫做 <em>tests/integration_test.rs</em> 的檔案。你的目錄架構應該要長的像這樣：</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>請在 <em>tests/integration_test.rs</em> 輸入範例 11-13 的程式碼：</p>
<p><span class="filename">檔案名稱：tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">範例 11-13：<code>adder</code> crate 中函式的整合測試</span></p>
<p><code>tests</code> 目錄的每個檔案都是獨立的 crate，所以我們需要將函式庫引入每個測試 crate 的作用域中。因此我們在程式最上方加了 <code>use adder</code>，這在單元測試是不需要的。</p>
<p>我們不用對 <em>tests/integration_test.rs</em> 的任何程式碼詮釋 <code>#[cfg(test)]</code>。Cargo 會特別對待 <code>tests</code> 目錄並只在我們執行 <code>cargo test</code> 時，編譯此目錄的檔案。現在請執行 <code>cargo test</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>輸出結果中有三個段落，包含單元測試、整合測試與技術文件測試。要是有個段落的任何一個測試失敗的話，接下來的段落就不會執行。舉例來說，如果單元測試失敗了，我們就不會看到整合測試與技術文件測試的輸出，因為它們只會在所有單元測試都通過之後才會執行。</p>
<p>第一個段落的單元測試與我們看過的相同：每行會是每個單元測試（在此例是我們在範例 11-12 寫的 <code>internal</code>）最後附上單元測試的總結。</p>
<p>整合測試段落從 <code>Running tests/integration_test.rs</code> 開始，接著每行會是每個整合測試的測試函式，最後在 <code>Doc-tests adder</code> 段落開始前的那一行則是整合測試的總結結果。</p>
<p>每個整合測試檔案會有自己的段落，如果如果我們在 <em>tests</em> 目錄加入更多檔案的話，就會出現更多整合測試段落。</p>
<p>我們一樣能用測試函式的名稱來作為 <code>cargo test</code> 的引數，來執行特定整合測試。要執行特定整合測試檔案內的所有測試，可以用 <code>--test</code> 作為 <code>cargo test</code> 的引數並加上檔案名稱：</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>此命令會只執行 <em>tests/integration_test.rs</em> 檔案內的測試。</p>
<h4 id="整合測試的子模組"><a class="header" href="#整合測試的子模組">整合測試的子模組</a></h4>
<p>隨著你加入的整合測試越多，你可能會想要在 <em>tests</em> 目錄下產生更多檔案來協助組織它們。舉例來說，你以用測試函式測試的功能來組織它們。如同稍早提到的，<em>tests</em>  目錄下的每個檔案都會編譯成自己獨立的 crate，這有助於建立不同的作用域，這就像是使用者使用你的 crate 的可能環境。然而這也代表 <em>tests</em> 目錄的檔案不會和 <em>src</em> 的檔案行為一樣，也就是你在第七章學到如何拆開程式碼成模組與檔案的部分。</p>
<p>當你希望擁有一些能協助數個整合測試檔案的輔助函式，並遵循第七章的<a href="ch07-05-separating-modules-into-different-files.html">「將模組拆成不同檔案」</a><!-- ignore -->段落來提取它們到一個通用模組時，你就會發現 <em>tests</em> 目錄下的檔案行為是不同的。舉例來說，我們建立了 <em>tests/common.rs</em> 並寫了一個函式 <code>setup</code>，然後我們希望 <code>setup</code> 能被不同測試檔案的數個測試函式呼叫：</p>
<p><span class="filename">檔案名稱：tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // 在此設置測試函式庫會用到的程式碼
}
</code></pre>
<p>當我們再次執行程式時，我們會看到測試輸出多了一個 <em>common.rs</em> 檔案的段落，就算該檔案沒有包含任何測試函式，而且我們也還沒有在任何地方呼叫 <code>setup</code> 函式：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>讓 <code>common</code> 出現在測試結果並顯示 <code>running 0 tests</code> 並不是我們想做的事。我們只是想要分享一些程式碼給其他整合測試檔案而已。</p>
<p>要防止 <code>common</code> 出現在測試輸出，我們不該建立 <em>tests/common.rs</em>，而是要建立 <em>tests/common/mod.rs</em>。專案目錄現在應該要長的像這樣：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>這是另一個 Rust 知道的舊版命名形式，我們在第七章的<a href="ch07-05-separating-modules-into-different-files.html#%E5%85%B6%E4%BB%96%E7%A8%AE%E7%9A%84%E6%AA%94%E6%A1%88%E8%B7%AF%E5%BE%91">「其他種的檔案路徑」</a><!-- ignore -->段落有提過。這樣命名檔案的話會告訴 Rust 不要將 <code>common</code> 模組視為整合測試檔案。當我們將 <code>setup</code> 函式程式碼移到 <em>tests/common/mod.rs</em> 並刪除 <em>tests/common.rs</em> 檔案時，原本的段落就不會再出現在測試輸出。<em>tests</em> 目錄下子目錄的檔案不會被編譯成獨立 crate 或在測試輸出顯示段落。</p>
<p>在我們建立 <em>tests/common/mod.rs</em> 之後，我們可以將它以模組的形式用在任何整合測試檔案中。以下是在 <em>tests/integration_test.rs</em> 的 <code>it_adds_two</code> 測試中呼叫函式 <code>setup</code> 的範例：</p>
<p><span class="filename">檔案名稱：tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>注意到 <code>mod common;</code> 的宣告與我們在範例 7-21 說明的模組宣告方式一樣。然而後在測試函式中，我們就可以呼叫函式 <code>common::setup()</code>。</p>
<h4 id="執行檔-crate-的整合測試"><a class="header" href="#執行檔-crate-的整合測試">執行檔 Crate 的整合測試</a></h4>
<p>如果我們的專案是只包含 <em>src/main.rs</em> 檔案的執行檔 crate 而沒有 <em>src/lib.rs</em> 檔案的話，我們無法在 <em>tests</em> 目錄下建立整合測試，也無法將 <em>src/main.rs</em> 檔案中定義的函式透過 <code>use</code> 陳述式引入作用域。只有函式庫 crate 能公開函式給其他 crate 使用，執行檔 crate 只用於獨自執行。</p>
<p>這也是為何 Rust 專案為執行檔提供直白的 <em>src/main.rs</em> 檔案並允許呼叫 <em>src/lib.rs</em> 檔案中的邏輯程式碼。使用這樣子的架構的話，整合測試<strong>可以</strong>透過 <code>use</code> 來測試函式庫 crate，並讓重點功能可以公開使用。如果重點功能可以運作的話，那 <em>src/main.rs</em> 檔案中剩下的程式碼部分也能夠如期執行，而這一小部分就不必特定做測試。</p>
<h2 id="總結-10"><a class="header" href="#總結-10">總結</a></h2>
<p>Rust 的測試功能提供了判定程式碼怎樣才算正常運作的方法，以確保它能以你預期的方式運作，就算當你做了改變時也是如此。單元測試分別測試函式庫中每個不同的部分，且能測試私有實作細節。整合測試檢查函式庫數個部分一起執行時是否正確無誤，且它們使用函式庫公開 API 來測試程式碼的行為與外部程式碼使用的方式一樣。雖然 Rust 型別系統與所有權規則能避免某些種類的程式錯誤，測試還是減少邏輯程式錯誤的重要辦法，讓你的程式碼能如預期行為運作。</p>
<p>讓我們統整此章節以及之前的章節所學到的知識來寫一支專案吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-專案建立一個命令列程式"><a class="header" href="#io-專案建立一個命令列程式">I/O 專案：建立一個命令列程式</a></h1>
<p>本章節用來回顧你目前學過的許多技能，並探索些標準函式庫中的更多功能。我們會來建立個命令列工作來處理檔案與命令列輸入／輸出，以此練習些你已經掌握的 Rust 概念。</p>
<p>Rust 的速度、安全、單一執行檔輸出與跨平台支援使其成為建立命令列工具的絕佳語言。所以在我們的專案中，我們要寫出我們自己的經典命令列工具 <code>grep</code>（<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint）。在最簡單的使用場合中，<code>grep</code> 會搜尋指定檔案中的指定字串。為此 <code>grep</code> 會接收一個檔案名稱與一個字串作為其引數。然後它會讀取檔案、在該檔案中找到包含字串引數的行數，並印出這些行數。</p>
<p>在過程中，我們會展示如何讓我們的命令列工具和其他許多命令列工具一樣使用終端機的功能。我們會讀取一個環境變數的數值來讓使用者可以配置此工具的行為。我們還會將錯誤訊息在控制台中的標準錯誤（<code>stderr</code>）顯示而非標準輸出（<code>stdout</code>）。所以舉例來說，使用者可以將成功的標準輸出重新導向至一個檔案，並仍能在螢幕上看到錯誤訊息。</p>
<p>其中一位 Rust 社群成員 Andrew Gallant 已經有建立個功能完善且十分迅速的 <code>grep</code> 版本，叫做 <code>ripgrep</code>。相比之下，我們的版本會相對簡單許多，但此章節能給你些背景知識，來幫你理解像是 <code>ripgrep</code> 等真實專案。</p>
<p>我們的 <code>grep</code> 專案會組合你所學過的各種概念：</p>
<ul>
<li>組織程式碼（使用你在<a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">第七章</a><!--   ignore -->所學的模組）</li>
<li>使用向量與字串（<a href="ch08-00-common-collections.html">第八章</a><!-- ignore -->的集合）</li>
<li>錯誤處理（<a href="ch09-00-error-handling.html">第九章</a><!-- ignore -->）</li>
<li>合理的使用特徵與生命週期（<a href="ch10-00-generics.html">第十章</a><!-- ignore -->）</li>
<li>測試（<a href="ch11-00-testing.html">第十一章</a><!-- ignore -->）</li>
</ul>
<p>我們還會簡單介紹閉包、疊代器與特徵物件，這些在<a href="ch13-00-functional-features.html">第十三章</a><!-- ignore -->與<a href="ch17-00-oop.html">第十七章</a><!-- ignore -->會做詳細介紹。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接受命令列引數"><a class="header" href="#接受命令列引數">接受命令列引數</a></h2>
<p>一如往常我們用 <code>cargo new</code> 建立新的專案，我們將我們的專案命名為 <code>minigrep</code> 來與很可能已經在你系統中的 <code>grep</code> 工具做區別。</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>第一項任務是要讓 <code>minigrep</code> 能接收兩個命令列引數：檔案路徑與欲搜尋的字串。也就是說，我們想要能夠使用 <code>cargo run</code> 加上兩條連字號來指示接下來的引號用於我們的程式而不是 <code>cargo</code>，然後輸入欲搜尋的字串與要被搜尋的檔案路徑來執行程式，如以下所示：</p>
<pre><code class="language-console">$ cargo run -- searchstring example-filename.txt
</code></pre>
<p>但現在由 <code>cargo new</code> 產生的程式還無法處理我們給予的引數。<a href="https://crates.io/">crates.io</a> 有些函式庫可以幫助程式接收命令列中的引數，但有鑑於你要學習此概念，讓我們親自來實作一個。</p>
<h3 id="讀取引數數值"><a class="header" href="#讀取引數數值">讀取引數數值</a></h3>
<p>要讓 <code>minigrep</code> 能夠讀取我們傳入的命令列引數數值，我們需要使用 Rust 標準函式庫中提供的 <code>std::env::args</code> 函式。此函式會回傳一個包含我們傳給 <code>minigrep</code> 的命令列引數的疊代器（iterator）。我們會在<a href="ch13-00-functional-features.html">第十三章</a><!-- ignore -->詳細解釋疊代器。現在你只需要知道疊代器的兩項重點：疊代器會產生一系列的數值，然後我們可以對疊代器呼叫 <code>collect</code> 方法來將其轉換成像是向量的集合，來包含疊代器產生的所有元素。</p>
<p>範例 21-1 的程式碼能讓你的 <code>minigrep</code> 程式能夠讀取任何傳入的命令列引數，然後收集數值成一個向量。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    dbg!(args);
}
</code></pre></pre>
<p><span class="caption">範例 12-1：收集命令列引數至向量中並顯示它們</span></p>
<p>首先我們透過 <code>use</code> 陳述式將 <code>std::env</code> 模組引入作用域，讓我們可以使用它的 <code>args</code> 函式。注意到 <code>std::env::args</code> 函式位於兩層模組下。如同我們在<a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#%E5%BB%BA%E7%AB%8B%E6%85%A3%E7%94%A8%E7%9A%84-use-%E8%B7%AF%E5%BE%91">第七章</a><!-- ignore -->談過的，如果我們要用的函式模組路徑超過一層以上的話，我們選擇將上層模組引入作用域中，而不是函式本身。這樣的話，我們可以輕鬆使用 <code>std::env</code> 中的其他函式。而且這也比直接加上 <code>use std::env::args</code> 然後只使用 <code>args</code> 來呼叫函式還要明確些，因為 <code>args</code> 容易被誤認成是由目前模組定義的函式。</p>
<blockquote>
<h3 id="args-函式與無效的-unicode"><a class="header" href="#args-函式與無效的-unicode"><code>args</code> 函式與無效的 Unicode</a></h3>
<p>值得注意的是如果任何引數包含無效 Unicode 的話，<code>std::env::args</code> 就會恐慌。如果你的程式想要接受包含無效 Unicode 引數的話，請改使用 <code>std::env::args_os</code>。該函式回傳會產生 <code>OsString</code> 數值的疊代器，而非 <code>String</code> 數值。我們出於簡單方便所以在此使用 <code>std::env::args</code>，因為 <code>OsString</code> 在不同平台中數值會有所差異，且會比 <code>String</code> 數值還要難處理。</p>
</blockquote>
<p>我們在 <code>main</code> 中的第一行呼叫 <code>env::args</code>，然後馬上使用 <code>collect</code> 來將疊代器轉換成向量，這會包含疊代器產生的所有數值。我們可以使用 <code>collect</code> 函式來建立許多種集合，所以我們顯式詮釋 <code>args</code> 的型別來指定我們想要字串向量。雖然我們很少需要在 Rust 中詮釋型別，<code>collect</code> 是其中一個你常常需要詮釋的函式，因為 Rust 無法推斷出你想要何種集合。</p>
<p>最後，我們使用除錯巨集來顯示向量。讓我們先嘗試不用引數來執行程式碼，再用兩個引數來執行：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
]
</code></pre>
<pre><code class="language-console">$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    &quot;target/debug/minigrep&quot;,
    &quot;needle&quot;,
    &quot;haystack&quot;,
]
</code></pre>
<p>值得注意的是向量中第一個數值為 <code>&quot;target/debug/minigrep&quot;</code>，這是我們的執行檔名稱。這與 C 的引數列表行為相符，讓程式在執行時能使用它們被呼叫的名稱路徑。存取程式名稱通常是很實用的，像是你能將它顯示在訊息中，或是依據程式被呼叫的命令列別名來改變程式的行為。但考慮本章節的目的，我們會忽略它並只儲存我們想要的兩個引數。</p>
<h3 id="將引數數值儲存至變數"><a class="header" href="#將引數數值儲存至變數">將引數數值儲存至變數</a></h3>
<p>目前程式能夠取得命令列引數指定的數值。現在我們想要將這兩個引數存入變數中，讓我們可以在接下來的程式中使用數值，如範例 12-2 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let file_path = &amp;args[2];

    println!(&quot;搜尋 {}&quot;, query);
    println!(&quot;目標檔案為 {}&quot;, file_path);
}
</code></pre>
<p><span class="caption">範例 12-2：建立變數來儲存搜尋引數與檔案路徑引數</span></p>
<p>如我們印出向量時所看到的，向量的第一個數值 <code>args[0]</code> 會是程式名稱，所以我們從引數 <code>1</code> 開始。<code>minigrep</code> 接收的第一個引數會是我們要搜尋的字串，所以我們將第一個引數的參考賦值給變數 <code>query</code>。第二個引數會是檔案路徑，所以我們將第二個引數的參考賦值給 <code>file_path</code>。</p>
<p>我們暫時印出這些變數的數值來證明程式碼運作無誤。讓我們用引數 <code>test</code> 與 <code>sample.txt</code> 來再次執行程式：</p>
<pre><code class="language-console">$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
搜尋 test
目標檔案為 sample.txt
</code></pre>
<p>很好，程式能執行！我們想要的引數數值都有儲存至正確的變數中。之後我們會對特定潛在錯誤的情形來加上一些錯誤處理，像是當使用者沒有提供引數的情況。現在我們先忽略這樣的情況，並開始加上讀取檔案的功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="讀取檔案"><a class="header" href="#讀取檔案">讀取檔案</a></h2>
<p>現在我們要加上能夠讀取 <code>file_path</code> 中命令列引數指定的檔案功能。首先我們需要有個檔案範本能讓我們測試，我們可以建立一個文字檔，其中由數行重複的單字組成少量文字。範例 12-3 Emily Dickinson 的詩就是不錯的選擇！在專案根目錄建立一個檔案叫做 <em>poem.txt</em>，然後輸入此詩「I’m Nobody! Who are you?」</p>
<p><span class="filename">檔案名稱：poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">範例 12-3：以 Emily Dickinson 的詩作為絕佳測試範本</span></p>
<p>有了這些文字，接著修改 <em>src/main.rs</em> 來加上讀取檔案的程式碼，如範例 12-4 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground">use std::env;
use std::fs;

fn main() {
    // --省略--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let file_path = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, query);
</span>    println!(&quot;目標檔案為 {}&quot;, file_path);

    let contents = fs::read_to_string(file_path)
        .expect(&quot;應該要能夠讀取檔案&quot;);

    println!(&quot;文字內容：\n{contents}&quot;);
}
</code></pre>
<p><span class="caption">範例 12-4：讀取第二個引數指定的檔案內容</span></p>
<p>首先，我們加上另一個 <code>use</code> 陳述式來將標準函式庫中的另一個相關部分引入：我們需要 <code>std::fs</code> 來處理檔案。</p>
<p>在 <code>main</code> 中，我們加上新的陳述式：<code>fs::read_to_string</code> 會接收 <code>file_path</code>、開啟該檔案並回傳檔案內容的 <code>Result&lt;String&gt;</code>。</p>
<p>在陳述式之後，我們再次加上暫時的 <code>println!</code> 陳述式來在讀取檔案之後，顯示 <code>contents</code> 的數值，讓我們能檢查程式目前運作無誤。</p>
<p>讓我們用任何字串作為第一個命令列引數（因為我們還沒實作搜尋的部分）並與 <em>poem.txt</em> 檔案作為第二個引數來執行此程式碼：</p>
<pre><code class="language-console">$ cargo run -- the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
搜尋 the
目標檔案為 poem.txt
文字內容：
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>很好！程式碼有讀取並印出檔案內容。但此程式碼有些缺陷。<code>main</code> 函式負責太多事情了，通常如果每個函式都只負責一件事的話，函式才能清楚直白且易於維護。另一個問題是我們盡可能地處理錯誤。由於程式還很小，此缺陷不算什麼大問題，但隨著程式增長時，這會越來越難清楚地修正。在開發程式時盡早重構是很好的做法，因為重構少量的程式碼會比較簡單。接下來就讓我們開始吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過重構來改善模組性與錯誤處理"><a class="header" href="#透過重構來改善模組性與錯誤處理">透過重構來改善模組性與錯誤處理</a></h2>
<p>為了改善我們的程式，我們需要修正四個問題，這與程式架構與如何處理潛在錯誤有關。首先，我們的 <code>main</code> 函式會處理兩件任務：它得解析引數並讀取檔案。隨著我們的程式增長，<code>main</code> 函式中要處理的任務就會增加。要是一個函式有這麼多責任，它就會越來越難理解、越難測試並且難在不破壞其他部分的情況下做改變。我們最好能將不同功能拆開，讓每個函式只負責一項任務。</p>
<p>而這也和第二個問題有關：雖然 <code>query</code> 與 <code>file_path</code> 是我們程式的設置變數，而變數 <code>contents</code> 則用於程式邏輯。隨著 <code>main</code> 增長，我們會需要引入越多變數至作用域中。而作用域中有越多變數，我們就越難追蹤每個變數的用途。我們最好是將設置變數集結成一個結構體，讓它們的用途清楚明白。</p>
<p>第三個問題是當讀取檔案失敗時，我們使用 <code>expect</code> 來印出錯誤訊息，但是錯誤訊息只印出 <code>應該要能夠讀取檔案</code>。讀取檔案可以有好幾種失敗的方式：舉例來說，檔案可能不存在，或是我們可能沒有權限能開啟它。目前不管原因為何，我們都只印出相同的錯誤訊息，這並沒有給使用者足夠的資訊！</p>
<p>第四，我們重複使用 <code>expect</code> 來處理不同錯誤，而如果有使用者沒有指定足夠的引數來執行程式的話，他們會從 Rust 獲得 <code>index out of bounds</code> 的錯誤，這並沒有清楚解釋問題。最好是所有的錯誤處理程式碼都可以位於同個地方，讓未來的維護者只需要在此處來修改錯誤處理的程式碼。將所有錯誤處理的程式碼置於同處也能確保我們能提供對終端使用者有意義的訊息。</p>
<p>讓我們來重構專案以解決這四個問題吧。</p>
<h3 id="分開執行檔專案的任務"><a class="header" href="#分開執行檔專案的任務">分開執行檔專案的任務</a></h3>
<p><code>main</code> 函式負責多數任務的組織分配問題在許多執行檔專案中都很常見。所以 Rust 社群開發出了一種流程，這在當 <code>main</code> 開始變大時，能作為分開執行檔程式中任務的指導原則。此流程有以下步驟：</p>
<ul>
<li>將你的程式分成 <em>main.rs</em> 與 <em>lib.rs</em> 並將程式邏輯放到 <em>lib.rs</em>。</li>
<li>只要你的命令列解析邏輯很小，它可以留在 <em>main.rs</em>。</li>
<li>當命令行解析邏輯變得複雜時，就將其從 <em>main.rs</em> 移至 <em>lib.rs</em>。</li>
</ul>
<p>在此流程之後的 <code>main</code> 函式應該要只負責以下任務：</p>
<ul>
<li>透過引數數值呼叫命令列解析邏輯</li>
<li>設置任何其他的配置</li>
<li>呼叫 <em>lib.rs</em> 中的 <code>run</code> 函式</li>
<li>如果 <code>run</code> 回傳錯誤的話，處理該錯誤</li>
</ul>
<p>此模式用於分開不同任務：<em>main.rs</em> 處理程式的執行，然後 <em>lib.rs</em> 處理眼前的所有任務邏輯。因為你無法直接測試 <code>main</code>，此架構讓你能測試所有移至 <em>lib.rs</em> 的程式函式邏輯。留在 <em>main.rs</em> 的程式碼會非常小，所以容易直接用閱讀來驗證。讓我們用此流程來重構程式吧。</p>
<h4 id="提取引數解析器"><a class="header" href="#提取引數解析器">提取引數解析器</a></h4>
<p>我們會提取解析引數的功能到一個 <code>main</code> 會呼叫的函式中，以將命令列解析邏輯妥善地移至 <em>src/lib.rs</em>。範例 12-5 展示新的 <code>main</code> 會呼叫新的函式 <code>parse_config</code>，而此函式我們先暫時留在 <em>src/main.rs</em>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, file_path) = parse_config(&amp;args);

    // --省略--
<span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(file_path)
</span><span class="boring">        .expect(&quot;應該要能夠讀取檔案&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let file_path = &amp;args[2];

    (query, file_path)
}
</code></pre>
<p><span class="caption">範例 12-5：從 <code>main</code> 提取 <code>parse_config</code> 函式</span></p>
<p>我們仍然收集命令列引數至向量中，但不同於在 <code>main</code> 函式中將索引 1 的引數數值賦值給變數 <code>query</code> 且將索引 2 的引數數值賦值給變數 <code>file_path</code>，我們將整個向量傳至 <code>parse_config</code> 函式。<code>parse_config</code> 函式會擁有決定哪些引數要賦值給哪些變數的邏輯，並將數值回傳給 <code>main</code>。我們仍然在 <code>main</code> 中建立變數 <code>query</code> and <code>file_path</code>，但 <code>main</code> 不再負責決定命令列引數與變數之間的關係。</p>
<p>此重構可能對我們的小程式來說有點像是殺雞焉用牛刀，但是我們正一小步一小步地累積重構。做了這項改變後，請再次執行程式來驗證引數解析有沒有正常運作。經常檢查你的進展是很好的，這能幫助你找出問題發生的原因。</p>
<h4 id="集結配置數值"><a class="header" href="#集結配置數值">集結配置數值</a></h4>
<p>我們可以再進一步改善 <code>parse_config</code> 函式。目前我們回傳的是元組，但是我們馬上又將元組拆成獨立部分。這是個我們還沒有建立正確抽象的信號。</p>
<p>另外一個告訴我們還有改善空間的地方是 <code>parse_config</code> 名稱中的 <code>config</code>，這指示我們回傳的兩個數值是相關的，且都是配置數值的一部分。我們現在沒有確實表達出這樣的資料結構，而只有將兩個數值組合成一個元組而已，我們可以將這兩個數值存入一個結構體，並對每個結構體欄位給予有意義的名稱。這樣做能讓未來的維護者可以清楚知道這些數值的不同與關聯，以及它們的用途。</p>
<p>範例 12-6 改善了 <code>parse_config</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;搜尋 {}&quot;, config.query);
    println!(&quot;目標檔案為 {}&quot;, config.file_path);

    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;應該要能夠讀取檔案&quot;);

    // --省略--
<span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span>}

struct Config {
    query: String,
    file_path: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let file_path = args[2].clone();

    Config { query, file_path }
}
</code></pre>
<p><span class="caption">範例 12-6：重構 <code>parse_config</code> 來回傳 <code>Config</code> 結構體實例</span></p>
<p>我們定義了一個結構體 <code>Config</code> 其欄位有 <code>query</code> 與 <code>file_path</code>。<code>parse_config</code> 的簽名現在指明它會回傳一個 <code>Config</code> 數值。在 <code>parse_config</code> 的本體中，我們原先回傳 <code>args</code> 中 <code>String</code> 數值參考的字串切片，現在我們定義 <code>Config</code> 來包含具所有權的 <code>String</code> 數值。<code>main</code> 中的 <code>args</code> 變數是引數數值的擁有者，而且只是借用它們給 <code>parse_config</code> 函式，這意味著如果 <code>Config</code> 嘗試取得 <code>args</code> 中數值的所有權的話，我們會違反 Rust 的借用規則。</p>
<p>我們可以用許多不同的方式來管理 <code>String</code> 的資料，最簡單（卻較無效率）的方式是對數值呼叫 <code>clone</code> 方法。這會複製整個資料讓 <code>Config</code> 能夠擁有，這會比參考字串資料還要花時間與記憶體。然而克隆資料讓我們的程式碼比較直白，因為在此情況下我們就不需要管理參考的生命週期，犧牲一點效能以換取簡潔性是值得的。</p>
<blockquote>
<h3 id="使用-clone-的權衡取捨"><a class="header" href="#使用-clone-的權衡取捨">使用 <code>clone</code> 的權衡取捨</a></h3>
<p>由於 <code>clone</code> 會有運行時消耗，所以許多 Rustaceans 傾向於避免使用它來修正所有權問題。在<a href="ch13-00-functional-features.html">第十三章</a><!-- ignore -->中，你會學到如何更有效率的處理這種情況。但現在我們可以先複製字串來繼續進行下去，因為你只複製了一次，而且檔案路徑與搜尋字串都算很小。先寫出較沒有效率但可執行的程式會比第一次就要過分優化還來的好。隨著你對 Rust 越熟練，你的確就可以從有效率的解決方案開始，但現在呼叫 <code>clone</code> 是完全可以接受的。</p>
</blockquote>
<p>我們更新 <code>main</code> 來將 <code>parse_config</code> 回傳的 <code>Config</code> 實例儲存至 <code>config</code> 變數中，並更新之前分別使用變數 <code>query</code> 與 <code>file_path</code> 的程式碼段落來改使用 <code>Config</code> 結構體中的欄位。</p>
<p>現在我們的程式碼更能表達出 <code>query</code> 與 <code>file_path</code> 是相關的，而且它們的目的是配置程式的行為。任何使用這些數值的程式碼都會從 <code>config</code> 實例中的欄位名稱知道它們的用途。</p>
<h4 id="建立-config-的建構子"><a class="header" href="#建立-config-的建構子">建立 <code>Config</code> 的建構子</a></h4>
<p>目前我們將負責解析命令列引數的邏輯從 <code>main</code> 移至 <code>parse_config</code> 函式。這樣做能幫助我們理解 <code>query</code> 與 <code>file_path</code> 數值是相關的，且此關係應該要能在我們的程式碼中表達出來。然後我們增加了結構體 <code>Config</code> 來描述 <code>query</code> 與 <code>file_path</code> 的相關性，並在 <code>parse_config</code> 函式中將數值名稱作為結構體欄位名稱來回傳。</p>
<p>所以現在 <code>parse_config</code> 函式的目的是要建立 <code>Config</code> 實例，我們可以將 <code>parse_config</code> 從普通的函式變成與 <code>Config</code> 結構體相關連的 <code>new</code> 函式。這樣做能讓程式碼更符合慣例。我們可以對像是 <code>String</code> 等標準函式庫中的型別呼叫 <code>String::new</code> 來建立實例。同樣地，透過將 <code>parse_config</code> 改為 <code>Config</code> 的關聯函式 <code>new</code>，我們可以透過呼叫 <code>Config::new</code> 來建立 <code>Config</code> 的實例。範例 12-7 正是我們要作出的改變。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust should_panic noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;應該要能夠讀取檔案&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span>
    // --省略--
}

// --省略--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let file_path = args[2].clone();

        Config { query, file_path }
    }
}
</code></pre>
<p><span class="caption">範例 12-7：變更 <code>parse_config</code> 成 <code>Config::new</code></span></p>
<p>我們更新了 <code>main</code> 原先呼叫 <code>parse_config</code> 的地方來改呼叫 <code>Config::new</code>。我們變更了 <code>parse_config</code> 的名稱成 <code>new</code> 並移入 <code>impl</code> 區塊中，讓 <code>new</code> 成為 <code>Config</code> 的關聯函式。請嘗試再次編譯此程式碼來確保它能執行。</p>
<h3 id="修正錯誤處理"><a class="header" href="#修正錯誤處理">修正錯誤處理</a></h3>
<p>現在我們要來修正錯誤處理。回想一下要是 <code>args</code>向量中的項目太少的話，嘗試取得向量中索引 1 或索引 2 的數值的話可能就會導致程式恐慌。試著不用任何引數執行程式的話，它會產生以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p><code>index out of bounds: the len is 1 but the index is 1</code> 這行是給程式設計師看的錯誤訊息。這無法協助我們的終端使用者理解他們該怎麼處理。讓我們來修正吧。</p>
<h4 id="改善錯誤訊息"><a class="header" href="#改善錯誤訊息">改善錯誤訊息</a></h4>
<p>在範例 12-8 中，我們在 <code>new</code> 函式加上了一項檢查來驗證 slice 是否夠長，接著才會取得索引 1 和 2。如果 slice 不夠長的話，程式就會恐慌並顯示更清楚的錯誤訊息。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;應該要能夠讀取檔案&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --省略--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;引數不足&quot;);
        }
        // --省略--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, file_path }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-8：新增對引數數量的檢查</span></p>
<p>此程式碼類似於我們在<a href="ch09-03-to-panic-or-not-to-panic.html#%E5%BB%BA%E7%AB%8B%E8%87%AA%E8%A8%82%E5%9E%8B%E5%88%A5%E4%BE%86%E9%A9%97%E8%AD%89">範例 9-13 寫的 <code>Guess::new</code> 函式</a><!-- ignore -->，在那裡當 <code>value</code> 超出有效數值的範圍時，我們就呼叫 <code>panic!</code>。然而在此我們不是檢查數值的範圍，而是檢查 <code>args</code> 的長度是否至少為 3，然後函式剩餘的段落都能在假設此條件成立情況下正常執行。如果 <code>args</code> 的項目數量少於三的話，此條件會為真，然後我們就會立即呼叫 <code>panic!</code> 巨集來結束程式。</p>
<p>在 <code>new</code> 多了這些額外的程式碼之後，讓我們不用任何引數再次執行程式，來看看錯誤訊息為何：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at '引數不足', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>這樣的輸出就好多了，我們現在有個合理的錯誤訊息。然而我們還是顯示了一些額外資訊給使用者。也許在此使用範例 9-13 的技巧並不是最好的選擇，如同<a href="ch09-03-to-panic-or-not-to-panic.html#%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86%E7%9A%84%E6%8C%87%E5%B0%8E%E5%8E%9F%E5%89%87">第九章所提及的</a><!-- ignore -->，<code>panic!</code> 的呼叫比較屬於程式設計問題，而不是使用問題。我們可以改使用第九章的其他技巧，像是<a href="ch09-02-recoverable-errors-with-result.html">回傳 <code>Result</code></a><!-- ignore -->來表達是成功還是失敗。</p>
<h4 id="回傳-result-而非呼叫-panic"><a class="header" href="#回傳-result-而非呼叫-panic">回傳 <code>Result</code> 而非呼叫 <code>panic!</code></a></h4>
<p>我們可以回傳 <code>Result</code> 數值，在成功時包含 <code>Config</code> 的實例並在錯誤時描述問題原因。我們也將函式名稱從 <code>new</code> 改為 <code>build</code>，因為許多開發者通常預期 <code>new</code> 函式不會失敗。當 <code>Config::build</code> 與 <code>main</code> 溝通時，我們可以使用 <code>Result</code> 型別來表達這裡有問題發生。然後我們改變 <code>main</code> 來將 <code>Err</code> 變體轉換成適當的錯誤訊息給使用者，而不是像呼叫 <code>panic!</code> 時出現圍繞著 <code>thread 'main'</code> 與 <code>RUST_BACKTRACE</code> 的文字。</p>
<p>範例 12-9 顯示我們得改變 <code>Config::build</code> 的回傳值並讓函式本體回傳 <code>Result</code>。注意到這還不能編譯，直到我們也更新 <code>main</code> 為止，這會在下個範例解釋。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;應該要能夠讀取檔案&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;引數不足&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        Ok(Config { query, file_path })
    }
}
</code></pre>
<p><span class="caption">範例 12-9：從 <code>Config::build</code> 回傳 <code>Result</code></span></p>
<p>我們的 <code>build</code> 函式現在會回傳 <code>Result</code>，在成功時會有 <code>Config</code> 實例，而在錯誤時會有個 <code>&amp;'static str</code>。我們的錯誤值永遠會是有 <code>'static</code> 生命週期的字串字面值。</p>
<p>我們在 <code>build</code> 函式本體作出了兩項改變：不同於呼叫 <code>panic!</code>，當使用者沒有傳遞足夠引數時，我們現在會回傳 <code>Err</code> 數值。此外我們也將 <code>Config</code> 封裝進 <code>Ok</code> 作為回傳值。這些改變讓函式能符合其新的型別簽名。</p>
<p>從 <code>Config::build</code> 回傳 <code>Err</code> 數值讓 <code>main</code> 函式能處理 <code>build</code> 函式回傳的 <code>Result</code> 數值，並明確地在錯誤情況下離開程序。</p>
<h4 id="呼叫-configbuild-並處理錯誤"><a class="header" href="#呼叫-configbuild-並處理錯誤">呼叫 <code>Config::build</code> 並處理錯誤</a></h4>
<p>為了能處理錯誤情形並印出對使用者友善的訊息，我們需要更新 <code>main</code> 來處理 <code>Config::build</code> 回傳的 <code>Result</code>，如範例 12-10 所示。我們還要負責用一個非零的錯誤碼來離開命令列工具，這原先是 <code>panic!</code> 會處理的，現在我們得自己實作。非零退出狀態是個常見信號，用來告訴呼叫程式的程序，該程式離開時有個錯誤狀態。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        println!(&quot;解析引數時出現問題：{err}&quot;);
        process::exit(1);
    });

    // --省略--
<span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)
</span><span class="boring">        .expect(&quot;應該要能夠讀取檔案&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-10：如果建立新的 <code>Config</code> 失敗時會用錯誤碼離開</span></p>
<p>在此範例中，我們使用一個還沒詳細介紹的方法 <code>unwrap_or_else</code>，這定義在標準函式庫的 <code>Result&lt;T, E&gt;</code> 中。使用 <code>unwrap_or_else</code> 讓我們能定義一些自訂的非 <code>panic!</code> 錯誤處理。如果 <code>Result</code> 數值為 <code>Ok</code>，此方法行為就類似於 <code>unwrap</code>，它會回傳<code>Ok</code> 所封裝的內部數值。然而，如果數值為 <code>Err</code> 的話，此方法會呼叫<strong>閉包</strong>（closure）內的程式碼，這會是由我們所定義的匿名函式並作為引數傳給 <code>unwrap_or_else</code>。我們會在<a href="ch13-00-functional-features.html">第十三章</a><!-- ignore -->詳細介紹閉包。現在你只需要知道 <code>unwrap_or_else</code> 會傳遞 <code>Err</code> 的內部數值，在此例中就是我們在範例 12-9 新增的靜態字串「引數不足」，將此數值傳遞給閉包中兩條直線之間的 <code>err</code> 引數。閉包內的程式碼就可以在執行時使用 <code>err</code> 數值。</p>
<p>我們新增了一行 <code>use</code> 來將標準函式庫中的 <code>process</code> 引入作用域。在錯誤情形下要執行的閉包程式碼只有兩行：我們印出 <code>err</code> 數值並呼叫 <code>process::exit</code>。<code>process::exit</code> 函式會立即停止程式並回傳給予的數字來作為退出狀態碼。這與範例 12-8 我們使用 <code>panic!</code> 來處理的方式類似，但我們不再顯示多餘的輸出結果。讓我們試試看：</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
解析引數時出現問題：引數不足
</code></pre>
<p>很好！這樣的輸出結果對使用者友善多了。</p>
<h3 id="從-main-提取邏輯"><a class="header" href="#從-main-提取邏輯">從 <code>main</code> 提取邏輯</a></h3>
<p>現在我們完成配置解析的重構了，接下來輪到程式邏輯了。如同我們在<a href="ch12-03-improving-error-handling-and-modularity.html#%E5%88%86%E9%96%8B%E5%9F%B7%E8%A1%8C%E6%AA%94%E5%B0%88%E6%A1%88%E7%9A%84%E4%BB%BB%E5%8B%99">「分開執行檔專案的任務」</a><!-- ignore -->中所提及的，我們會提取一個函式叫做 <code>run</code>，這會存有目前 <code>main</code> 函式中除了設置配置或處理錯誤以外的所有邏輯。當我們完成後，<code>main</code> 會變得非常簡潔，且能輕鬆用肉眼來驗證，然後我就能對所有其他邏輯進行測試了。</p>
<p>範例 12-11 提取了 <code>run</code> 函式。目前我們在提取函式時，會逐步作出小小的改善。我們仍然在 <em>src/main.rs</em> 底下定義函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --省略--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;解析引數時出現問題：{err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;搜尋 {}&quot;, config.query);
    println!(&quot;目標檔案為 {}&quot;, config.file_path);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.file_path)
        .expect(&quot;應該要能夠讀取檔案&quot;);

    println!(&quot;文字內容：\n{contents}&quot;);
}

// --省略--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-11：提取 <code>run</code> 函式來包含剩餘的程式邏輯</span></p>
<p><code>run</code> 現在會包含 <code>main</code> 中從讀取文件開始的所有剩餘邏輯。<code>run</code> 函式會接收 <code>Config</code> 實例來作為引數。</p>
<h4 id="從-run-函式回傳錯誤"><a class="header" href="#從-run-函式回傳錯誤">從 <code>run</code> 函式回傳錯誤</a></h4>
<p>隨著剩餘程式邏輯都移至 <code>run</code> 函式，我們可以像範例 12-9 的 <code>Config::build</code> 一樣來改善錯誤處理。不同於讓程式呼叫 <code>expect</code> 來恐慌，當有問題發生時，<code>run</code> 函式會回傳 <code>Result&lt;T, E&gt;</code>。這能讓我們進一步穩固 <code>main</code> 中對使用者友善的處理錯誤邏輯。範例 12-12 展示我們對 <code>run</code> 的簽名與本體所需要做的改變。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --省略--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;解析引數時出現問題：{err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    println!(&quot;文字內容：\n{contents}&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-12：變更 <code>run</code> 函式來回傳 <code>Result</code></span></p>
<p>我們在此做了三項明顯的修改。首先，我們改變了 <code>run</code> 函式的回傳型別為 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>，此函式之前回傳的是單元型別 <code>()</code>，而它現在仍作為 <code>Ok</code> 條件內的數值。</p>
<p>對於錯誤型別，我們使用<strong>特徵物件（trait object）</strong> <code>Box&lt;dyn Error&gt;</code>（然後我們在最上方透過 <code>use</code> 陳述式來將 <code>std::error::Error</code> 引入作用域）。我們會在<a href="ch17-00-oop.html">第十七章</a><!-- ignore -->討論特徵物件。現在你只需要知道 <code>Box&lt;dyn Error&gt;</code> 代表函式會回傳有實作 <code>Error</code> 特徵的型別，但我們不必指定回傳值的明確型別。這增加了回傳錯誤數值的彈性，其在不同錯誤情形中可能有不同的型別。<code>dyn</code> 關鍵字是「動態（dynamic）」的縮寫。</p>
<p>再來，我們移除了 <code>expect</code> 的呼叫並改為<a href="ch09-02-recoverable-errors-with-result.html#%E5%82%B3%E6%92%AD%E9%8C%AF%E8%AA%A4%E7%9A%84%E6%8D%B7%E5%BE%91-%E9%81%8B%E7%AE%97%E5%AD%90">第九章</a><!-- ignore -->所介紹的 <code>?</code> 運算子。所以與其對錯誤 <code>panic!</code>，<code>?</code> 會回傳當前函式的錯誤數值，並交由呼叫者處理。</p>
<p>第三，<code>run</code> 函式現在成功時會回傳 <code>Ok</code> 數值。我們在 <code>run</code> 函式簽名中的成功型別為 <code>()</code>，這意味著我們需要將單元型別封裝進 <code>Ok</code> 數值。<code>Ok(())</code> 這樣的語法一開始看可能會覺得有點奇怪，但這樣子使用 <code>()</code> 的確符合慣例，說明我們呼叫 <code>run</code> 只是為了它的副作用，它不會回傳我們需要的數值。</p>
<p>當你執行此程式時，它雖然能編譯但會顯示一個警告：</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `minigrep` (bin &quot;minigrep&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
搜尋 the
目標檔案為 poem.txt
文字內容：
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust 告訴我們程式碼忽略了 <code>Result</code> 數值且 <code>Result</code> 數值可能代表會有錯誤發生。但我們沒有檢查是不是會發生錯誤，所以編譯器提醒我們可能要在此寫些錯誤處理的程式碼！我們現在就來修正此問題。</p>
<h4 id="在-main-中處理-run-回傳的錯誤"><a class="header" href="#在-main-中處理-run-回傳的錯誤">在 <code>main</code> 中處理 <code>run</code> 回傳的錯誤</a></h4>
<p>我們會用類似範例 12-10 中處理 <code>Config::build</code> 的技巧來處理錯誤，不過會有一些差別：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --省略--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;解析引數時出現問題：{err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;搜尋 {}&quot;, config.query);
    println!(&quot;目標檔案為 {}&quot;, config.file_path);

    if let Err(e) = run(config) {
        println!(&quot;應用程式錯誤：{e}&quot;);
        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>我們使用 <code>if let</code> 而非 <code>unwrap_or_else</code> 來檢查 <code>run</code> 是否有回傳 <code>Err</code> 數值，並以此呼叫 <code>process::exit(1)</code>。<code>run</code> 函式沒有回傳數值，所以我們不必像處理 <code>Config::build</code> 得用 <code>unwrap</code> 取得 <code>Config</code> 實例。因為 <code>run</code> 在成功時會回傳 <code>()</code>，而我們只在乎偵測錯誤，所以我們不需要 <code>unwrap_or_else</code> 來回傳解封裝後的數值，因為它只會是 <code>()</code>。</p>
<p><code>if let</code> 的本體與 <code>unwrap_or_else</code> 函式則都做一樣的事情：印出錯誤並離開。</p>
<h3 id="將程式碼拆到函式庫-crate"><a class="header" href="#將程式碼拆到函式庫-crate">將程式碼拆到函式庫 Crate</a></h3>
<p>我們的 <code>minigrep</code> 專案目前看起來不錯！接下來我們要將 <em>src/main.rs</em> 檔案分開來，將一些程式碼放入 <em>src/lib.rs</em> 檔案中。這樣讓我們可以測試程式碼，並讓 <em>src/main.rs</em> 檔案的負擔變得少一點。</p>
<p>讓我們將 <code>main</code> 以外的所有程式碼從 <em>src/main.rs</em> 移到 <em>src/lib.rs</em>：</p>
<ul>
<li><code>run</code> 函式定義</li>
<li>相關的 <code>use</code> 陳述式</li>
<li><code>Config</code> 的定義</li>
<li><code>Config::build</code> 的函式定義</li>
</ul>
<p><em>src/lib.rs</em> 的內容應該要如範例 12-13 所示（為了簡潔，我們省略了函式本體）。注意到這還無法編譯，直到我們也修改 <em>src/main.rs</em> 成範例 12-14 為止。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub file_path: String,
}

impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --省略--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --省略--
<span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;文字內容：\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">範例 12-13：將 <code>Config</code> 與 <code>run</code> 移至 <em>src/lib.rs</em></span></p>
<p>我們對許多項目都使用了 <code>pub</code> 關鍵字，這包含 <code>Config</code> 與其欄位，以及其 <code>build</code> 方法，還有 <code>run</code> 函式。我們現在有個函式庫會提供公開 API 能讓我們來測試！</p>
<p>現在我們需要將移至 <em>src/lib.rs</em> 的程式碼引入執行檔 crate 的 <em>src/main.rs</em> 作用域中，如範例 12-14 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --省略--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::build(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;解析引數時出現問題：{err}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;搜尋 {}&quot;, config.query);
</span><span class="boring">    println!(&quot;目標檔案為 {}&quot;, config.file_path);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --省略--
<span class="boring">        println!(&quot;應用程式錯誤：{e}&quot;);
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">範例 12-14：在 <em>src/main.rs</em> 使用 <code>minigrep</code> 函式庫 crate</span></p>
<p>我們加上 <code>use minigrep::Config</code> 這行來將 <code>Config</code> 型別從函式庫 crate 引入執行檔 crate 的作用域中，然後我們使用 <code>run</code> 函式的方式是在其前面再加上 crate 的名稱。現在所有的功能都應該正常並能執行了。透過 <code>cargo run</code> 來執行程式並確保一切正常。</p>
<p>哇！辛苦了，不過我們為未來的成功打下了基礎。現在處理錯誤就輕鬆多了，而且我們讓程式更模組化。現在幾乎所有的工作都會在 <em>src/lib.rs</em> 中進行。</p>
<p>讓我們利用這個新的模組化優勢來進行些原本在就程式碼會很難處理的工作，但在新的程式碼會變得非常容易，那就是寫些測試！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過測試驅動開發完善函式庫功能"><a class="header" href="#透過測試驅動開發完善函式庫功能">透過測試驅動開發完善函式庫功能</a></h2>
<p>現在我們提取邏輯到 <em>src/lib.rs</em> 並在 <em>src/main.rs</em> 留下引數收集與錯誤處理的任務，現在對程式碼中的核心功能進行測試會簡單許多。我們可以使用各種引數直接呼叫函式來檢查回傳值，而不用從命令列呼叫我們的執行檔。</p>
<p>在此段落中，我們會在 <code>minigrep</code> 程式中利用測試驅動開發（Test-driven development，TDD）來新增搜尋邏輯。此程式開發技巧遵循以下步驟：</p>
<ol>
<li>寫出一個會失敗的測試並執行它來確保它失敗的原因如你所預期。</li>
<li>寫出或修改足夠的程式碼來讓新測試可以通過。</li>
<li>重構你新增或變更的程式碼並確保測試仍能持續通過。</li>
<li>重複第一步！</li>
</ol>
<p>雖然這只是編寫軟體的許多方式之一，但 TDD 也有助於程式碼的設計。在寫出能通過測試的程式碼之前先寫好測試能夠協助在開發過程中維持高測試覆蓋率。</p>
<p>我們將用測試驅動功能的實作，而要實作的功能就是在檔案內容中找到欲搜尋的字串，並產生符合查詢字串的行數列表。我們會在一個叫做 <code>search</code> 的函式新增此功能。</p>
<h3 id="編寫失敗的測試"><a class="header" href="#編寫失敗的測試">編寫失敗的測試</a></h3>
<p>讓我們移除 <em>src/lib.rs</em> 與 <em>src/main.rs</em> 中用來檢查程式行為的 <code>println!</code> 陳述式，因為我們不再需要它們了。然後在 <em>src/lib.rs</em> 中，我們加上 <code>tests</code> 模組與一個測試函式，如我們在<a href="ch11-01-writing-tests.html#%E6%B8%AC%E8%A9%A6%E5%87%BD%E5%BC%8F%E5%89%96%E6%9E%90">第十一章</a><!-- ignore -->所做的一樣。測試函式會指定我們希望 <code>search</code> 函式所能擁有的行為，它會接收搜尋字串與一段要被搜尋的文字，然後它只回傳文字中包含該搜尋字串的行數。範例 12-15 展示了此測試，但還不能編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}
</code></pre>
<p><span class="caption">範例 12-15：建立一個我們預期 <code>search</code> 函式該有的行為的失敗測試</span></p>
<p>此測試搜尋字串 <code>&quot;duct&quot;</code>。而要被搜尋的文字有三行，只有一行包含 <code>&quot;duct&quot;</code>（在雙引號開頭後方的斜線會告訴 Rust 別在此字串內容開始處換行）。我們判定 <code>search</code> 函式回傳的數值只會包含我們預期的那一行。</p>
<p>我們還無法執行此程式並觀察其失敗，因為測試還無法編譯，<code>search</code> 函式根本還不存在！按照 TDD 的準則，我們只要加上足夠的程式碼讓測試可以編譯並執行，而我們要加上的是 <code>search</code> 函式的定義並永遠回傳一個空的向量，如範例 12-16 所示。然後測試應該就能編譯並失敗，因為空向量並不符合包含 <code>&quot;safe, fast, productive.&quot;</code> 此行的向量。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-16：定義足夠的 <code>search</code> 函式讓我們的測試能夠編譯</span></p>
<p>值得注意的是在 <code>search</code> 的簽名中需要定義一個顯式的生命週期 <code>'a</code>，並用於 <code>contents</code> 引數與回傳值。回想一下在<a href="ch10-03-lifetime-syntax.html">第十章</a><!-- ignore -->中生命週期參數會連結引數生命週期與回傳值生命週期。在此例中，我們指明回傳值應包含字串切片且其會參考 <code>contents</code> 引數的切片（而非引數 <code>query</code>）。</p>
<p>換句話說，我們告訴 Rust <code>search</code> 函式回傳的資料會跟傳遞給 <code>search</code> 函式的引數 <code>contents</code> 資料存活的一樣久。這點很重要！被切片參考的資料必須有效，這樣其參考才會有效。如果編譯器假設是在建立 <code>query</code> 而非 <code>contents</code> 的字串切片，它的安全檢查就會不正確。</p>
<p>如果我們忘記詮釋生命週期並嘗試編譯此函式，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                      ----            ----         ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`
help: consider introducing a named lifetime parameter
   |
28 | pub fn search&lt;'a&gt;(query: &amp;'a str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
   |              ++++         ++                 ++              ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep` due to previous error
</code></pre>
<p>Rust 無法知道這兩個引數哪個才是我們需要的，所以我們得告訴它。由於引數 <code>contents</code> 包含所有文字且我們想要回傳符合條件的部分文字，所以我們知道 <code>contents</code> 引數要用生命週期語法與回傳值做連結。</p>
<p>其他程式設計語言不會要求你要在簽名中連結引數與回傳值，但這寫久就會習慣了。你可能會想要將此例與第十章的<a href="ch10-03-lifetime-syntax.html#%E9%80%8F%E9%81%8E%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E9%A9%97%E8%AD%89%E5%8F%83%E8%80%83">「透過生命週期驗證參考」</a><!-- ignore -->段落做比較。</p>
<p>現在讓我們執行測試：</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>很好！測試如我們所預期地失敗。接下來我們要讓測試通過！</p>
<h3 id="寫出讓測試成功的程式碼"><a class="header" href="#寫出讓測試成功的程式碼">寫出讓測試成功的程式碼</a></h3>
<p>目前我們的測試會失敗，因為我們永遠只回傳一個空向量。要修正並實作 <code>search</code>，我們的程式需要完成以下步驟：</p>
<ul>
<li>遍歷內容的每一行。</li>
<li>檢查該行是否包含我們要搜尋的字串。</li>
<li>如果有的話，將它加入我們要回傳的數值列表。</li>
<li>如果沒有的話，不做任何事。</li>
<li>回傳符合的結果列表。</li>
</ul>
<p>讓我們來完成每個步驟，先從遍歷每一行開始。</p>
<h4 id="透過-lines-方法來遍歷每一行"><a class="header" href="#透過-lines-方法來遍歷每一行">透過 <code>lines</code> 方法來遍歷每一行</a></h4>
<p>Rust 有個實用的方法能逐步處理字串的每一行，這方法就叫 <code>lines</code>，而使用方式就如範例 12-17 所示。注意此例還無法編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // 對每行做些事情
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-17：在 <code>contents</code> 中遍歷每一行
</span></p>
<p><code>lines</code> 方法會回傳疊代器（iterator）。我們會在<a href="ch13-02-iterators.html">第十三章</a><!-- ignore -->詳細解釋疊代器，不過回想一下你在<a href="ch03-05-control-flow.html#%E4%BD%BF%E7%94%A8-for-%E9%81%8D%E6%AD%B7%E9%9B%86%E5%90%88">範例 3-5</a><!-- ignore -->就看過疊代器的用法了，我們對疊代器使用 <code>for</code> 迴圈來對集合中的每個項目執行一些程式碼。</p>
<h4 id="檢查每行是否有要搜尋的字串"><a class="header" href="#檢查每行是否有要搜尋的字串">檢查每行是否有要搜尋的字串</a></h4>
<p>接著，我們要檢查目前的行數是否有包含我們要搜尋的字串。幸運的是，字串有個好用的方法叫做 <code>contains</code> 能幫我處理這件事！在 <code>search</code> 函式中加上方法 <code>contains</code> 的呼叫，如範例 12-18 所示。注意這仍然無法編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // 對每行做些事情
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-18：增加檢查行數是否包含 <code>query</code> 字串的功能</span></p>
<p>目前我們正在將功能實作出來。但要能夠編譯的話，我們需要從本體回傳函式簽名中指定的數值。</p>
<h4 id="儲存符合條件的行數"><a class="header" href="#儲存符合條件的行數">儲存符合條件的行數</a></h4>
<p>要完成此函式的話，我們需要有個方式能儲存包含搜尋字串的行數。為此我們可以在 <code>for</code> 迴圈前建立一個可變向量然後對向量呼叫 <code>push</code> 方法來儲存 <code>line</code>。在 <code>for</code> 迴圈之後，我們回傳向量，如範例 12-19 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-19：儲存符合的行數讓我們可以回傳它們</span></p>
<p>現在 <code>search</code> 函式應該只會回傳包含 <code>query</code> 的行數，而我們的測試也該通過。讓我們執行測試：</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>我們的測試通過了，所以我們確定它運作無誤！</p>
<p>在此刻之後，我們可以考慮重構搜尋函式的實作，並確保測試能通過以維持功能不變。搜尋函式的程式碼並沒有很糟，但它沒有用到疊代器中的一些實用功能優勢。我們會在<a href="ch13-02-iterators.html">第十三章</a><!-- ignore -->詳細探討疊代器之後，再回過頭來看這個例子，來看看如何改善。</p>
<h4 id="在-run-函式中使用-search-函式"><a class="header" href="#在-run-函式中使用-search-函式">在 <code>run</code> 函式中使用 <code>search</code> 函式</a></h4>
<p>現在 <code>search</code> 函式能夠執行且也有測試過了，我們需要從 <code>run</code> 函式呼叫 <code>search</code>。我們需要將 <code>config.query</code> 數值與 <code>run</code> 從檔案讀取到的 <code>contents</code> 傳給 <code>search</code> 函式。然後 <code>run</code> 會印出 <code>search</code> 回傳的每一行：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>我們仍會使用 <code>for</code> 迴圈來取得 <code>search</code> 回傳的每一行並顯示出來。</p>
<p>現在整支程式應該都能執行了！讓我們來試試看。首先用一個只會在 Emily Dickinson 的詩中回傳剛好一行的單字「frog」：</p>
<pre><code class="language-console">$ cargo run -- frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>酷喔！現在讓我們試試看能符合多行的單字，像是「body」：</p>
<pre><code class="language-console">$ cargo run -- body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I'm nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>最後，讓我們確保使用詩中沒出現的單字來搜尋時，我們不會得到任何一行，像是「monomorphization」：</p>
<pre><code class="language-console">$ cargo run -- monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>漂亮！我們建立了一個屬於自己的迷你經典工具，並學到了很多如何架構應用程式的知識。我們也學了一些檔案輸入與輸出、生命週期、測試與命令列解析。</p>
<p>為了讓此專案更完整，我們會簡單介紹如何使用環境變數，以及如何印出到標準錯誤（standard error），這兩項在寫命令列程式時都很實用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="處理環境變數"><a class="header" href="#處理環境變數">處理環境變數</a></h2>
<p>我們會新增一個額外的功能來改善 <code>minigrep</code>：使用者可以透過環境變數來啟用不區分大小寫的搜尋功能。我們可以將此功能設為命令列選項並要求使用者每次需要時就要加上它，但是這次我們選擇使用環境變數。這樣一來能讓使用者設置環境變數一次就好，然後在該終端機 session 中所有的搜尋都會是不區分大小寫的。</p>
<h3 id="寫個不區分大小寫的-search-函式的失敗測試"><a class="header" href="#寫個不區分大小寫的-search-函式的失敗測試">寫個不區分大小寫的 <code>search</code> 函式的失敗測試</a></h3>
<p>我們首先新增個 <code>search_case_insensitive</code> 函式在環境變數有數值時呼叫它。我們將繼續遵守 TDD 流程，所以第一步一樣是先寫個會失敗的測試。我們會為新函式 <code>search_case_insensitive</code> 新增一個測試，並將舊測試從 <code>one_result</code> 改名為 <code>case_sensitive</code> 以便清楚兩個測試的差別，如範例 12-20 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
</code></pre>
<p><span class="caption">範例 12-20：為準備加入的不區分大小寫函式新增個失敗測試</span></p>
<p>注意到我們也修改了舊測試 <code>contents</code>。我們新增了一行使用大寫 D 的 <code>&quot;Duct tape.&quot;</code>，當我們以區分大小寫來搜尋時，就不會符合要搜尋的 <code>&quot;duct&quot;</code>。這樣變更舊測試能確保我們沒有意外破壞我們已經實作好的區分大小寫的功能。此測試應該要能通過，並在我們實作不區分大小寫的搜尋時仍能繼續通過。</p>
<p>新的不區分大小寫的搜尋測試使用 <code>&quot;rUsT&quot;</code> 來搜尋。在我們準備要加入的 <code>search_case_insensitive</code> 函式中，要搜尋的 <code>&quot;rUsT&quot;</code> 應該要能符合有大寫 R 的 <code>&quot;Rust:&quot;</code> 以及 <code>&quot;Trust me.&quot;</code> 這幾行，就算兩者都與搜尋字串有不同的大小寫。這是我們的失敗測試而且它還無法編譯，因為我們還沒有定義 <code>search_case_insensitive</code> 函式。歡迎自行加上一個永遠回傳空向量的骨架實作，就像我們在範例 12-16 所做的一樣，然後看看測試能不能編譯過並失敗。</p>
<h3 id="實作-search_case_insensitive-函式"><a class="header" href="#實作-search_case_insensitive-函式">實作 <code>search_case_insensitive</code> 函式</a></h3>
<p>範例 12-21 顯示的 <code>search_case_insensitive</code> 函式會與 <code>search</code> 函式幾乎一樣。唯一的不同在於我們將 <code>query</code> 與每個 <code>line</code> 都變成小寫，所以無論輸入引數是大寫還是小寫，當我們在檢查行數是否包含搜尋的字串時，它們都會是小寫。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-21：定義 <code>search_case_insensitive</code> 並在比較前將搜尋字串與行數均改為小寫</span></p>
<p>首先我們將 <code>query</code> 字串變成小寫並儲存到同名的遮蔽變數中。我們必須呼叫對要搜尋的字串 <code>to_lowercase</code>，這樣無論使用者輸入的是 <code>&quot;rust&quot;</code>、<code>&quot;RUST&quot;</code>、<code>&quot;Rust&quot;</code> 或 <code>&quot;rUsT&quot;</code>，我們都會將字串視為 <code>&quot;rust&quot;</code> 並以此來不區分大小寫。雖然 <code>to_lowercase</code> 能處理基本的 Unicode，但它不會是 100% 準確的。如果我們是在寫真正的應用程式的話，我們需要處理更多條件，但在此段落是為了理解環境變數而非 Unicode，所以我們維持這樣寫就好。</p>
<p>注意到 <code>query</code> 現在是個 <code>String</code> 而非字串切片，因為呼叫 <code>to_lowercase</code> 會建立新的資料而非參考現存的資料。假設要搜尋的字串是 <code>&quot;rUsT&quot;</code> 的話，該字串切片並沒有包含小寫的 <code>u</code> 或 <code>t</code> 能讓我們來使用，所以我們必須分配一個包含 <code>&quot;rust&quot;</code> 的新 <code>String</code>。現在當我們將 <code>query</code> 作為引數傳給 <code>contains</code> 方法時，我們需要加上「&amp;」，因為 <code>contains</code> 所定義的簽名接收的是一個字串切片。</p>
<p>接著，我們對每個 <code>line</code> 加上 <code>to_lowercase</code> 的呼叫。現在我們將 <code>line</code> 和 <code>query</code> 都轉換成小寫了。我們可以不區分大小寫來找到符合的行數。</p>
<p>讓我們來看看實作是否能通過測試：</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>很好！測試通過。現在讓我們從 <code>run</code> 函式呼叫新的 <code>search_case_insensitive</code> 函式。首先，我們要在 <code>Config</code> 中新增一個配置選項來切換區分大小寫與不區分大小寫之間的搜尋。新增此欄位會造成編譯錯誤，因為我們還沒有初始化該欄位：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub file_path: String,
    pub ignore_case: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>注意到我們新增了 <code>ignore_case</code> 欄位並存有布林值。接著，我們需要 <code>run</code> 函式檢查 <code>ignore_case</code> 欄位的數值並以此決定要呼叫 <code>search</code> 函式或是 <code>search_case_insensitive</code> 函式，如範例 12-22 所示。不過目前還無法編譯。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.file_path)?;

    let results = if config.ignore_case {
        search_case_insensitive(&amp;config.query, &amp;contents)
    } else {
        search(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{line}&quot;);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-22：依據 <code>config.ignore_case</code> 的數值來呼叫 <code>search</code> 或 <code>search_case_insensitive</code></span></p>
<p>最後，我們需要檢查環境變數。處理環境變數的函式位於標準函式庫中的 <code>env</code> 模組中，所以我們在 <em>src/lib.rs</em> 最上方加上 <code>use std::env;</code> 來將該模組引入作用域。然後我們使用 <code>env</code> 模組中的 <code>var</code> 函式來檢查一個叫做 <code>IGNORE_CASE</code> 的環境變數有沒有設任何數值，如範例 12-23 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::env;
// --省略--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;引數不足&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-23：檢查環境變數 <code>IGNORE_CASE</code></span></p>
<p>我們在此建立了一個新的變數 <code>ignore_case</code>。要設置其數值，我們可以呼叫 <code>env::var</code> 函式並傳入環境變數 <code>IGNORE_CASE</code> 的名稱。<code>env::var</code> 函式會回傳 <code>Result</code>，如果有設置環境變數的話，這就會是包含環境變數數值的成功 <code>Ok</code>變體；如果環境變數沒有設置的話，這就會回傳 <code>Err</code> 變體。</p>
<p>我們在 <code>Result</code> 使用 <code>is_ok</code> 方法來檢查環境變數是否有設置，也就是程式是否該使用區分大小寫的搜尋。如果 <code>IGNORE_CASE</code> 環境變數沒有設置任何數值的話，<code>is_ok</code> 會回傳否，所以程式就會進行區分大小寫的搜尋。我們不在乎環境變數的<strong>數值</strong>，只在意它有沒有被設置而已，所以我們使用 <code>is_ok</code> 來檢查而非使用 <code>unwrap</code>、<code>expect</code> 或其他任何我們看過的 <code>Result</code> 方法。</p>
<p>我們將變數 <code>ignore_case</code> 的數值傳給 <code>Config</code> 實例，讓 <code>run</code> 函式可以讀取該數值並決定該呼叫 <code>search_case_insensitive</code> 還是 <code>search</code>，如範例 12-22 所實作的一樣。</p>
<p>讓我們試看看吧！首先，我們先不設置環境變數並執行程式來搜尋 <code>to</code>，任何包含小寫單字「to」的行數都應要符合：</p>
<pre><code class="language-console">$ cargo run -- to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>看起來運作仍十分正常！現在，讓我們設置 <code>IGNORE_CASE</code> 為 <code>1</code> 並執行程式來搜尋相同的字串 <code>to</code>。</p>
<pre><code class="language-console">$ IGNORE_CASE=1 cargo run -- to poem.txt
</code></pre>
<p>如果你使用的是 PowerShell，你需要將設置變數與執行程式分為不同的命令：</p>
<pre><code class="language-console">PS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt
</code></pre>
<p>這會在你的 shell session 中設置 <code>IGNORE_CASE</code>。它可以透過 <code>Remove-Item</code> cmdlet 來取消設置：</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:IGNORE_CASE
</code></pre>
<p>我們應該會得到包含可能有大寫的「to」的行數：</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>太好了，我們也取得了包含「To」的行數！我們的 <code>minigrep</code> 程式現在可以進行不區分大小寫的搜尋並以環境變數配置。現在你知道如何使用命令列引數或環境變數來管理設置選項了。</p>
<p>有些程式允許同時使用引數<strong>與</strong>環境變數來配置。在這種情況下，程式會決定各種選項的優先層級。你想要練習的話，嘗試使用命令列引數與環境變數來控制區分大小寫的選項。並在程式執行時，其中一個設置為區分大小寫，而另一個為不區分大小寫時，自行決定該優先使用命令列引數還是環境變數。</p>
<p><code>std::env</code> 模組還包含很多處理環境變數的實用功能，歡迎查閱其官方文件來瞭解有哪些可用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="將錯誤訊息寫入標準錯誤而非標準輸出"><a class="header" href="#將錯誤訊息寫入標準錯誤而非標準輸出">將錯誤訊息寫入標準錯誤而非標準輸出</a></h2>
<p>目前我們使用 <code>println!</code> 巨集來將所有的輸出顯示到終端機。大多數的終端機都提供兩種輸出方式：用於通用資訊的<strong>標準輸出（standard output, <code>stdout</code>）<strong>以及用於錯誤訊息的</strong>標準錯誤（standard error, <code>stderr</code>）</strong>。這樣的區別讓使用者可以選擇將程式的成功輸出導向到一個檔案中，並仍能在螢幕上顯示錯誤訊息。</p>
<p><code>println!</code> 巨集只能夠印出標準輸出，所以我們得用其他方式來印出標準錯誤。</p>
<h3 id="檢查該在哪裡寫錯誤"><a class="header" href="#檢查該在哪裡寫錯誤">檢查該在哪裡寫錯誤</a></h3>
<p>首先，我們先來觀察 <code>minigrep</code> 目前寫到標準輸出的顯示內容，其中包含任何我們想改寫成標準錯誤的錯誤訊息。我們會將標準輸出重新導向至一個檔案並故意產生一個錯誤。因為我們不會重新導向標準錯誤，所以任何傳送至標準錯誤的內容會繼續顯示在螢幕上。</p>
<p>命令列程式應該要傳送錯誤訊息至標準錯誤，讓我們可以在重新導向標準輸出至檔案時，仍能在螢幕上看到錯誤訊息。所以我們的程式目前並不符合預期：我們會看到它儲存錯誤訊息輸出到檔案中！</p>
<p>要觀察此行為的方式的話，我們要透過 <code>&gt;</code> 來執行程式並加上檔案名稱 <em>output.txt</em>，這是我們要重新導向標準輸出到的地方。我們不會傳遞任何引數，這樣就應該會造成錯誤：</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p><code>&gt;</code> 語法告訴 shell 要將標準輸出的內容寫入 <em>output.txt</em> 而不是顯示在螢幕上。我們沒有看到應顯示在螢幕上的錯誤訊息，這代表它一定跑到檔案中了。以下是 <em>output.txt</em> 包含的內容：</p>
<pre><code class="language-text">解析引數時出現問題：引數不足
</code></pre>
<p>是的，我們的錯誤訊息印到了標準輸出。像這樣的錯誤訊息印到標準錯誤會比較好，這樣才能只讓成功執行的資料存至檔案中。讓我們來修正吧。</p>
<h3 id="將錯誤印出至標準錯誤"><a class="header" href="#將錯誤印出至標準錯誤">將錯誤印出至標準錯誤</a></h3>
<p>我們會使用範例 12-24 的程式碼來改變錯誤訊息印出的方式。由於我們在本章前幾篇的重構，所有印出錯誤訊息的程式碼都位於 <code>main</code> 函式中。標準函式庫有提供 <code>eprintln!</code> 巨集來印到標準錯誤，所以讓我們變更兩個原本呼叫 <code>println!</code> 來印出錯誤的段落來改使用 <code>eprintln!</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;解析引數時出現問題：{err}&quot;);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;應用程式錯誤：{e}&quot;);
        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">範例 12-24：使用 <code>eprintln!</code> 來將錯誤訊息印至標準錯誤而非標準輸出</span></p>
<p>讓我們以相同方式再執行程式一次，沒有任何引數並用 <code>&gt;</code> 重新導向標準輸出：</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
解析引數時出現問題：引數不足
</code></pre>
<p>現在我們看到錯誤顯示在螢幕上而且 <em>output.txt</em> 裡什麼也沒只有，這正是命令列程式所預期的行為。</p>
<p>讓我們加上不會產生錯誤的引數來執行程式，並仍重新導向標準輸出至檔案中，如以下所示：</p>
<pre><code class="language-console">$ cargo run -- to poem.txt &gt; output.txt
</code></pre>
<p>我們在終端機不會看到任何輸出，而 <em>output.txt</em> 會包含我們的結果：</p>
<p><span class="filename">檔案名稱：output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>這說明我們現在有對成功的輸出使用標準輸出，而且有妥善地將錯誤輸出傳至標準錯誤。</p>
<h2 id="總結-11"><a class="header" href="#總結-11">總結</a></h2>
<p>本章節回顧了你目前所學的一些重要概念，並介紹了如何在 Rust 中進行常見的 I/O 操作。透過使用命令列引數、檔案、環境變數與用來印出錯誤的 <code>eprintln!</code> 巨集，你現在已經準備好能寫出命令列應用程式了。結合前幾章的概念，你的程式的組織架構會非常穩固、資料都能有效率地儲存至適當的資料結構、完善地處理錯誤，並通過測試檢驗。</p>
<p>接下來，我們要探討些 Rust 受到函式語言啟發的功能：閉包與疊代器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函式語言功能疊代器與閉包"><a class="header" href="#函式語言功能疊代器與閉包">函式語言功能：疊代器與閉包</a></h1>
<p>Rust 的設計靈感啟發自許多現有的語言與技術，其中一個影響十分顯著的就是<em>函式程式設計（functional programming）</em>。以函式風格的程式設計通常包含將函式視為數值並作為引數傳遞、將它們從其他函式回傳、將它們賦值給變數以便之後使用，以及更多。</p>
<p>在本章節中，我們不會討論哪些才是屬於函式程式設計或哪些不是，而是介紹一些 Rust 中類似於許多語言常視為函式語言特色的功能。</p>
<p>更明確來說，我們會涵蓋：</p>
<ul>
<li><em>閉包（Closures）</em>：類似函式的結構並可以賦值給變數</li>
<li><em>疊代器（Iterators）</em>：遍歷一系列元素的方法</li>
<li>如何用閉包與疊代器來改善第十二章的 I/O 專案</li>
<li>閉包與疊代器的效能（先偷偷跟你說：它們比你想像的還要快！）</li>
</ul>
<p>我們已經在其他章節提到的功能像是模式配對與枚舉也都有被函式風格所影響。因為掌握閉包與疊代器是寫出符合語言風格與高效 Rust 程式碼中重要的一環，所以我們將用一章來介紹它們。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="閉包獲取其環境的匿名函式"><a class="header" href="#閉包獲取其環境的匿名函式">閉包：獲取其環境的匿名函式</a></h2>
<p>Rust 的閉包（closures）是個你能賦值給變數或作為其他函式引數的匿名函式。你可以在某處建立閉包，然後在不同的地方呼叫閉包並執行它。而且不像函式，閉包可以從它們所定義的作用域中獲取數值。我們將會解釋這些閉包功能如何允許程式碼重用以及自訂行為。</p>
<h3 id="透過閉包獲取環境"><a class="header" href="#透過閉包獲取環境">透過閉包獲取環境</a></h3>
<p>我們首先會來研究我們如何用閉包來獲取定義在環境的數值並在之後使用。讓我們考慮以下假設情境：每隔一段時間，我們的襯衫公司會送出獨家限量版襯衫給郵寄清單的某位顧客來作為宣傳手段。郵寄清單的顧客可以在他們的設定中加入他們最愛的顏色。如果被選中的人有設定最愛顏色的話，他們就會獲得該顏色的襯衫。如果他們沒有指定任何最愛顏色的話，公司就會選擇目前顏色最多的選項。</p>
<p>要實作的方式有很多種。舉例來說，我們可以使用一個枚舉叫做 <code>ShirtColor</code> 然後其變體有 <code>Red</code> 和 <code>Blue</code>（為了簡潔我們限制顏色的種類）。我們用 <code>Inventory</code> 來代表公司的庫存，然後用 <code>shirts</code> 欄位來包含 <code>Vec&lt;ShirtColor&gt;</code> 來代表目前庫存有的襯衫顏色。定義在 <code>Inventory</code> 的 <code>giveaway</code> 方法會取得免費襯衫得主的選擇性襯衫顏色偏好，然後回傳他們會拿到的襯衫顏色。如範例 13-1 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;偏好 {:?} 的使用者獲得 {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;偏好 {:?} 的使用者獲得 {:?}&quot;,
        user_pref2, giveaway2
    );
}
</code></pre>
<p><span class="caption">範例 13-1：襯衫公司送禮的情境</span></p>
<p>定義在 <code>main</code> 中的 <code>store</code> 在這次的限量版宣傳中的庫存有兩件藍色襯衫與一件紅色襯衫。我們呼叫了 <code>giveaway</code> 方法兩次，一次是給偏好紅色襯衫的使用者，另一次則是給無任何偏好的使用者。</p>
<p>再次強調這可以用各種方式實作，只是在此我們想專注在閉包，所以除了用到我們已經學過的概念以外，<code>giveaway</code> 方法中還使用了閉包。在 <code>giveaway</code> 方法中，我們從參數型別 <code>Option&lt;ShirtColor&gt;</code> 取得使用者偏好，然後對 <code>user_preference</code> 呼叫 <code>unwrap_or_else</code> 方法。<a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code> 的 <code>unwrap_or_else</code> 方法</a><!-- ignore -->定義在標準函式庫中。它接收一個引數：一個沒有任何引數的閉包然後會回傳數值 <code>T</code>（該型別為 <code>Option&lt;T&gt;</code> 的 <code>Some</code> 儲存的型別，在此例中就是 <code>ShirtColor</code>）。如果 <code>Option&lt;T&gt;</code> 是 <code>Some</code> 變體，<code>unwrap_or_else</code> 就會回傳 <code>Some</code> 裡的數值。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code> 變體，<code>unwrap_or_else</code> 會呼叫閉包並回傳閉包回傳的數值。</p>
<p>我們寫上閉包表達式 <code>|| self.most_stocked()</code> 作為 <code>unwrap_or_else</code> 的引數。這是個沒有任何參數的閉包（如果閉包有參數的話，它們會出現在兩條直線中間）。閉包本體會呼叫 <code>self.most_stocked()</code>。我們直接在此定義閉包，然後 <code>unwrap_or_else</code> 的實作就會在需要結果時執行閉包。</p>
<p>執行此程式的話就會印出：</p>
<pre><code class="language-console">$ cargo r
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company) 
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/shirt-company`
偏好 Some(Red) 的使用者獲得 Red
偏好 None 的使用者獲得 Blue
</code></pre>
<p>這裡值得注意的是我們對當前 <code>Inventory</code> 實例傳入的是一個呼叫 <code>self.most_stocked()</code> 的閉包。標準函式庫不需要知道我們定義的任何型別像  <code>Inventory</code> 與 <code>ShirtColor</code>，或是在此情境中我們需要使用的任何邏輯，閉包就會獲取 <code>Inventory</code> 實例的不可變參考 <code>self</code>，然後傳給我們在 <code>unwrap_or_else</code> 方法中指定的程式碼。反之，函式就無法像這樣獲取它們周圍的環境。</p>
<h3 id="閉包型別推導與詮釋"><a class="header" href="#閉包型別推導與詮釋">閉包型別推導與詮釋</a></h3>
<p>函式與閉包還有更多不同的地方。閉包通常不必像 <code>fn</code> 函式那樣要求你要詮釋參數或回傳值的型別。函式需要型別詮釋是因為它們是顯式公開給使用者的介面。嚴格定義此介面是很重要的，這能確保每個人同意函式使用或回傳的數值型別為何。但是閉包並不是為了對外公開使用，它們儲存在變數且沒有名稱能公開給我們函式庫的使用者。</p>
<p>閉包通常很短，而且只與小範圍內的程式碼有關，而非適用於任何場合。有了這樣限制的環境，編譯器能可靠地推導出參數與回傳值的型別，如同其如何推導出大部分的變數型別一樣。（但在有些例外情形下編譯器還是需要閉包的型別詮釋）</p>
<p>至於變數的話，雖然不是必要的，但如果我們希望能夠增加閱讀性與清楚程度，我們還是可以加上型別詮釋。要在閉包詮釋型別的話，就會如範例 13-2 的定義所示。在此範例中，我們定義一個閉包並儲存至一個變數中，而非像範例 13-1 我們將閉包作為引數傳入。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;緩慢計算中...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;今天請做 {} 下伏地挺身！&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;然後請做 {} 下仰臥起坐！&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;今天休息！別忘了多喝水！&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;今天請慢跑 {} 分鐘！&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-2：對閉包加上選擇性的參數與回傳值型別詮釋</span></p>
<p>加上型別詮釋後，閉包的語法看起來就更像函式的語法了。我們在此定義了一個對參數加 1 的函式，以及一個有相同行為的閉包做為比較。我們加了一些空格來對齊相對應的部分。這顯示了閉包語法和函式語法有多類似，只是改用直線以及有些語法是選擇性的。</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行顯示的是函式定義，而第二行則顯示有完成型別詮釋的閉包定義。在第三行我們移除了閉包定義的型別詮釋，然後在第四行我們移除了大括號，因為閉包本體只有一個表達式，所以這是選擇性的。這些都是有效的定義，並會在被呼叫時產生相同行為。而 <code>add_one_v3</code> 和 <code>add_one_v4</code> 一定要被呼叫，這樣編譯器才能從它們的使用方式中推導出型別。這就像 <code>let v = Vec::new();</code> 需要型別詮釋，或是有某種型別的數值插入 <code>Vec</code> 中，Rust 才能推導出型別。</p>
<p>對於閉包定義，編譯器會對每個參數與它們的回傳值推導出一個實際型別。舉例來說，範例 13-3 展示一支只會將收到的參數作為回傳值的閉包定義。此閉包並沒有什麼意義，純粹作為範例解釋。注意到我們沒有在定義中加上任何型別詮釋。由於沒有型別詮釋，我們可以用任何型別來呼叫閉包，像我們第一次呼叫就用 <code>String</code>。如果我們接著嘗試用整數呼叫 <code>example_closure</code>，我們就會得到錯誤。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;哈囉&quot;));
    let n = example_closure(5);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-3：嘗試呼叫被推導出兩個不同型別的閉包</span></p>
<p>編譯器會給我們以下錯誤：</p>
<pre><code class="language-console">$ cargo r
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --&gt; src/main.rs:3:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>當我們第一次使用 <code>String</code> 數值呼叫 <code>example_closure</code> 時，編譯器會推導 <code>x</code> 與閉包回傳值的型別為 <code>String</code>。這樣 <code>example_closure</code> 閉包內的型別就會鎖定，然後我們如果對同樣的閉包嘗試使用不同的型別的話，我們就會得到型別錯誤。</p>
<h3 id="獲取參考或移動所有權"><a class="header" href="#獲取參考或移動所有權">獲取參考或移動所有權</a></h3>
<p>閉包要從它們周圍環境取得數值有三種方式，這能直接對應於函式取得參數的三種方式：不可變借用、可變借用，與取得所有權。閉包會依照函式本體如何使用獲取的數值，來決定要用哪種方式。</p>
<p>在範例 13-4 中，我們定義一個閉包來獲取 <code>list</code> 向量的不可變參考，因為它只需要不可變參考就能印出數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;定義閉包前：{:?}&quot;, list);

    let only_borrows = || println!(&quot;來自閉包：{:?}&quot;, list);

    println!(&quot;呼叫閉包前：{:?}&quot;, list);
    only_borrows();
    println!(&quot;呼叫閉包後：{:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-4：定義並呼叫會獲取不可變參考的閉包</span></p>
<p>此範例還示範了變數能綁定閉包的定義，然後我們之後就可以用變數名稱加上括號來呼叫閉包，這樣變數名稱就像函式名稱一樣。</p>
<p>由於我們可以同時擁有 <code>list</code> 的多重不可變參考，<code>list</code> 在閉包定義前、在閉包定義後閉包呼叫前以及閉包呼叫時的程式碼中都是能使用的。此程式碼就會編譯、執行並印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example
定義閉包前：[1, 2, 3]
呼叫閉包前：[1, 2, 3]
來自閉包：[1, 2, 3]
呼叫閉包後：[1, 2, 3]
</code></pre>
<p>接著在範例 13-5 中我們改變閉包本體，對 <code>list</code> 向量加上一個元素。這樣閉包現在就會獲取可變參考：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;呼叫閉包前{:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;呼叫閉包後：{:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-11：定義並呼叫會獲取可變參考的閉包</span></p>
<p>此程式碼會編譯、執行並印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
呼叫閉包前[1, 2, 3]
呼叫閉包後：[1, 2, 3, 7]
</code></pre>
<p>注意到在 <code>borrows_mutably</code> 閉包的定義與呼叫之間的 <code>println!</code> 不見了：當 <code>borrows_mutably</code> 定義時，它會獲取 <code>list</code> 的可變參考。我們在閉包呼叫之後沒有再使用閉包，所以可變參考就結束。在閉包定義與呼叫之間，利用不可變參考印出輸出是不允許的，因為在可變參考期間不能再有其他參考。你可以試試看在那加上 <code>println!</code> 然後看看會收到什麼錯誤訊息！</p>
<p>如果你想要強迫閉包取得周圍環境數值的所有權的話，你可以在參數列表前使用 <code>move</code> 關鍵字。</p>
<p>此技巧適用於將閉包傳給新執行緒來移動資料，讓新的執行緒能擁有該資料。我們會在第十六章討論並行時，介紹為何你會想使用它們。但現在讓我們簡單探索怎麼在閉包使用 <code>move</code> 關鍵字開個新的執行緒就好。範例 13-6 更改了範例 13-4 讓向量在新的執行緒印出而非原本的主執行緒：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;呼叫閉包前：{:?}&quot;, list);

    thread::spawn(move || println!(&quot;來自執行緒：{:?}&quot;, list))
        .join()
        .unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 13-6：使用 <code>move</code> 來迫使執行緒的閉包取得 <code>list</code> 的所有權</span></p>
<p>我們開了一個新的執行緒，將閉包作為引數傳入，閉包本體會印出 <code>list</code>。在範例 13-4 中，閉包只用不可變參考獲取 <code>list</code>，因為要印出 <code>list</code> 的需求只要這樣就好。而在此例中，儘管閉包本體仍然只需要不可變參考就好，我們在閉包定義時想要指定 <code>list</code> 應該要透過 <code>move</code> 關鍵字移入閉包。新的執行緒可能會在主執行緒之前結束，或者主執行緒也有可能會先結束。如果主執行緒持有 <code>list</code> 的所有權卻在新執行緒之前結束並釋放 <code>list</code> 的話，執行緒拿到的不可變參考就會無效了。因此編譯器會要求 <code>list</code> 移入新執行緒的閉包中，這樣參考才會有效。嘗試看看將 <code>move</code> 關鍵字刪掉，或是在主執行緒的閉包定義之後使用 <code>list</code>，看看你會收到什麼編譯器錯誤訊息！</p>
<h3 id="fn-特徵以及將獲取的數值移出閉包"><a class="header" href="#fn-特徵以及將獲取的數值移出閉包"><code>Fn</code> 特徵以及將獲取的數值移出閉包</a></h3>
<p>一但閉包從其定義的周圍環境獲取了數值的參考或所有權（也就是說被<strong>移入</strong>閉包中），閉包本體的程式碼會定義閉包在之後執行結束後要對參考或數值做什麼事情（也就是說被<strong>移出</strong>閉包）。閉包本體可以做以下的事情：將獲取的數值移出閉包、改變獲取的數值、不改變且不移動數值，或是一開始就不從環境獲取任何值。</p>
<p>閉包從周圍環境獲取並處理數值的方式會影響閉包會實作哪種特徵，而這些特徵能讓函式與結構體決定它們想使用哪種閉包。閉包會依照閉包本體處理數值的方式，自動實作一種或多種 <code>Fn</code> 特徵：</p>
<ol>
<li><code>FnOnce</code> 適用於可以呼叫一次的閉包。所有閉包至少都會有此特徵，因為所有閉包都能被呼叫。會將獲取的數值移出本體的閉包只會實作 <code>FnOnce</code> 而不會再實作其他 <code>Fn</code> 特徵，因為這樣它只能被呼叫一次。</li>
<li><code>FnMut</code> 適用於不會將獲取數值移出本體，而且可能會改變獲取數值的閉包。這種閉包可以被呼叫多次。</li>
<li><code>Fn</code> 適用於不會將獲取數值移出本體，而且不會改變獲取數值或是甚至不從環境獲取數值的閉包。這種閉包可以被呼叫多次，而且不會改變周圍環境，這對於並行呼叫閉包多次來說非常重要。</li>
</ol>
<p>讓我們來觀察範例 13-1 中 <code>Option&lt;T&gt;</code> 用到的 <code>unwrap_or_else</code> 方法定義：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>回想一下 <code>T</code> 是一個泛型型別，代表著 <code>Option</code> 的 <code>Some</code> 變體內的數值型別。型別 <code>T</code> 同時也是函式 <code>unwrap_or_else</code> 的回傳型別：比如說對 <code>Option&lt;String&gt;</code> 呼叫  <code>unwrap_or_else</code> 的話就會取得 <code>String</code>。</p>
<p>接著注意到函式 <code>unwrap_or_else</code> 有個額外的泛型型別參數 <code>F</code>。型別 <code>F</code> 是參數 <code>f</code> 的型別，也正是當我們呼叫 <code>unwrap_or_else</code> 時的閉包。</p>
<p>泛型型別 <code>F</code> 指定的特徵界限是 <code>FnOnce() -&gt; T</code>，也就是說 <code>F</code> 必須要能夠呼叫一次、不帶任何引數然後回傳 <code>T</code>。在特徵界限中使用 <code>FnOnce</code> 限制了 <code>unwrap_or_else</code> 只能呼叫 <code>f</code> 最多一次。在 <code>unwrap_or_else</code> 本體中，如果 <code>Option</code> 是 <code>Some</code> 的話，<code>f</code> 就不會被呼叫。如果 <code>Option</code> 是 <code>None</code> 的話，<code>f</code> 就會被呼叫一次。由於所有閉包都有實作 <code>FnOnce</code>，<code>unwrap_or_else</code> 能接受大多數各種不同的閉包，讓它的用途非常彈性。</p>
<blockquote>
<p>注意：函式也可以實作這三種 <code>Fn</code> 特徵。如果我們不必獲取環境數值，在我們需要有實作其中一種 <code>Fn</code> 特徵的項目時，我們可以使用函式名稱而不必用到閉包。舉例來說，對於 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 的數值，我們可以呼叫 <code>unwrap_or_else(Vec::new)</code> 在數值為 <code>None</code> 時取得新的空向量。</p>
</blockquote>
<p>現在讓我們來看看標準函式庫中切片定義的 <code>sort_by_key</code> 方法，來觀察它和 <code>unwrap_or_else</code> 有什麼不同，以及為何 <code>sort_by_key</code> 的特徵界限使用的是 <code>FnMut</code> 而不是 <code>FnOnce</code>。閉包會取得一個引數，這會是該切片當下項目的參考，然後回傳型別 <code>K</code> 的數值以供排序。當你想透過切片項目的特定屬性做排序時，此函式會很實用。在範例 13-7 中，我們有個 <code>Rectangle</code> 實例的列表，然後我們使用 <code>sort_by_key</code> 透過 <code>width</code> 屬性由低至高排序它們：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-7：使用 <code>sort_by_key</code> 依據寬度來排序長方形</span></p>
<p>此程式碼會印出：</p>
<pre><code class="language-console">
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code> 的定義會需要 <code>FnMut</code> 閉包的原因是因為它得呼叫閉包好幾次，對切片的每個項目都要呼叫一次。閉包 <code>|r| r.width</code> 沒有獲取、改變或移動周圍環境的任何值，所以它符合特徵界限的要求。</p>
<p>反之，範例 13-8 示範了一個只實作 <code>FnOnce</code> 特徵的閉包，因為它有將數值移出環境。編譯器不會允許我們將此閉包用在 <code>sort_by_key</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;by key called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}
</code></pre>
<p><span class="caption">範例 13-8：嘗試在 <code>sort_by_key</code> 使用 <code>FnOnce</code> 閉包</span></p>
<p>這裡嘗試用很糟糕且令人費解的方式計算 <code>list</code> 在排序時 <code>sort_by_key</code> 被呼叫了幾次。此程式碼嘗試計數的方式是把閉包周圍環境中型別為 <code>String</code> 的 <code>value</code> 變數放入 <code>sort_operations</code> 向量中。閉包會獲取 <code>value</code>，然後將 <code>value</code> 移出閉包，也就是將 <code>value</code> 的所有權轉移到 <code>sort_operations</code> 向量裡。此向量只能呼叫一次，嘗試呼叫第二次是無法成功的，因為 <code>value</code> 已經不存在於環境中了，無法再次放入 <code>sort_operations</code>！因此，此閉包僅實作了 <code>FnOnce</code>。當我們嘗試編譯此程式碼時，我們會收到錯誤訊息說明 <code>value</code> 無法移出閉包，因為閉包必須實作 <code>FnMut</code>：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (/Users/wuwayne/Desktop/book-tw/listings/ch13-functional-features/listing-13-08)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;by key called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>錯誤訊息指出閉包本體將 <code>value</code> 移出環境的地方。要修正此問題的話，我們需要改變閉包本體，讓它不再將數值移出環境。要計算 <code>sort_by_key</code> 呼叫次數的話，在環境中放置一個計數器，然後在閉包本體增加其值是更直觀的計算方法。範例 13-9 的閉包就能用在 <code>sort_by_key</code>，因為它只獲取了 <code>num_sort_operations</code> 計數器的可變參考，因此可以被呼叫不只一次：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?} 的排序經過 {num_sort_operations} 次運算&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-9：在 <code>sort_by_key</code> 使用 <code>FnMut</code> 閉包是允許的</span></p>
<p>當我們要在函式或型別中定義與使用閉包時，<code>Fn</code> 特徵是很重要的。在下個段落中，我們將討論疊代器。疊代器有許多方法都需要閉包引數，所以隨著我們繼續下去別忘了複習閉包的用法！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用疊代器來處理一系列的項目"><a class="header" href="#使用疊代器來處理一系列的項目">使用疊代器來處理一系列的項目</a></h2>
<p>疊代器（Iterator）模式讓你可以對一個項目序列依序進行某些任務。疊代器的功用是遍歷序列中每個項目，並決定該序列何時結束。當你使用疊代器，你不需要自己實作這些邏輯。</p>
<p>在 Rust 中疊代器是<strong>惰性</strong>（lazy）的，代表除非你呼叫方法來使用疊代器，不然它們不會有任何效果。舉例來說，範例 13-10 的程式碼會透過 <code>Vec&lt;T&gt;</code> 定義的方法 <code>iter</code> 從向量<code>v1</code> 建立一個疊代器來遍歷它的項目。此程式碼本身沒有啥實用之處。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-10：建立一個疊代器</span></p>
<p>疊代器儲存在變數 <code>v1_iter</code> 中。一旦我們建立了疊代器，我們可以有很多使用它的方式。在第三章的範例 3-5 中，我們在 <code>for</code> 迴圈中使用疊代器來對每個項目執行一些程式碼。在過程中這就隱性建立並使用了一個疊代器，雖然我們當時沒有詳細解釋細節。</p>
<p>在範例 13-11 中，我們區隔了疊代器的建立與使用疊代器 <code>for</code> 迴圈。當使用 <code>v1_iter</code> 疊代器的 <code>for</code> 迴圈被呼叫時，疊代器中的每個元素才會在迴圈中每次疊代中使用，以此印出每個數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;取得：{}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-11：在 <code>for</code> 迴圈使用疊代器</span></p>
<p>在標準函式庫沒有提供疊代器的語言中，你可能會用別種方式寫這個相同的函式，像是先從一個變數 0 作為索引開始、使用該變數索引向量來獲取數值，然後在迴圈中增加變數的值直到它抵達向量的總長。</p>
<p>疊代器會為你處理這些所有邏輯，減少重複且你可能會搞砸的程式碼。疊代器還能讓你靈活地將相同的邏輯用於不同的序列，而不只是像向量這種你能進行索引的資料結構。讓我們研究看看疊代器怎麼辦到的。</p>
<h3 id="iterator-特徵與-next-方法"><a class="header" href="#iterator-特徵與-next-方法"><code>Iterator</code> 特徵與 <code>next</code> 方法</a></h3>
<p>所有的疊代器都會實作定義在標準函式庫的 <code>Iterator</code> 特徵。特徵的定義如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 以下省略預設實作
}
<span class="boring">}
</span></code></pre></pre>
<p>注意到此定義使用了一些新的語法：<code>type Item</code> 與 <code>Self::Item</code>，這是此特徵定義的<strong>關聯型別（associated type）</strong>。我們會在第十九章進一步探討關聯型別。現在你只需要知道此程式碼表示要實作 <code>Iterator</code> 特徵的話，你還需要定義 <code>Item</code> 型別，而此 <code>Item</code> 型別會用在方法 <code>next</code> 的回傳型別中。換句話說，<code>Item</code> 型別會是從疊代器回傳的型別。</p>
<p><code>Iterator</code> 型別只要求實作者定義一個方法：<code>next</code> 方法會用 <code>Some</code> 依序回傳疊代器中的每個項目，並在疊代器結束時回傳 <code>None</code>。</p>
<p>我們可以直接在疊代器呼叫 <code>next</code> 方法。範例 13-12 展示從向量建立的疊代器重複呼叫 <code>next</code> 每次會得到什麼數值。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-12：對疊代器呼叫 <code>next</code> 方法</span></p>
<p>注意到 <code>v1_iter</code> 需要是可變的：在疊代器上呼叫 <code>next</code> 方法會改變疊代器內部用來紀錄序列位置的狀態。換句話說，此程式碼<strong>消耗</strong>或者說使用了疊代器。每次 <code>next</code> 的呼叫會從疊代器消耗一個項目。而我們不必在 <code>for</code> 迴圈指定 <code>v1_iter</code> 為可變是因為迴圈會取得 <code>v1_iter</code> 的所有權並在內部將其改為可變。</p>
<p>另外還要注意的是我們從 <code>next</code> 呼叫取得的是向量中數值的不可變參考。<code>iter</code> 方法會從疊代器中產生不可變參考。如果我們想要一個取得 <code>v1</code> 所有權的疊代器，我們可以呼叫 <code>into_iter</code> 而非 <code>iter</code>。同樣地，如果我們想要遍歷可變參考，我們可以呼叫 <code>iter_mut</code> 而非 <code>iter</code>。</p>
<h3 id="消耗疊代器的方法"><a class="header" href="#消耗疊代器的方法">消耗疊代器的方法</a></h3>
<p>標準函式庫提供的 <code>Iterator</code> 特徵有一些不同的預設實作方法，你可以查閱標準函式庫的 <code>Iterator</code> 特徵 API 技術文件來找到這些方法。其中有些方法就是在它們的定義呼叫 <code>next</code> 方法，這就是為何當你實作 <code>Iterator</code> 特徵時需要提供 <code>next</code> 方法的實作。</p>
<p>會呼叫 <code>next</code> 的方法被稱之為<strong>消耗配接器（consuming adaptors）</strong>，因為呼叫它們會使用掉疊代器。其中一個例子就是方法 <code>sum</code>，這會取得疊代器的所有權並重複呼叫 <code>next</code> 來遍歷所有項目，因而消耗掉疊代器。隨著遍歷的過程中，他會將每個項目加到總計中，並在疊代完成時回傳總計數值。範例 13-13 展示了一個使用 <code>sum</code> 方法的測試：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-13：呼叫 <code>sum</code> 方法來取得疊代器中所有項目的總計數值</span></p>
<p>我們呼叫 <code>sum</code> 之後就不再被允許使用 <code>v1_iter</code> 了，因為 <code>sum</code> 取得了疊代器的所有權。</p>
<h3 id="產生其他疊代器的方法"><a class="header" href="#產生其他疊代器的方法">產生其他疊代器的方法</a></h3>
<p><strong>疊代配接器</strong>（iterator adaptors）是定義在 <code>Iterator</code> 特徵的方法，它們不會消耗掉疊代器。它們會改變原本疊代器的一些屬性來產生不同的疊代器。</p>
<p>範例 13-14 呼叫了疊代器的疊代配接器方法 <code>map</code>，它會取得一個閉包在進行疊代時對每個項目進行呼叫。<code>map</code> 方法會回傳個項目被改變過的新疊代器。這裡的閉包會將向量中的每個項目加 1 來產生新的疊代器：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-14：呼叫疊代配接器 <code>map</code> 來建立新的疊代器</span></p>
<p>不過此程式碼會產生個警告：</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>範例 13-14 的程式碼不會做任何事情，我們指定的閉包沒有被呼叫到半次。警告提醒了我們原因：疊代配接器是惰性的，我們必須在此消耗疊代器才行。</p>
<p>要修正並消耗此疊代器，我們將使用 <code>collect</code> 方法，這是我們在範例 12-1 搭配 <code>env::args</code> 使用的方法。此方法會消耗疊代器並收集結果數值至一個資料型別集合。</p>
<p>在範例 13-15 中，我們將遍歷 <code>map</code> 呼叫所產生的疊代器結果數值收集到一個向量中。此向量最後會包含原本向量每個項目都加 1 的數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-15：呼叫方法 <code>map</code> 來建立新的疊代器並呼叫 <code>collect</code> 方法來消耗新的疊代器來產生向量</span></p>
<p>因為 <code>map</code> 接受一個閉包，我們可以對每個項目指定任何我們想做的動作。這是一個展示如何使用閉包來自訂行為，同時又能重複使用 <code>Iterator</code> 特徵提供的遍歷行為的絕佳例子。</p>
<p>你可以透過疊代配接器串連多重呼叫，在進行一連串複雜運算的同時，仍保持良好的閱讀性。但因為所有的疊代器都是惰性的，你必須呼叫能消耗配接器的方法來取得疊代配接器的結果。</p>
<h3 id="使用閉包獲取它們的環境"><a class="header" href="#使用閉包獲取它們的環境">使用閉包獲取它們的環境</a></h3>
<p>許多疊代配接器都會拿閉包作為引數，而通常我們向疊代配接器指定的閉包引數都能獲取它們周圍的環境。</p>
<p>在以下例子中，我們要使用 <code>filter</code> 方法來取得閉包。閉包會取的疊代器的每個項目並回傳布林值。如果閉包回傳 <code>true</code>，該數值就會被包含在 <code>filter</code> 產生的疊代器中；如果閉包回傳 <code>false</code>，該數值就不會被包含在結果疊代器中。</p>
<p>在範例 13-16 中我們使用 <code>filter</code> 與一個從它的環境獲取變數 <code>shoe_size</code> 的閉包來遍歷一個有 <code>Shoe</code> 結構體實例的集合。它會回傳只有符合指定大小的鞋子：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;運動鞋&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;涼鞋&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;靴子&quot;),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;運動鞋&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;靴子&quot;)
                },
            ]
        );
    }
}
</code></pre>
<p><span class="caption">範例 13-16：使用 <code>filter</code> 方法與一個獲取 <code>shoe_size</code> 的閉包</span></p>
<p>函式 <code>shoes_in_size</code> 會取得鞋子向量的所有權以及一個鞋子大小作為參數。它會回傳只有符合指定大小的鞋子向量。</p>
<p>在 <code>shoes_in_size</code> 的本體中，我們呼叫 <code>into_iter</code> 來建立一個會取得向量所有權的疊代器。然後我們呼叫 <code>filter</code> 來將該疊代器轉換成只包含閉包回傳為 <code>true</code> 的元素的新疊代器。</p>
<p>閉包會從環境獲取 <code>shoe_size</code> 參數並比較每個鞋子數值的大小，讓只有符合大小的鞋子保留下來。最後呼叫 <code>collect</code> 來收集疊代器回傳的數值進一個函式會回傳的向量。</p>
<p>此測試顯示了當我們呼叫 <code>shoes_in_size</code> 時，我們會得到我們指定相同大小的鞋子。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="改善我們的-io-專案"><a class="header" href="#改善我們的-io-專案">改善我們的 I/O 專案</a></h2>
<p>有了疊代器這樣的新知識，我們可以使用疊代器來改善第十二章的 I/O 專案，讓程式碼更清楚與簡潔。我們來看看疊代器如何改善 <code>Config::build</code> 函式與 <code>search</code> 函式的實作。</p>
<h3 id="使用疊代器移除-clone"><a class="header" href="#使用疊代器移除-clone">使用疊代器移除 <code>clone</code></a></h3>
<p>在範例 12-6 中，我們加了些程式碼來取得 <code>String</code> 數值的切片並透過索引切片與克隆數值來產生 <code>Config</code> 實例，讓 <code>Config</code> 結構體能擁有其數值。在範例 13-17 中，我們重現了範例 12-23 的 <code>Config::build</code> 函式實作：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;引數不足&quot;);
        }

        let query = args[1].clone();
        let file_path = args[2].clone();

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-17：重現範例 12-23 的 <code>Config::build</code> 函式</span></p>
<p>當時我們說先不用擔心 <code>clone</code> 呼叫帶來的效率問題，因為我們會在之後移除它們。現在正是絕佳時機！</p>
<p>我們在此需要 <code>clone</code> 的原因為我們的參數 <code>args</code> 是擁有 <code>String</code> 元素的切片，但是 <code>build</code> 函式並不擁有 <code>args</code>。要回傳 <code>Config</code> 實例的所有權，我們必須克隆數值給 <code>Config</code> 的 <code>query</code> 與 <code>filename</code> 欄位，<code>Config</code> 實例才能擁有其值。</p>
<p>有了我們新學到的疊代器，我們可以改變 <code>build</code> 函式來取得疊代器的所有權來作為引數，而非借用切片。我們會來使用疊代器的功能，而不是檢查切片長度並索引特定位置。這能讓 <code>Config::build</code> 函式的意圖更清楚，因為疊代器會存取數值。</p>
<p>一旦 <code>Config::build</code> 取得疊代器的所有權並不再使用借用的索引動作，我們就可以從疊代器中移動 <code>String</code> 的數值至 <code>Config</code> 而非呼叫 <code>clone</code> 來產生新的分配。</p>
<h4 id="直接使用回傳的疊代器"><a class="header" href="#直接使用回傳的疊代器">直接使用回傳的疊代器</a></h4>
<p>請開啟你的 I/O 專案下的 <em>src/main.rs</em> 檔案，這應該會看起來像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::build(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;解析引數時出現問題：{err}&quot;);
        process::exit(1);
    });

    // --省略--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;應用程式錯誤：{e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p>我們首先會改變範例 12-24 的 <code>main</code> 函式開頭段落成範例 13-18 這段使用疊代器的程式碼。這在我們更新 <code>Config::build</code> 之前都還無法編譯。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::build(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;解析引數時出現問題：{err}&quot;);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;應用程式錯誤：{e}&quot;);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 13-18：傳遞 <code>env::args</code> 的回傳值給 <code>Config::build</code></span></p>
<p><code>env::args</code> 函式回傳的是疊代器！與其收集疊代器的數值成一個向量再傳遞切片給 <code>Config::build</code>，現在我們可以直接傳遞 <code>env::args</code> 回傳的疊代器所有權給 <code>Config::build</code>。</p>
<p>接下來，我們需要更新 <code>Config::build</code> 的定義。在 I/O 專案的 <em>src/lib.rs</em> 檔案中，讓我們變更 <code>Config::build</code> 的簽名成範例 13-19 的樣子。這還無法編譯，因為我們需要更新函式本體。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-19：更新 <code>Config::build</code> 的簽名來接收疊代器</span></p>
<p>標準函式庫技術文件顯示 <code>env::args</code> 函式回傳的疊代器型別為 <code>std::env::Args</code>，而該疊代器有實作 <code>Iterator</code> 特徵並回傳 <code>String</code> 數值。</p>
<p>我們更新了 <code>Config::build</code> 函式的簽名，讓參數 <code>args</code> 擁有個特徵界限為 <code>impl Iterator&lt;Item = String&gt;</code> 的泛型型別而非 <code>&amp;[String]</code>。我們在第十章的<a href="ch10-02-traits.html#traits-as-parameters">「特徵作為參數」</a><!-- ignore -->段落討論過 <code>impl Trait</code> 的語法，這樣的用法讓 <code>args</code> 可以接收任何有實作 <code>Iterator</code> 並回傳 <code>String</code> 數值的型別。</p>
<p>因為我們取得了 <code>args</code> 的所有權，而且我們需要將 <code>args</code> 成為可變的讓我們可以疊代它，所以我們將關鍵字 <code>mut</code> 加到 <code>args</code> 的參數指定使其成為可變的。</p>
<h4 id="使用-iterator-特徵方法而非索引"><a class="header" href="#使用-iterator-特徵方法而非索引">使用 <code>Iterator</code> 特徵方法而非索引</a></h4>
<p>接下來，我們要修正 <code>Config::build</code> 的本體。因為 <code>args</code> 有實作 <code>Iterator</code> 特徵，所以我們知道我們可以對它呼叫 <code>next</code> 方法！範例 13-20 更新了範例 12-23 的程式碼來使用 <code>next</code> 方法：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn build(
        mut args: impl Iterator&lt;Item = String&gt;,
    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;無法取得搜尋字串&quot;),
        };

        let file_path = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;無法取得檔案路徑&quot;),
        };

        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();

        Ok(Config {
            query,
            file_path,
            ignore_case,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-20：變更 <code>Config::build</code> 的本體來使用疊代器方法</span></p>
<p>我們還記得 <code>env::args</code> 回傳的第一個數值會是程式名稱。我們想要忽略該值並取得下個數值，所以我們第一次呼叫 <code>next</code> 時不會對回傳值做任何事。再來我們才會呼叫 <code>next</code> 來取得我們想要的數值置入 <code>Config</code> 中的 <code>query</code> 欄位。如果 <code>next</code> 回傳 <code>Some</code> 的話，我們使用 <code>match</code> 來提取數值。如果它回傳 <code>None</code> 的話，這代表引數不足，所以我們提早用 <code>Err</code> 數值回傳。我們對 <code>filename</code> 數值也做一樣的事。</p>
<h3 id="透過疊代配接器讓程式碼更清楚"><a class="header" href="#透過疊代配接器讓程式碼更清楚">透過疊代配接器讓程式碼更清楚</a></h3>
<p>我們也可以對 I/O 專案中的 <code>search</code> 函式利用疊代器的優勢，範例 13-21 重現了範例 12-19 的程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;引數不足&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let file_path = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, file_path })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-21：範例 12-19 的 <code>search</code> 函式實作</span></p>
<p>我們可以使用疊代配接器（iterator adaptor）方法讓此程式碼更精簡。這樣做也能避免我們產生過程中的 <code>results</code> 可變向量。函式程式設計風格傾向於最小化可變狀態的數量使程式碼更加簡潔。移除可變狀態還在未來有機會讓搜尋可以平行化，因為我們不需要去管理 <code>results</code> 向量的並行存取。範例 13-22 展示了此改變：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub file_path: String,
</span><span class="boring">    pub ignore_case: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn build(
</span><span class="boring">        mut args: impl Iterator&lt;Item = String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;無法取得搜尋字串&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let file_path = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;無法取得檔案路徑&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let ignore_case = env::var(&quot;IGNORE_CASE&quot;).is_ok();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            file_path,
</span><span class="boring">            ignore_case,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.file_path)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.ignore_case {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{line}&quot;);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-22：對 <code>search</code> 函式實作使用疊代配接器方法</span></p>
<p>回想一下 <code>search</code> 函式的目的是要回傳 <code>contents</code> 中所有包含 <code>query</code> 的行數。類似於範例 13-16 的 <code>filter</code> 範例，此程式碼使用 <code>filter</code> 配接器來只保留 <code>line.contains(query)</code> 回傳為 <code>true</code> 的行數。我們接著就可以用 <code>collect</code> 收集符合的行數成另一個向量。這樣簡單多了！你也可以對 <code>search_case_insensitive</code> 函式使用疊代器方法做出相同的改變。</p>
<h3 id="迴圈與疊代器之間的選擇"><a class="header" href="#迴圈與疊代器之間的選擇">迴圈與疊代器之間的選擇</a></h3>
<p>接下來的邏輯問題是在你自己的程式碼中你應該與為何要使用哪種風格呢：是要原本範例 13-21 的程式碼，還是範例 13-22 使用疊代器的版本呢？大多數的 Rust 程式設計師傾向於使用疊代器。一開始的確會有點難上手，不過一旦你熟悉各種疊代配接器與它們的用途後，疊代器就會很好理解了。不同於用迴圈迂迴處理每一步並建構新的向量，疊代器能更專注在迴圈的高階抽象上。這能抽象出常見的程式碼，並能更容易看出程式碼中的重點部位，比如疊代器中每個元素要過濾的條件。</p>
<p>但是這兩種實作真的完全相等嗎？你的直覺可能會假設低階的迴圈可能更快些。讓我們來討論效能吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="比較效能迴圈-vs-疊代器"><a class="header" href="#比較效能迴圈-vs-疊代器">比較效能：迴圈 vs. 疊代器</a></h2>
<p>為了決定該使用迴圈還是疊代器，你需要知道哪個實作比較快：是顯式 <code>for</code> 迴圈的版本，還是疊代器的版本。</p>
<p>我們可以透過讀取整本 Sir Arthur Conan Doyle 寫的 <em>The Adventures of Sherlock Holmes</em> 到 <code>String</code> 中並搜尋內容中的 <em>the</em> 來進行評測。以下為針對 <code>search</code> 函式使用 <code>for</code> 迴圈與使用疊代器的版本評測（benchmark）：</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>疊代器版本竟然比較快一些！我們在此不會解釋評測的程式碼，因為這裡的重點不再於證明這兩種版本是一樣快的，而是要理解這兩種實作對效能的影響。</p>
<p>要做更全面的評測的話，你應該要檢查使用不同大小的不同文字來作為 <code>contents</code>、不同單字與不同長度來作為 <code>query</code>，以及所有各式各樣的可能性。這邊的重點在於：疊代器雖然是高階抽象，但其編譯出來的程式碼與你親自寫出低階的程式碼幾乎相同。疊代器是 Rust 其中一種<strong>零成本抽象</strong>（zero-cost abstractions），這指的是使用的抽象不會在執行時有額外的開銷。這是 C++ 的初始設計暨實作者 Bjarne Stroustrup 在 “Foundations of C++” (2012) 書中所定義的<strong>零開銷</strong>（zero-overhead）的概念：</p>
<blockquote>
<p>大致上來說，C++ 的實作遵守著零開銷的原則：你沒有使用到的話，你就不必買單。而且你有使用到的話，你不可能再寫出更好的程式碼。</p>
</blockquote>
<p>作為另一個例子，以下程式碼是音訊解碼器的其中一個段落。解碼演算碼使用線性預測數學運算，並依據之前樣本的線性函式來預估未來的數值。此程式碼使用一連串的疊代器來對作用域中的三個變數進行數學運算：資料切片 <code>buffer</code>、長度為 12 的 <code>coefficients</code> 陣列以及要偏移的數量 <code>qlp_shift</code>。我們在範例中宣告變數但沒有給予任何數值，雖然只看此程式碼的確沒有什麼意義，但是這仍然是個現實世界中的其中一個簡例，可以來看出 Rust 如何將高階的想法轉換成低階的程式碼。</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>要計算 <code>prediction</code> 的數值的話，此程式碼會遍歷 <code>coefficients</code> 的 12 個數值並使用 <code>zip</code> 方法將係數數值與 <code>buffer</code> 中之前 12 個數值做配對。然後在每個配對中，我們將數值相乘，然後相加所有結果，最後對總和往右偏移 <code>qlp_shift</code> 位。</p>
<p>像音訊解碼器這種的應用程式運算通常最注重效率。我們在此建立了一個疊代器，使用兩個配接器，然後消化數值。這段 Rust 程式碼會產生什麼樣的組合語言程式碼呢？在本書撰寫時，它會編譯出與你自己手寫一樣的組合語言。遍歷 <code>coefficients</code> 的數值完全不需用到迴圈：Rust 知道一共有 12 次疊代，所以它會「展開（unroll）」迴圈。<strong>展開</strong>是一種優化方式，這會移除迴圈控制程式碼並改產生針對迴圈中每次疊代的重複程式碼。</p>
<p>所有的係數都會存在暫存器中，這意味著存取數值會非常地快。在執行時不會有對陣列的界限檢查。這些所有 Rust 能做的優化讓產生的程式碼可以十分迅速。現在既然你已經知道了，你就可以自在地使用疊代器與閉包！它們可以寫出高階的程式碼，但不會犧牲執行時的效能。</p>
<h2 id="總結-12"><a class="header" href="#總結-12">總結</a></h2>
<p>閉包與疊代器是 Rust 啟發自函式程式語言的概念。它們讓 Rust 在表達高階概念的同時，仍能擁有低階程式碼的效能。閉包與疊代器的實作對執行時效能不會有影響。這是 Rust 竭力提供零成本抽象的目標之一。</p>
<p>現在我們改善了 I/O 專案的可讀性，讓我們看看 <code>cargo</code> 一些更多的功能，來幫助我們分享專案給全世界。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更多關於-cargo-與-cratesio-的內容"><a class="header" href="#更多關於-cargo-與-cratesio-的內容">更多關於 Cargo 與 Crates.io 的內容</a></h1>
<p>目前我們只使用了 Cargo 最基本的功能來建構、執行與測試我們的程式碼，但它還能做更多事。在本章節中我們將討論這些其他的進階功能，你將瞭解如何做到以下動作：</p>
<ul>
<li>透過發佈設定檔來自訂你的建構</li>
<li>發佈函式庫到 <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>透過工作空間組織大型專案</li>
<li>從 <a href="https://crates.io/">crates.io</a><!-- ignore --> 安裝執行檔</li>
<li>使用自訂命令擴展 Cargo 的功能</li>
</ul>
<p>Cargo 能做的事比本章會介紹到的功能還多，所以想要知道它所有功能的話，歡迎查閱<a href="https://doc.rust-lang.org/cargo/">它的技術文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過發佈設定檔自訂建構"><a class="header" href="#透過發佈設定檔自訂建構">透過發佈設定檔自訂建構</a></h2>
<p>在 Rust 中<strong>發佈設定檔</strong>（release profiles）是個預先定義好並可用不同配置選項來自訂的設定檔，能讓程式設計師掌控更多選項來編譯程式碼。每個設定檔的配置彼此互相獨立。</p>
<p>Cargo 有兩個主要的設定檔：<code>dev</code> 設定檔會在當你對 Cargo 執行 <code>cargo build</code> 時所使用；<code>release</code> 設定檔會在當你對 Cargo 執行 <code>cargo build --release</code> 時所使用。<code>dev</code> 設定檔預設定義為適用於開發時使用，而<code>release</code> 設定檔預設定義為適用於發佈時使用。</p>
<p>你可能會覺得這些設定檔名稱很眼熟，因為它們就已經顯示在輸出結果過：</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p><code>dev</code> 與 <code>release</code> 是編譯器會使用到的不同設定檔。</p>
<p>當專案的 <em>Cargo.toml</em> 中你沒有顯式加上任何 <code>[profile.*]</code> 段落的話，Cargo 就會使用每個設定檔的預設設置。透過對你想要自訂的任何設定檔加上 <code>[profile.*]</code> 段落，你可以覆寫任何預設設定的子集。舉例來說，以下是 <code>dev</code> 與 <code>release</code> 設定檔中 <code>opt-level</code> 設定的預設數值：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code> 設定控制了 Rust 對程式碼進行優化的程度，範圍從 0 到 3。提高優化程度會增加編譯時間，所以如果你在開發過程中得時常編譯程式碼的話，你傾向於編譯快一點而不管優化的多寡，就算結果程式碼會執行的比較慢。這就是 <code>dev</code> 的 <code>opt-level</code> 預設為 0 的原因。當你準備好要發佈你的程式碼時，則最好花多點時間來編譯。你只需要在發佈模式編譯一次，但你的編譯程式則會被執行很多次，所以發佈模式選擇花費多點編譯時間來讓程式跑得比較快。這就是 <code>release</code> 的 <code>opt-level</code> 預設為 3 的原因。</p>
<p>你可以在 <em>Cargo.toml</em> 加上不同的數值來覆蓋預設設定。舉例來說，如果我們希望在開發設定檔使用優化等級 1 的話，我們可以在專案的 <em>Cargo.toml</em> 檔案中加上這兩行：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>這樣就會覆蓋預設設定 <code>0</code>。現在當我們執行 <code>cargo build</code>，Cargo 就會使用 <code>dev</code> 設定檔的預設值以及我們自訂的 <code>opt-level</code>。因為我們將 <code>opt-level</code> 設為 <code>1</code>，Cargo 會比原本的預設進行更多優化，但沒有發佈建構那麼多。</p>
<p>對於完整的設置選項與每個設定檔的預設列表，請查閱 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 的技術文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="發佈-crate-到-cratesio"><a class="header" href="#發佈-crate-到-cratesio">發佈 Crate 到 Crates.io</a></h2>
<p>我們已經使用過 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的套件來作為我們專案的依賴函式庫，但是你也可以發佈你自己的套件來將你的程式碼提供給其他人使用。<a href="https://crates.io/">crates.io</a><!-- ignore --> 會發行套件的原始碼，所以它主要用來託管開源程式碼。</p>
<p>Rust 與 Cargo 有許多功能可以幫助其他人更容易找到並使用你發佈的套件。我們會介紹其中一些功能並解釋如何發佈套件。</p>
<h3 id="寫上有幫助的技術文件註解"><a class="header" href="#寫上有幫助的技術文件註解">寫上有幫助的技術文件註解</a></h3>
<p>準確地加上套件的技術文件有助於其他使用者知道如何及何時使用它們，所以投資時間在寫技術文件上是值得的。在第三章我們提過如何使用兩條斜線 <code>//</code> 來加上 Rust 程式碼註解。Rust 還有個特別的註解用來作為技術文件，俗稱為<strong>技術文件註解（documentation comment）</strong>，這能用來產生 HTML 技術文件。這些 HTML 顯示公開 API 項目中技術文件註解的內容，讓對此函式庫有興趣的開發者知道如何<strong>使用</strong>你的 crate，而不需知道 crate 是如何<strong>實作</strong>的。</p>
<p>技術文件註解使用三條斜線 <code>///</code> 而不是兩條，並支援 Markdown 符號來格式化文字。技術文件註解位於它們對應項目的上方。範例 14-1 顯示了 <code>my_crate</code> crate 中 <code>add_one</code> 的技術文件註解。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">範例 14-1：函式的技術文件註解</span></p>
<p>我們在這裡加上了解釋函式 <code>add_one</code> 行為的描述、加上一個標題為 <code>Examples</code> 的段落並附上展示如何使用 <code>add_one</code> 函式的程式碼。我們可以透過執行 <code>cargo doc</code> 來從技術文件註解產生 HTML 技術文件。此命令會執行隨著 Rust 一起發佈的工具 <code>rustdoc</code>，並在 <em>target/doc</em> 目錄下產生 HTML 技術文件。</p>
<p>為了方便起見，你可以執行 <code>cargo doc --open</code> 來建構當前 crate 的 HTML 技術文件（以及 crate 所有依賴的技術文件）並在網頁瀏覽器中開啟結果。導向到函式 <code>add_one</code> 而你就能看到技術文件註解是如何呈現的，如圖示 14-1 所示：</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">圖示 14-1：函式 <code>add_one</code> 的 HTML 技術文件</span></p>
<h4 id="常見技術文件段落"><a class="header" href="#常見技術文件段落">常見技術文件段落</a></h4>
<p>我們在範例 14-1 使用 <code># Examples</code> Markdown 標題來在 HTML 中建立一個標題為「Examples」的段落。以下是 crate 技術文件中常見的段落標題：</p>
<ul>
<li><strong>Panics</strong>：該函式可能會導致恐慌的可能場合。函式的呼叫者不希望他們的程式恐慌的話，就要確保他們沒有在這些情況下呼叫該函式。</li>
<li><strong>Errors</strong>：如果函式回傳 <code>Result</code>，解釋發生錯誤的可能種類以及在何種條件下可能會回傳這些錯誤有助於呼叫者，讓他們可以用不同方式來寫出處理不同種錯誤的程式碼。</li>
<li><strong>Safety</strong>: 如果呼叫的函式是 <code>unsafe</code> 的話（我們會在第十九章討論不安全的議題），就必須要有個段落解釋為何該函式是不安全的，並提及函式預期呼叫者要確保哪些不變條件（invariants）。</li>
</ul>
<p>大多數的技術文件註解不全都需要這些段落，但這些可能是使用者有興趣瞭解的內容，你可以作為提醒你的檢查列表。</p>
<h4 id="將技術文件註解作為測試"><a class="header" href="#將技術文件註解作為測試">將技術文件註解作為測試</a></h4>
<p>在技術文件註解加上範例程式碼區塊有助於解釋如何使用你的函式庫，而且這麼做還有個額外好處：執行 <code>cargo test</code> 也會將你的技術文件視為測試來執行！在技術文件加上範例的確是最佳示範，但是如果程式碼在技術文件寫完之後變更的話，該範例可能就會無法執行了。如果我們對範例 14-1 中有附上技術文件的函式 <code>add_one</code> 執行 <code>cargo test</code> 的話，我們會看見測試結果有以下這樣的段落：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
</code></pre>
<p>現在如果我們變更函式或範例使其內的 <code>assert_eq!</code> 會恐慌並再次執行 <code>cargo test</code> 的話，我們會看到技術文件測試能互相獲取錯誤，告訴我們範例與程式碼已經不同步了！</p>
<h4 id="包含項目結構的註解"><a class="header" href="#包含項目結構的註解">包含項目結構的註解</a></h4>
<p>風格為 <code>//!</code> 技術文件註解會對其包含該註解的項目加上的技術文件，而不是對註解後的項目加上技術文件。我們通常將此技術文件註解用於 crate 源頭檔（通常為 <em>src/lib.rs</em>）或模組來對整個 crate 或模組加上技術文件。</p>
<p>舉例來說，如果我們希望能加上技術文件來描述包含 <code>add_one</code> 函式的 <code>my_crate</code> 目的，我們可以用  <code>//!</code> 在 <em>src/lib.rs</em> 檔案開頭加上技術文件註解，如範例 14-2 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --省略--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 14-2：描述整個 <code>my_crate</code> crate 的技術文件</span></p>
<p>注意到 <code>//!</code> 最後一行之後並沒有緊貼任何程式碼，因為我們是用 <code>//!</code> 而非 <code>///</code> 來下註解，我們是對包含此註解的整個項目加上技術文件，而不是此註解之後的項目。在此例中，該項目就是 <em>src/lib.rs</em> 檔案，也就是 crate 的源頭。這些註解會描述整個 crate。</p>
<p>當我們執行 <code>cargo doc --open</code>，這些註解會顯示在 <code>my_crate</code> 技術文件的首頁，位於 crate 公開項目列表的上方，如圖示 14-2 所示：</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">圖示 14-2：<code>my_crate</code> 的技術文件，包含描述整個 crate 的註解</span></p>
<p>項目中的技術文件註解可以用來分別描述 crate 和模組。用它們來將解釋容器整體的目的有助於你的使用者瞭解該 crate 的程式碼組織架構。</p>
<h3 id="透過-pub-use-匯出理想的公開-api"><a class="header" href="#透過-pub-use-匯出理想的公開-api">透過 <code>pub use</code> 匯出理想的公開 API</a></h3>
<p>公開 API 的架構是發佈 crate 時要考量到的一大重點。使用 crate 的人可能並沒有你那麼熟悉其中的架構，而且如果你的 crate 模組分層越深的話，他們可能就難以找到他們想使用的部分。</p>
<p>在第七章中，我們介紹了如何使用 <code>mod</code> 關鍵字來組織我們的程式碼成模組、如何使用 <code>pub</code> 關鍵字來公開項目，以及如何使用 <code>use</code> 關鍵字在將項目引入作用域。然而在開發 crate 時的架構雖然對你來說是合理的，但對你的使用者來說可能就不是那麼合適了。你可能會希望用有數個層級的分層架構來組織你的程式碼，但是要是有人想使用你定義在分層架構裡的型別時，它們可能就很難發現這些型別的存在。而且輸入 <code>use my_crate::some_module::another_module::UsefulType;</code> 是非常惱人的，我們會希望輸入 <code>use my_crate::UsefulType;</code> 就好。</p>
<p>好消息是如果你的架構<strong>不便於</strong>其他函式庫所使用的話，你不必重新組織你的內部架構：你可以透過使用 <code>pub use</code>選擇重新匯出（re-export）項目來建立一個不同於內部私有架構的公開架構。重新匯出會先取得某處的公開項目，再從其他地方使其公開，讓它像是被定義在其他地方一樣。</p>
<p>舉例來說，我們建立了一個函式庫叫做 <code>art</code> 來模擬藝術概念。在函式庫中有兩個模組：<code>kinds</code> 模組包含兩個枚舉 <code>PrimaryColor</code> 和 <code>SecondaryColor</code>；而 <code>utils</code> 模組包含一個函式 <code>mix</code>，如範例 14-3 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground test_harness">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --省略--
<span class="boring">        unimplemented!();
</span>    }
}
</code></pre>
<p><span class="caption">範例 14-3：函式庫 <code>art</code> 有兩個模組項目 <code>kinds</code> 和 <code>utils</code></span></p>
<p>圖示 14-3 顯示了此 crate 透過 <code>cargo doc</code> 產生的技術文件首頁：</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">圖示 14-3：<code>art</code> 的技術文件首頁陳列了 <code>kinds</code> 和 <code>utils</code> 模組</span></p>
<p>注意到 <code>PrimaryColor</code> 與 <code>SecondaryColor</code> 型別沒有列在首頁，而函式 <code>mix</code> 也沒有。我們必須點擊 <code>kinds</code> 與 <code>utils</code> 才能看到它們。</p>
<p>其他依賴此函式庫的 crate 需要使用 <code>use</code> 陳述式來將 <code>art</code> 的項目引入作用域中，並指定當前模組定義的架構。範例 14-4 顯示了從 <code>art</code> crate 使用 <code>PrimaryColor</code> 和 <code>mix</code> 項目的 crate 範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">範例 14-4：一個使用 <code>art</code> 並匯出內部架構項目的 crate</span></p>
<p>範例 14-4 中使用 <code>art</code> crate 的程式碼作者必須搞清楚 <code>PrimaryColor</code> 位於 <code>kinds</code> 模組中而 <code>mix</code> 位於 <code>utils</code> 模組中。<code>art</code> crate 的模組架構對開發 <code>art</code> crate 的開發者才比較有意義，對使用者來說就沒那麼重要。內部架構沒有提供什麼有用的資訊給想要知道如何使用 <code>art</code> crate 的人，還容易造成混淆，因為開發者得自己搞清楚要從何處找起，而且必須在 <code>use</code> 陳述式中指定每個模組名稱。</p>
<p>要從公開 API 移除內部架構，我們可以修改範例 14-3 中 <code>art</code> crate 的程式碼，並加上 <code>pub use</code> 陳述式來在頂層重新匯出項目，如範例 14-5 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --省略--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --省略--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 14-5：加上 <code>pub use</code> 陳述式來重新匯出項目</span></p>
<p><code>cargo doc</code> 對此 crate 產生的 API 技術文件現在就會顯示與連結重新匯出的項目到首頁中，如圖示 14-4 所示。讓<code>PrimaryColor</code> 與 <code>SecondaryColor</code> 型別以及函式 <code>mix</code> 更容易被找到。</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">圖示 14-：<code>art</code> 的技術文件首頁會連結重新匯出的結果</span></p>
<p><code>art</code> crate 使用者仍可以看到並使用範例 14-3 的內部架構，如範例 14-4 所展示的方式，或者它們可以使用像範例 14-5 這樣更方便的架構，如範例 14-6 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --省略--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}
</code></pre>
<p><span class="caption">範例 14-6：使用從 <code>art</code> crate 重新匯出項目的程式</span></p>
<p>如果你有許多巢狀模組（nested modules）的話，在頂層透過 <code>pub use</code> 重新匯出型別可以大大提升使用 crate 的體驗。另一項 <code>pub use</code> 的常見用途是重新匯出目前 crate 依賴的定義，讓那些 crate 定義成會你的 crate 公開 API 的一部分。</p>
<p>提供實用的公開 API 架構更像是一門藝術而不只是科學，而你可以一步步來尋找最適合使用者的 API 架構。使用 <code>pub use</code> 可以給你更多組織 crate 內部架構的彈性，並將內部架構與你要呈現給使用者的介面互相解偶（decouple）。你可以觀察一些你安裝過的程式碼，看看它們的內部架構是不是不同於它們的公開 API。</p>
<h3 id="設定-cratesio-帳號"><a class="header" href="#設定-cratesio-帳號">設定 Crates.io 帳號</a></h3>
<p>在你可以發佈任何 crate 之前，你需要建立一個 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的帳號並取得一個 API token。請前往 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的首頁並透過 GitHub 帳號來登入（GitHub 目前是必要的，但未來可能會支援其他建立帳號的方式）一旦你登入好了之後，到你的帳號設定 <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> 並索取你的 API key，然後用這個 API key 來執行  <code>cargo login</code> 命令，如以下所示：</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>此命令會傳遞你的 API token 給 Cargo 並儲存在本地的 <em>~/.cargo/credentials</em>。注意此 token 是個<strong>祕密（secret）</strong>，千萬不要分享給其他人。如果你因為任何原因分享給任何人的話，你最好撤銷掉並回到 <a href="https://crates.io/">crates.io</a><!-- ignore --> 產生新的 token。</p>
<h3 id="新增詮釋資料到新的-crate"><a class="header" href="#新增詮釋資料到新的-crate">新增詮釋資料到新的 Crate</a></h3>
<p>讓我們假設你有個 crate 想要發佈。在發佈之前，你需要加上一些詮釋資料（metadata），也就是在 crate 的 <em>Cargo.toml</em> 檔案中 <code>[package]</code> 的段落內加上更多資料。</p>
<p>你的 crate 必須要有個獨特的名稱。雖然你在本地端開發 crate 時，你的 crate 可以是任何你想要的名稱。但是 <a href="https://crates.io/">crates.io</a><!-- ignore --> 上的 crate 名稱採先搶先贏制。一旦有 crate 名稱被取走了，其他人就不能再使用該名稱來發佈 crate。在嘗試發佈 crate 前，最好先搜尋你想使用的名稱。如果該名稱已被使用了，你就需要想另一個名稱，並在 <em>Cargo.toml</em> 檔案中 <code>[package]</code> 段落的 <code>name</code> 欄位使用新的名稱來發佈，如以下所示：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>當你選好獨特名稱後，此時執行 <code>cargo publish</code> 來發佈 crate 的話，你會得到以下警告與錯誤：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--省略--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>這是因為你還缺少一些關鍵資訊：描述與授權條款是必須的，所以人們才能知道你的 crate 在做什麼以及在何種情況下允許使用。在 <em>Cargo.toml</em> 檔案中加上一兩句描述，它就會顯示在你的 crate 的搜尋結果中。至於 <code>license</code> 欄位，你需要給予 <em>license identifier value</em>。<a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)</a> 有列出你可以使用的標識符數值。舉例來說，要指定你的 crate 使用 MIT 授權條款的話，就加上 <code>MIT</code> 標識符：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>如果你想使用沒有出現在 SPDX 的授權條款，你需要將該授權條款的文字儲存在一個檔案中、將該檔案加入你的專案中並使用 <code>license-file</code> 來指定該檔案名稱，而不使用 <code>license</code>。</p>
<p>你的專案適合使用什麼樣的授權條款超出了本書的範疇。不過 Rust 社群中許多人都會用 <code>MIT OR Apache-2.0</code> 雙授權條款作為它們專案的授權方式，這和 Rust 的授權條款一樣。這也剛好展示你也可以用 <code>OR</code> 指定數個授權條款，讓你的專案擁有數個不同的授權方式。</p>
<p>有了獨特名稱、版本、描述與授權條款，已經準備好發佈的 <em>Cargo.toml</em> 檔案會如以下所示：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo 技術文件</a>還介紹了其他你可以指定的詮釋資料，讓你的 crate 更容易被其他人發掘並使用。</p>
<h3 id="發佈至-cratesio"><a class="header" href="#發佈至-cratesio">發佈至 Crates.io</a></h3>
<p>現在你已經建立了帳號、儲存了 API token、選擇了 crate 的獨特名稱並指定了所需的詮釋資料，你現在已經準備好發佈了！發佈 crate 會上傳一個指定版本到 <a href="https://crates.io/">crates.io</a><!-- ignore --> 供其他人使用。</p>
<p>發佈 crate 時請格外小心，因為發佈是會<strong>永遠</strong>存在的。該版本無法被覆寫，而且程式碼無法被刪除。<a href="https://crates.io/">crates.io</a><!-- ignore --> 其中一個主要目標就是要作為儲存程式碼的永久伺服器，讓所有依賴 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的 crate 的專案可以持續正常運作。允許刪除版本會讓此目標幾乎無法達成。不過你能發佈的 crate 版本不會有數量限制。</p>
<p>再次執行 <code>cargo publish</code> 命令，這次就應該會成功了：</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>恭喜！你現在將你的程式碼分享給 Rust 社群了，任何人現在都可以輕鬆將你的 crate 加到他們的專案中作為依賴了。</p>
<h3 id="對現有-crate-發佈新版本"><a class="header" href="#對現有-crate-發佈新版本">對現有 Crate 發佈新版本</a></h3>
<p>當你對你的 crate 做了一些改變並準備好發佈新版本時，你可以變更 <em>Cargo.toml</em> 中的 <code>version</code> 數值，並再發佈一次。請使用<a href="https://semver.org/lang/zh-TW/">語意化版本規則</a>依據你作出的改變來決定下一個妥當的版本數字。接著執行 <code>cargo publish</code> 來上傳新版本。</p>
<h3 id="透過-cargo-yank-棄用-cratesio-的版本"><a class="header" href="#透過-cargo-yank-棄用-cratesio-的版本">透過 <code>cargo yank</code> 棄用 Crates.io 的版本</a></h3>
<p>雖然你無法刪除 crate 之前的版本，你還是可以防止任何未來的專案加入它們作為依賴。這在 crate 版本因某些原因而被破壞時會很有用。在這樣的情況下，Cargo 支援<strong>撤回（yanking）</strong> crate 版本。</p>
<p>撤回一個版本能防止新專案用該版本作為依賴，同時允許現存依賴它的專案能夠繼續依賴該版本。實際上，撤回代表所有專案的 <em>Cargo.lock</em> 都不會被破壞，且任何未來產生的 <em>Cargo.lock</em> 檔案不會使用被撤回的版本。</p>
<p>要撤回一個 crate 的版本，在你先前發布的 crate 目錄底下執行 <code>cargo yank</code> 並指定你想撤回的版本。舉例來說，如果我們發布了一個 <code>guessing_game</code> crate 的版本 1.0.1，然讓我們想撤回的話，我們可以在 <code>guessing_game</code> 專案目錄底下執行：</p>
<!-- manual-regeneration:
want to yank:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->
<pre><code class="language-console">$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>而對命令加上 <code>--undo</code> 的話，你還可以在復原撤回的動作，允許其他專案可以再次依賴該版本：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
        Yank guessing_game@1.0.1
</code></pre>
<p>撤回<strong>並不會</strong>刪除任何程式碼。舉例來說，它並不會刪除任何不小心上傳的祕密訊息。如果真的出現這種情形，你必須立即重設那些資訊。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cargo-工作空間"><a class="header" href="#cargo-工作空間">Cargo 工作空間</a></h2>
<p>在第十二章中，我們建立的套件包含一個執行檔 crate 與一個函式庫 crate。隨著專案開發，你可能會發現函式庫 crate 變得越來越大，而你可能會想要將套件拆成數個函式庫 crate。Cargo 提供了一個功能叫做<strong>工作空間</strong>（workspaces）能來幫助管理並開發數個相關的套件。</p>
<h3 id="建立工作空間"><a class="header" href="#建立工作空間">建立工作空間</a></h3>
<p><strong>工作空間</strong>是一系列的共享相同 <em>Cargo.lock</em> 與輸出目錄的套件。讓我們建立個使用工作空間的專案，我們會使用簡單的程式碼，好讓我們能專注在工作空間的架構上。組織工作空間的架構有很多種方式，我們會介紹其中一種常見的方式。我們的工作空間將會包含一個執行檔與兩個函式庫。執行檔會提供主要功能，並依賴其他兩個函式庫。其中一個函式庫會提供函式 <code>add_one</code>，而另一個函式庫會提供函式 <code>add_two</code>。這三個 crate 會包含在相同的工作空間中，我們先從建立工作空間的目錄開始：</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>接著在 <em>add</em> 目錄中，我們建立會設置整個工作空間的 <em>Cargo.toml</em> 檔案。此檔案不會有 <code>[package]</code> 段落。反之，他會使用一個 <code>[workspace]</code> 段落作為起始，讓我們可以透過指定執行檔 crate 的套件路徑來將它加到工作空間的成員中。在此例中，我們的路徑是 <em>adder</em>：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>接下來我們會在 <em>add</em> 目錄下執行 <code>cargo new</code> 來建立 <code>adder</code> 執行檔 crate：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>在這個階段，我們已經可以執行 <code>cargo build</code> 來建構工作空間。目錄 <em>add</em> 底下的檔案應該會看起來像這樣：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>工作空間在頂層有一個 <em>target</em> 目錄用來儲存編譯結果。<code>adder</code> 套件不會有自己的 <em>target</em> 目錄。就算我們在 <em>adder</em> 目錄底下執行 <code>cargo build</code>，編譯結果仍然會在 <em>add/target</em> 底下而非 <em>add/adder/target</em>。Cargo 之所以這樣組織工作空間的 <em>target</em> 目錄是因為工作空間的 crate 是會彼此互相依賴的。如果每個 crate 都有自己的 <em>target</em> 目錄，每個 crate 就得重新編譯工作空間中的其他每個 crate 才能將編譯結果放入它們自己的 <em>target</em> 目錄。共享 <em>target</em> 目錄的話，crate 可以避免不必要的重新建構。</p>
<h3 id="在工作空間中建立第二個套件"><a class="header" href="#在工作空間中建立第二個套件">在工作空間中建立第二個套件</a></h3>
<p>接下來讓我們在工作空間中建立另一個套件成員 <code>add_one</code>。請修改頂層 <em>Cargo.toml</em> 來指定 <em>add_one</em> 的路徑到 <code>members</code> 列表中：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add_one&quot;,
]
</code></pre>
<p>然後產生新的函式庫 crate <code>add_one</code>：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add_one/add
rm -rf add_one
cargo new add_one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add_one --lib
     Created library `add_one` package
</code></pre>
<p><em>add</em> 目錄現在應該要擁有這些目錄與檔案：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add_one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>在 <em>add_one/src/lib.rs</em> 檔案中，讓我們加上一個函式 <code>add_one</code>：</p>
<p><span class="filename">檔案名稱：add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>現在我們可以讓我們 <code>adder</code> 套件的執行檔依賴擁有函式庫的 <code>add_one</code> 套件。首先，我們需要將 <code>add_one</code> 的路徑依賴加到 <em>adder/Cargo.toml</em>。</p>
<p><span class="filename">檔案名稱：adder/Cargo.toml</span></p>
<pre><code class="language-toml">
add_one = { path = &quot;../add_one&quot; }
</code></pre>
<p>Cargo 不會假設工作空間下的 crate 會彼此依賴，我們我們要指定彼此之間依賴的關係。</p>
<p>接著讓我們在 <code>adder</code> 內使用 <code>add_one</code> crate 的 <code>add_one</code> 函式。開啟 <em>adder/src/main.rs</em> 檔案並在最上方加上 <code>use</code> 來將 <code>add_one</code> 函式庫引入作用域。然後變更 <code>main</code> 函式來呼叫 <code>add_one</code> 函式，如範例 14-7 所示。</p>
<p><span class="filename">檔案名稱：adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;你好，世界！{num} 加一會是 {}！&quot;, add_one::add_one(num);
    );
}
</code></pre>
<p><span class="caption">範例 14-7：在 <code>adder</code> crate 中使 <code>add_one</code> 函式庫 crate</span></p>
<p>讓我們在頂層的 <em>add</em> 目錄執行 <code>cargo build</code> 來建構工作空間吧！</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>要執行 <em>add</em> 目錄的執行檔 crate，我們可以透過 <code>-p</code> 加上套件名稱使用 <code>cargo run</code> 來執行我們想要在工作空間中指定的套件：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
你好，世界！10 加一會是 11！
</code></pre>
<p>這就會執行 <em>adder/src/main.rs</em> 的程式碼，其依賴於 <code>add_one</code> crate。</p>
<h4 id="在工作空間中依賴外部套件"><a class="header" href="#在工作空間中依賴外部套件">在工作空間中依賴外部套件</a></h4>
<p>注意到工作空間只有在頂層有一個 <em>Cargo.lock</em> 檔案，而不是在每個 crate 目錄都有一個 <em>Cargo.lock</em>。這確保所有的 crate 都對所有的依賴使用相同的版本。如果我們加了 <code>rand</code> 套件到 <em>adder/Cargo.toml</em> 與 <em>add_one/Cargo.toml</em> 檔案中，Cargo 會將兩者的版本解析為同一個 <code>rand</code> 版本並記錄到同個 <em>Cargo.lock</em> 中。確保工作空間所有 crate 都會使用相同依賴代表工作空間中的 crate 永遠都彼此相容。讓我們將 <code>rand</code> crate 加到 <em>add_one/Cargo.toml</em> 檔案的 <code>[dependencies]</code> 段落中，使 <code>add_one</code> crate 可以使用 <code>rand</code> crate：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">檔案名稱：add_one/Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.5&quot;
</code></pre>
<p>我們現在就可以將 <code>use rand;</code> 加到 <em>add_one/src/lib.rs</em> 檔案中，接著在 <em>add</em> 目錄下執行 <code>cargo build</code> 來建構整個工作空間就會引入並編譯 <code>rand</code> crate。我們會得到一個警告，因爲我們還沒有開始使用引入作用域的 <code>rand</code>：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.5
   --省略--
   Compiling rand v0.8.5
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
warning: unused import: `rand`
 --&gt; add_one/src/lib.rs:1:5
  |
1 | use rand;
  |     ^^^^
  |
  = note: `#[warn(unused_imports)]` on by default
warning: `add_one` (lib) generated 1 warning
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>頂層的 <em>Cargo.lock</em> 現在就包含 <code>add_one</code> 有 <code>rand</code> 作為依賴的資訊。不過就算我們能在工作空間的某處使用 <code>rand</code>，並不代表我們可以在工作空間的其他 crate 中使用它，除非它們的 <em>Cargo.toml</em> 也加上了 <code>rand</code>。舉例來說，如果我們將 <code>use rand;</code> 加到 <em>adder/src/main.rs</em> 檔案中想讓 <code>adder</code> 套件也使用的話，我們就會得到錯誤：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --省略--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no external crate `rand`
</code></pre>
<p>要修正此問題，只要修改 <code>adder</code> 套件的 <em>Cargo.toml</em> 檔案，指示它也加入 <code>rand</code> 作為依賴就好了。這樣建構 <code>adder</code> 套件就會將在 <em>Cargo.lock</em> 中將 <code>rand</code> 加入 <code>adder</code> 的依賴，但是沒有額外的 <code>rand</code> 會被下載。Cargo 會確保工作空間中每個套件的每個 crate 都會使用相同的 <code>rand</code> 套件版本。這可以節省空間，並能確保工作空間中的 crate 彼此可以互相兼容。</p>
<h4 id="在工作空間中新增測試"><a class="header" href="#在工作空間中新增測試">在工作空間中新增測試</a></h4>
<p>讓我們再進一步加入一個測試函式 <code>add_one::add_one</code> 到 <code>add_one</code> crate 之中：</p>
<p><span class="filename">檔案名稱：add_one/src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
</code></pre>
<p>現在在頂層的 <em>add</em> 目錄執行 <code>cargo test</code>。像這樣在工作空間的架構下執行 <code>cargo test</code> 會執行工作空間下所有 crate 的測試：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add_one v0.1.0 (file:///projects/add/add_one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>輸出的第一個段落顯示了 <code>add_one</code> crate 中的 <code>it_works</code> 測試通過。下一個段落顯示 <code>adder</code> crate 沒有任何測試，然後最後一個段落顯示 <code>add_one</code> 中沒有任何技術文件測試。</p>
<p>我們也可以在頂層目錄使用 <code>-p</code> 並指定我們想測試的 crate 名稱來測試工作空間中特定的 crate：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add_one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add_one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests add_one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>此輸出顯示 <code>cargo test</code> 只執行了 <code>add_one</code> crate 的測試並沒有執行 <code>adder</code> crate 的測試。</p>
<p>如果你想要發佈工作空間的 crate 到 <a href="https://crates.io/">crates.io</a>，工作空間中的每個 crate 必須分別獨自發佈。和 <code>cargo test</code> 一樣，我們可以用 <code>-p</code> 的選項來指定想要的 crate 名稱，來發布工作空間內的特定 crate。</p>
<p>之後想嘗試練習的話，你可以在工作空間中在加上 <code>add_two</code> crate，方式和 <code>add_one</code> crate 類似！</p>
<p>隨著你的專案成長，你可以考慮使用工作空間：拆成各個小部分比一整塊大程式還更容易閱讀。再者，如果需要經常同時修改的話，將 crate 放在同個工作空間中更易於彼此的協作。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過-cargo-install-安裝執行檔"><a class="header" href="#透過-cargo-install-安裝執行檔">透過 <code>cargo install</code> 安裝執行檔</a></h2>
<p><code>cargo install</code> 命令讓你能本地安裝並使用執行檔 crates。這並不是打算要取代系統套件，這是為了方便讓 Rust 開發者可以安裝 <a href="https://crates.io/">crates.io</a><!-- ignore --> 上分享的工具。注意你只能安裝有執行檔目標的套件。<strong>執行檔目標</strong>（binary target）是在 crate 有 <em>src/main.rs</em> 檔案或其他指定的執行檔時，所建立的可執行程式。而相反地，函式庫目標就無法單獨執行，因為它提供給其他程式使用的函式庫。通常 crate 都會提供 <em>README</em> 檔案說明此 crate 是函式庫還是執行檔目標，或者兩者都是。</p>
<p>所有透過 <code>cargo install</code> 安裝的執行檔都儲存在安裝根目錄的 <em>bin</em> 資料夾中。如果你是用 <em>rustup.rs</em>  安裝 Rust 且沒有任何自訂設置的話，此目錄會是 <em>$HOME/.cargo/bin</em>。請確定該目錄有在你的 <code>$PATH</code> 中，這樣才能夠執行 <code>cargo install</code> 安裝的程式。</p>
<p>舉例來說，第十二章我們提到有個 Rust 版本的 <code>grep</code> 工具叫做 <code>ripgrep</code> 能用來搜尋檔案。要安裝 <code>ripgrep</code> 的話，我們可以執行以下命令：</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v13.0.0
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v13.0.0
--省略--
   Compiling ripgrep v13.0.0
    Finished release [optimized + debuginfo] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
</code></pre>
<p>輸出的最後兩行顯示了執行檔的安裝位置與名稱，在 <code>ripgrep</code> 此例中就是 <code>rg</code>。如稍早提到的，只要你的 <code>$PATH</code> 有包含安裝目錄，你就可以執行 <code>rg --help</code> 並開始使用更快更鏽的搜尋檔案工具！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過自訂命令來擴展-cargo-的功能"><a class="header" href="#透過自訂命令來擴展-cargo-的功能">透過自訂命令來擴展 Cargo 的功能</a></h2>
<p>Cargo 的設計能讓你在不用修改 Cargo 的情況下擴展新的子命令。如果你 <code>$PATH</code> 中有任何叫做 <code>cargo-something</code> 的執行檔，你就可以用像是執行 Cargo 子命令的方式 <code>cargo something</code> 來執行它。像這樣的自訂命令在你執行 <code>cargo --list</code> 時也會顯示出來。能夠透過 <code>cargo install</code> 來安裝擴展外掛並有如內建 Cargo 工具般來執行使用是 Cargo 設計上的一大方便優勢！</p>
<h2 id="總結-13"><a class="header" href="#總結-13">總結</a></h2>
<p>透過 Cargo 與 <a href="https://crates.io/">crates.io</a><!-- ignore --> 分享程式碼是讓 Rust 生態系統能適用於許多不同任務的重要部分之一。Rust 的標準函式庫既小又穩定，但是 crate 可以很容易地分享、使用，並在語言本身不同的時間線來進行改善。千萬別吝嗇於分享你認為實用的程式碼到 <a href="https://crates.io/">crates.io</a><!-- ignore -->，其他人可能也會覺得它很有幫助！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智慧指標"><a class="header" href="#智慧指標">智慧指標</a></h1>
<p><strong>指標</strong>（pointer）是一個將變數儲存記憶體位址的通用概念。此位址參考或者說是「指向」一些其他資料。Rust 中最常見的指標種類就是第四章介紹的參考（reference）。參考以 <code>&amp;</code> 符號作為指示並借用它們指向的數值。它們除了參考資料以外，沒有其他的特殊能力，也沒有任何額外開銷。</p>
<p>另一方面，<strong>智慧指標</strong>（Smart pointers）是個不只會有像是指標的行為，還會包含擁有的詮釋資料與能力。智慧指標的概念並不是 Rust 獨有的，智慧指標起源於 C++ 且也都存在於其他語言。Rust 在標準函式庫中有提供許多不同的智慧指標，不只能參考還具備更多的功能。為了探索各個概念，我們會來研究一些各種不同的智慧指標範例，包含<strong>參考計數</strong>（reference counting）智慧指標型別。此指標允許一個資料可以有多個擁有者，並追蹤擁有者的數量，當沒有任何擁有者時，就清除資料。</p>
<p>在 Rust 中，我們有所有權與借用的概念，所以參考與智慧指標之間還有一項差別：參考是只有借用資料的指標，但智慧指標在很多時候都<strong>擁有</strong>它們指向的資料。</p>
<p>雖然在前面的章節我們沒有這樣稱呼，但我們已經在本書中遇過一些智慧指標了，像是第八章的 <code>String</code> 和 <code>Vec&lt;T&gt;</code>，雖然當時我們沒有稱呼它們為智慧指標。這些型別都算是智慧指標，因為它們都擁有一些記憶體並允許你操控它們。它們也有詮釋資料以及額外的能力或保障。像是 <code>String</code> 就會將容量儲存在詮釋資料中，並確保其資料永遠是有效的 UTF-8。</p>
<p>智慧指標通常都使用結構體實作。和一般結構體不同，智慧指標會實作 <code>Deref</code> 與 <code>Drop</code> 特徵。<code>Deref</code> 特徵允許智慧指標結構體的實例表現的像是參考一樣，讓你可以寫出能用在參考與智慧指標的程式碼。<code>Drop</code> 特徵允許你自訂當智慧指標實例離開作用域時要執行的程式碼。在本章節我們會討論這兩個特徵並解釋為何它們對智慧指標很重要。</p>
<p>有鑑於智慧指標在 Rust 是個常用的通用設計模式，本章不會涵蓋每一個現有的智慧指標。許多函式庫也都會提供它們自己的智慧指標，你甚至能寫個你自己的。我們會提及標準函式庫中最常用到的智慧指標：</p>
<ul>
<li><code>Box&lt;T&gt;</code> 將數值分配到堆積上</li>
<li><code>Rc&lt;T&gt;</code>, 參考計數型別來允許資料能有數個擁有者</li>
<li>透過 <code>RefCell&lt;T&gt;</code> 來存取 <code>Ref&lt;T&gt;</code> 與 <code>RefMut&lt;T&gt;</code> ，這是在執行時而非編譯時強制執行借用規則的型別</li>
</ul>
<p>除此之外，我們還會涵蓋到<strong>內部可變性</strong>（interior mutability）模式，這讓不可變參考的型別能提供改變內部數值的 API。我們還會討論<strong>參考循環</strong>（reference cycles）為何會導致記憶體泄漏以及如何預防它們。</p>
<p>讓我們開始吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-boxt-指向堆積上的資料"><a class="header" href="#使用-boxt-指向堆積上的資料">使用 <code>Box&lt;T&gt;</code> 指向堆積上的資料</a></h2>
<p>最直白的智慧指標是 <em>box</em> 其型別為 <code>Box&lt;T&gt;</code>。Box 允許你儲存資料到堆積上，而不是堆疊。留在堆疊上的會是指向堆積資料的指標。你可以回顧第四章瞭解堆疊與堆積的差別。</p>
<p>Box 沒有額外的效能開銷，就只是將它們的資料儲存在堆積上而非堆疊而已。不過相對地它們也沒有多少額外功能。你大概會在這些場合用到它們：</p>
<ul>
<li>當你有個型別無法在編譯時期確定大小，而你又想在需要知道確切大小的情況下使用該型別的數值。</li>
<li>當你有個龐大的資料，而你想要轉移所有權並確保資料不會被拷貝。</li>
<li>當你想要擁有某個值，但你只在意該型別有實作特定的特徵，而不是何種特定型別。</li>
</ul>
<p>我們會在<a href="ch15-01-box.html#%E9%80%8F%E9%81%8E-box-%E5%BB%BA%E7%AB%8B%E9%81%9E%E8%BF%B4%E5%9E%8B%E5%88%A5">「透過 Box 建立遞迴型別」</a><!-- ignore -->段落解說第一種情形。而在第二種情形，轉移龐大的資料的所有權可能會很花費時間，因為在堆疊上的話會拷貝所有資料。要改善此情形，我們可以用 box 將龐大的資料儲存在堆積上。這樣就只有少量的指標資料在堆疊上被拷貝，而其參考的資料仍然保留在堆積上的同個位置。第三種情況被稱之為<strong>特徵物件（trait object）</strong>，第十七章會花整個<a href="ch17-02-trait-objects.html">「允許不同型別數值的特徵物件」</a><!-- ignore -->段落來討論此議題。所以你在此學到的到第十七章會再次用上！</p>
<h3 id="使用-boxt-儲存資料到堆積上"><a class="header" href="#使用-boxt-儲存資料到堆積上">使用 <code>Box&lt;T&gt;</code> 儲存資料到堆積上</a></h3>
<p>在我們討論 <code>Box&lt;T&gt;</code> 在堆積儲存空間上的使用場合前，我們會先介紹語法以及如何對 <code>Box&lt;T&gt;</code> 內儲存的數值進行互動。</p>
<p>範例 15-1 顯示如何使用 box 在堆積上儲存一個 <code>i32</code> 數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">範例 15-1：使用 box 在堆積上儲存一個 <code>i32</code> 數值</span></p>
<p>我們定義了變數 <code>b</code> 其數值為 <code>Box</code> 分配在堆積上指向的數值 <code>5</code>。程式在此例會印出 <code>b = 5</code>，在此例中我們可以用在堆疊上相同的方式取得 box 的資料。就像任何有所有權的數值一樣，當 box 離開作用域時會釋放記憶體，在此例就是當 <code>b</code> 抵達 <code>main</code> 結尾的時候。釋放記憶體作用於 box（儲存在堆疊上）以及其所指向的資料（儲存在堆積上）。</p>
<p>將單一數值放在堆積上的確沒什麼用處，所以你不會對這種類型經常使用 box。在大多數情況下將像 <code>i32</code> 這種單一數值預設儲存在堆疊的確比較適合。</p>
<h3 id="透過-box-建立遞迴型別"><a class="header" href="#透過-box-建立遞迴型別">透過 Box 建立遞迴型別</a></h3>
<p><strong>遞迴型別</strong>（recursive type）的數值可以用相同型別的其他數值作為自己的一部分。遞迴型別對 Rust 來說會造成問題，因為 Rust 得在編譯期間時知道型別佔用的空間。由於這種巢狀數值理論上可以無限循環下去，Rust 無法知道一個遞迴型別的數值需要多大的空間。然而 box 則有已知大小，所以將 box 填入遞迴型別定義中，你就可以有遞迴型別了。</p>
<p>讓我們來探索 <em>cons list</em> 來作為遞迴型別的範例。這是個在函式程式語言中常見的資料型別，很適合作為遞迴型別的範例。我們要定義的 cons list 型別除了遞迴的部分以外都很直白，因此這個例子的概念在往後你遇到更複雜的遞迴型別時會很實用。</p>
<h4 id="更多關於-cons-list-的資訊"><a class="header" href="#更多關於-cons-list-的資訊">更多關於 Cons List 的資訊</a></h4>
<p><em>cons list</em> 是個起源於 Lisp 程式設計語言與其方言的資料結構，用巢狀配對組成，相當於 Lisp 版的鏈結串列（linked list）。這名字來自於 Lisp 中的 <code>cons</code> 函式（「construct function」的縮寫），它會從兩個引數建構一個新的配對，而這通常包含一個數值與另一個配對。對其呼叫 <code>cons</code> 就我們能建構出擁有遞迴配對的 cons list。</p>
<p>舉例來說，以下是個 cons list 的範例，包含了用括號包起來的 1、2、3 列表配對：</p>
<pre><code class="language-text">(1, (2, (3, Nil)))
</code></pre>
<p>每個 cons list 的項目都包含兩個元素：目前項目的數值與下一個項目。列表中的最後一個項目只會包含一個數值叫做 <code>Nil</code>，並不會再連接下一個項目。cons list 透過遞迴呼叫 <code>cons</code> 函式來產生。表示遞迴終止條件的名稱為 <code>Nil</code>。注意這和第六章提到的「null」或「nil」的概念不全然相同，這些代表的是無效或空缺的數值。</p>
<p>在 Rust 中 cons lists 不是常見的資料結構。大多數當你在 Rust 需要項目列表時，<code>Vec&lt;T&gt;</code> 會是比較好的選擇。而其他時候夠複雜的遞迴資料型別<strong>確實</strong>在各種特殊情形會很實用，不過先從 cons list 開始的話，我們可以專注探討 box 如何讓我們定義遞迴資料型別。</p>
<p>範例 15-2 包含了 cons list 的枚舉定義。注意到此程式碼還不能編譯過，因為 <code>List</code> 型別並沒有已知的大小，我們接下來會繼續說明。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 15-2：第一次嘗試定義一個枚舉來代表有 <code>i32</code> 數值的 cons list 資料結構</span></p>
<blockquote>
<p>注意：我們定義的 cons list 只有 <code>i32</code> 數值是為了範例考量。我們當然可以使用第十章討論過的泛型來定義它，讓 cons list 定義的型別可以儲存任何型別數值。</p>
</blockquote>
<p>使用 <code>List</code> 型別來儲存 <code>1, 2, 3</code> 列表的話會如範例 15-3 的程式碼所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">範例 15-3：使用 <code>List</code> 枚舉儲存列表 <code>1, 2, 3</code></span></p>
<p>第一個 <code>Cons</code> 值會得到 <code>1</code> 與另一個 <code>List</code> 數值。此 <code>List</code> 數值是另一個 <code>Cons</code> 數值且持有 <code>2</code> 與另一個 <code>List</code> 數值。此 <code>List</code> 數值是另一個 <code>Cons</code> 數值且擁有 <code>3</code> 與一個 <code>List</code> 數值，其就是最後的 <code>Nil</code>，這是傳遞列表結尾訊號的非遞迴變體。</p>
<p>如果我們嘗試編譯範例 15-3 的程式碼，我們會得到範例 15-4 的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

For more information about this error, try `rustc --explain E0072`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><span class="caption">範例 15-4：嘗試定義遞迴枚舉所得到的錯誤</span></p>
<p>錯誤顯示此型別的「大小為無限」，原因是因為我們定義的 <code>List</code> 有個變體是遞迴：它直接存有另一個相同類型的數值。所以 Rust 無法判別出它需要多少空間才能儲存一個 <code>List</code> 的數值。讓我進一步研究為何我們會得到這樣的錯誤，首先來看 Rust 如何決定要分配多少空間來儲存非遞迴型別。</p>
<h4 id="計算非遞迴型別的大小"><a class="header" href="#計算非遞迴型別的大小">計算非遞迴型別的大小</a></h4>
<p>回想一下第六章中，當我們在討論枚舉定義時，我們在範例 6-2 定義的 <code>Message</code> 枚舉：</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>要決定一個 <code>Message</code> 數值需要分配多少空間，Rust 會遍歷每個變體來看哪個變體需要最大的空間。Rust 會看到 <code>Message::Quit</code> 不佔任何空間、<code>Message::Move</code> 需要能夠儲存兩個 <code>i32</code> 的空間，以此類推。因為只有一個變體會被使用，一個 <code>Message</code> 數值所需的最大空間就是其最大變體的大小。</p>
<p>將此對應到當 Rust 嘗試檢查像是範例 15-2 的 <code>List</code> 枚舉來決定遞迴型別需要多少空間時，究竟會發生什麼事。編譯器先從查看 <code>Cons</code> 的變體開始，其存有一個 <code>i32</code> 型別與一個 <code>List</code> 型別。因此 <code>Cons</code> 需要的空間大小為 <code>i32</code> 的大小加上 <code>List</code> 的大小。為了要瞭解 <code>List</code> 型別需要的多少記憶體，編譯器在進一步看它的變體，也是從 <code>Cons</code> 變體開始。<code>Cons</code> 變體存有一個型別 <code>i32</code> 與一個型別 <code>List</code>，而這樣的過程就無限處理下去，如圖示 15-1 所示。</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 15-1：無限個 <code>List</code> 包含著無限個 <code>Cons</code> 變體</span></p>
<h4 id="使用-boxt-取得已知大小的遞迴型別"><a class="header" href="#使用-boxt-取得已知大小的遞迴型別">使用 <code>Box&lt;T&gt;</code> 取得已知大小的遞迴型別</a></h4>
<p>由於 Rust 無法判別出遞迴定義型別要分配多少空間，所以編譯器會針對此錯誤提供些實用的建議：</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable
  |
2 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +
</code></pre>
<p>在此建議中，「indirection」代表與其直接儲存數值，我們可以變更資料結構，間接儲存指向數值的指標。</p>
<p>因為 <code>Box&lt;T&gt;</code> 是個指標，Rust 永遠知道 <code>Box&lt;T&gt;</code> 需要多少空間：指標的大小不會隨著指向的資料數量而改變。這代表我們可以將 <code>Box&lt;T&gt;</code> 存入 <code>Cons</code> 變體而非直接儲存另一個 <code>List</code> 數值。<code>Box&lt;T&gt;</code> 會指向另一個存在於堆積上的 <code>List</code> 數值而不是存在 <code>Cons</code> 變體中。概念上我們仍然有建立一個持有其他列表的列表，但此實作更像是將項目接著另一個項目排列，而非包含另一個在內。</p>
<p>我們可以改變範例 15-2 的 <code>List</code> 枚舉定義以及範例 15-3 <code>List</code> 的使用方式，將其寫入範例 15-5，這次就能夠編譯過了：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">範例 15-5：使用 <code>Box&lt;T&gt;</code> 定義的 <code>List</code> 就有已知大小</span></p>
<p><code>Cons</code> 變體需要的大小為 <code>i32</code> 加上儲存 box 指標的空間。<code>Nil</code> 變體沒有儲存任何數值，所以它需要的空間比 <code>Cons</code> 變體少。現在我們知道任何 <code>List</code> 數值會佔的空間都是一個 <code>i32</code> 加上 box 指標的大小。透過使用 box，我們打破了無限遞迴，所以編譯器可以知道儲存一個 <code>List</code> 數值所需要的大小。圖示 15-2 顯示了 <code>Cons</code> 變體看起來的樣子。</p>
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">圖示 15-2：不再是無限大小的 <code>List</code>，因為其 <code>Cons</code> 存的是 <code>Box</code></span></p>
<p>Boxes 只提供了間接儲存與堆積分配，它們沒有其他任何特殊功能，比如我們等下就會看到的其他智慧指標型別。它們也沒有任何因這些特殊功能產生的額外效能開銷，所以它們很適合用於像是 cons list 這種我們只需要間接儲存的場合。我們在第十七章還會再介紹到更多 box 的使用情境。</p>
<p><code>Box&lt;T&gt;</code> 型別是智慧指標是因為它有實作 <code>Deref</code> 特徵，讓 <code>Box&lt;T&gt;</code> 的數值可以被視為參考所使用。當 <code>Box&lt;T&gt;</code> 數值離開作用域時，該 box 指向的堆積資料也會被清除，因為其有 <code>Drop</code> 特徵實作。這兩種特徵對於本章將會討論的其他智慧指標型別所提供的功能，將會更加重要。讓我們來探討這兩種特徵的細節吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過-deref-特徵將智慧指標視為一般參考"><a class="header" href="#透過-deref-特徵將智慧指標視為一般參考">透過 <code>Deref</code> 特徵將智慧指標視為一般參考</a></h2>
<p>實作 <code>Deref</code> 特徵讓你可以自訂<strong>解參考運算子（dereference operator）</strong> <code>*</code> 的行為（這不是相乘或全域運算子）。透過這種方式實作 <code>Deref</code> 的智慧指標可以被視為正常參考來對待，這樣操作參考的程式碼也能用在智慧指標中。</p>
<p>讓我們先看解參考運算子如何在正常參考中使用。然後我們會嘗試定義一個行為類似 <code>Box&lt;T&gt;</code> 的自定型別，並看看為何解參考運算子無法像參考那樣用在我們新定義的型別。我們將會探討如何實作 <code>Deref</code> 特徵使智慧指標能像類似參考的方式運作。接著我們會看看 Rust 的**強制解參考（deref coercion）**功能並瞭解它如何處理參考與智慧指標。</p>
<blockquote>
<p>注意：我們即將定義的 <code>MyBox&lt;T&gt;</code> 型別與真正的 <code>Box&lt;T&gt;</code> 有一項很大的差別，就是我們的版本不會將其資料儲存在堆積上。我們在此例會專注在 <code>Deref</code> 上，所以資料實際上儲存在何處，並沒有比指標相關行為來得重要。</p>
</blockquote>
<h3 id="追蹤指標的數值"><a class="header" href="#追蹤指標的數值">追蹤指標的數值</a></h3>
<p>一般的參考是一種指標，其中一種理解指標的方式是看成一個會指向存於某處數值的箭頭。在範例 15-6 中我們建立了數值 <code>i32</code> 的參考，接著使用解參考運算子來追蹤參考的數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">範例 15-6：使用解參考運算子來追蹤數值 <code>i32</code> 的參考</span></p>
<p>變數 <code>x</code> 存有 <code>i32</code> 數值 <code>5</code>。我們將 <code>y</code> 設置為 <code>x</code> 的參考。我們可以判定 <code>x</code> 等於 <code>5</code>。不過要是我們想要判定 <code>y</code> 數值的話，我們需要使用 <code>*y</code> 來追蹤參考指向的數值（也就是<strong>解參考</strong>），這樣編譯器才能比較實際數值。一旦我們解參考 <code>y</code>，我們就能取得 <code>y</code> 指向的整數數值並拿來與 <code>5</code> 做比較。</p>
<p>如果我們嘗試寫說 <code>assert_eq!(5, y);</code> 的話，我們會得到此編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
  = help: the following other types implement trait `PartialEq&lt;Rhs&gt;`:
            f32
            f64
            i128
            i16
            i32
            i64
            i8
            isize
          and 6 others

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>比較一個數字與一個數字的參考是不允許的，因為它們是不同的型別。我們必須使用解參考運算子來追蹤其指向的數值。</p>
<h3 id="像參考般使用-boxt"><a class="header" href="#像參考般使用-boxt">像參考般使用 <code>Box&lt;T&gt;</code></a></h3>
<p>我們將範例 15-6 的參考改用 <code>Box&lt;T&gt;</code> 重寫。範例 15-7 對 <code>Box&lt;T&gt;</code> 使用解參考運算子的方式如就和範例 15-6 對參考使用解參考運算子的方式一樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">範例 15-7：對 <code>Box&lt;i32&gt;</code> 使用解參考運算子</span></p>
<p>範例 15-7 與範例 15-6 主要的差別在於這裡我們設置 <code>y</code> 為一個指向 <code>x</code> 的拷貝數值的 <code>Box&lt;T&gt;</code> 實例，而不是指向 <code>x</code> 數值的參考。在最後的判定中，我們可以對 <code>Box&lt;T&gt;</code> 的指標使用解參考運算子，跟我們對當 <code>y</code> 還是參考時所做的動作一樣。接下來，我們要來探討 <code>Box&lt;T&gt;</code> 有何特別之處，讓我們可以對自己定義的型別也可以使用解參考運算子。</p>
<h3 id="定義我們自己的智慧指標"><a class="header" href="#定義我們自己的智慧指標">定義我們自己的智慧指標</a></h3>
<p>讓我們定義一個與標準函式庫所提供的 <code>Box&lt;T&gt;</code> 型別類似的智慧指標，並看看智慧指標預設行為與參考有何不同。然後我們就會來看能夠使用解參考運算子的方式。</p>
<p><code>Box&lt;T&gt;</code> 本質上就是定義成只有一個元素的元組結構體，所以範例 15-8 用相同的方式來定義 <code>MyBox&lt;T&gt;</code>。我們也定義了 <code>new</code> 函式來對應於 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 15-8：定義 <code>MyBox&lt;T&gt;</code> 型別</span></p>
<p>我們定義了一個結構體叫做 <code>MyBox</code> 並宣告一個泛型參數 <code>T</code>，因為我們希望我們的型別能存有任何型別的數值。<code>MyBox</code> 是個只有一個元素型別為 <code>T</code> 的元組結構體。<code>MyBox::new</code> 函式接受一個參數型別為 <code>T</code> 並回傳存有該數值的 <code>MyBox</code> 實例。</p>
<p>讓我們將範例 15-7 的 <code>main</code> 函式加到範例 15-8 並改成使用我們定義的 <code>MyBox&lt;T&gt;</code> 型別而不是原本的 <code>Box&lt;T&gt;</code>。範例 15-9 的程式碼無法編譯，因為 Rust 不知道如何解參考<code>MyBox</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">範例 15-9：嘗試像使用 <code>Box&lt;T&gt;</code> 和參考一樣的方式來使用 <code>MyBox&lt;T&gt;</code></span></p>
<p>以下是編譯結果出現的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example` due to previous error
</code></pre>
<p>我們的 <code>MyBox&lt;T&gt;</code> 型別無法解參考因為我們還沒有對我們的型別實作該能力。要透過 <code>*</code> 運算子來解參考的話，我們要實作 <code>Deref</code> 特徵。</p>
<h3 id="透過實作-deref-特徵來將一個型別能像參考般對待"><a class="header" href="#透過實作-deref-特徵來將一個型別能像參考般對待">透過實作 <code>Deref</code> 特徵來將一個型別能像參考般對待</a></h3>
<p>如同第十章的<a href="ch10-02-traits.html#%E7%82%BA%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E7%89%B9%E5%BE%B5">「為型別實作特徵」</a><!-- ignore-->段落所講過的，要實作一個特徵的話，我們需要提供該特徵要求的方法實作。標準函式庫所提供的 <code>Deref</code> 特徵要求我們實作一個方法叫做 <code>deref</code>，這會借用 <code>self</code> 並回傳內部資料的參考。範例 15-10 包含了對 <code>MyBox</code> 定義加上的 <code>Deref</code> 實作：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 15-10：對 <code>MyBox&lt;T&gt;</code> 實作 <code>Deref</code></span></p>
<p><code>type Target = T;</code> 語法定義了一個供 <code>Deref</code> 特徵使用的關聯型別。關聯型別與宣告泛型參數會有一點差別，但是你現在先不用擔心它們，我們會在第十九章深入探討。</p>
<p>我們對 <code>deref</code> 的方法本體加上 <code>&amp;self.0</code>，<code>deref</code> 就可以回傳一個參考讓我們可以使用 <code>*</code> 運算子取得數值。回想一下第五章的<a href="ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%84%A1%E5%90%8D%E7%A8%B1%E6%AC%84%E4%BD%8D%E7%9A%84%E5%85%83%E7%B5%84%E7%B5%90%E6%A7%8B%E9%AB%94%E4%BE%86%E5%BB%BA%E7%AB%8B%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5">「使用無名稱欄位的元組結構體來建立不同型別」</a><!-- ignore -->段落，<code>.0</code> 可以取的元組結構體的第一個數值。範例 15-9 的 <code>main</code> 函式現在對 <code>MyBox&lt;T&gt;</code> 數值的 <code>*</code> 呼叫就可以編譯了，而且判定也會通過！</p>
<p>沒有 <code>Deref</code> 特徵的話，編譯器只能解參考 <code>&amp;</code> 的參考。<code>deref</code> 方法讓編譯器能夠從任何有實作 <code>Deref</code> 的型別呼叫 <code>deref</code> 方法取得 <code>&amp;</code> 參考，而它就可以進一步解參考獲取數值。</p>
<p>當我們在範例 15-9 中輸入 <code>*y</code> 時，Rust 背後實際上是執行此程式碼：</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust 將 <code>*</code> 運算子替換為方法 <code>deref</code> 的呼叫再進行普通的解參考，所以我們不必煩惱何時該或不該呼叫 <code>deref</code> 方法。此 Rust 特性讓我們可以對無論是參考或是有實作 <code>Deref</code> 的型別都能寫出一致的程式碼。</p>
<p><code>deref</code> 方法會回傳一個數值參考，以及括號外要再加上普通解參考的原因，都是因為所有權系統。如果 <code>deref</code> 方法直接回傳數值而非參考數值的話，該數值就會移出 <code>self</code>。我們不希望在此例或是大多數使用解參考運算子的場合下，取走 <code>MyBox&lt;T&gt;</code> 內部數值的所有權。</p>
<p>注意到每次我們在程式碼中使用 <code>*</code> 時，<code>*</code> 運算子被替換成 <code>deref</code> 方法呼叫，然後再呼叫 <code>*</code> 剛好一次。因為 <code>*</code> 運算子不會被無限遞迴替換，我們能剛好取得型別 <code>i32</code> 並符合範例 15-9 <code>assert_eq!</code> 中與 <code>5</code> 的判定。</p>
<h3 id="函式與方法的隱式強制解參考"><a class="header" href="#函式與方法的隱式強制解參考">函式與方法的隱式強制解參考</a></h3>
<p>**強制解參考（Deref coercion）**會將有實作 <code>Deref</code> 特徵的型別參考轉換成其他型別的參考。舉例來說，強制解參考可以轉換 <code>&amp;String</code> 成 <code>&amp;str</code>，因為 <code>String</code> 有實作 <code>Deref</code> 特徵並能用它來回傳 <code>&amp;str</code>。強制解參考是一個 Rust 針對函式或方法的引數的便利設計，且只會用在有實作 <code>Deref</code> 特徵的型別。當我們將某個特定型別數值的參考作為引數傳入一個函式或方法，但該函式或方法所定義的參數卻不相符時，強制解參考就會自動發生，並進行一系列的 <code>deref</code> 方法呼叫，將我們提供的型別轉換成參數所需的型別。</p>
<p>Rust 會加入強制解參考的原因是因為程式設計師在寫函式與方法呼叫時，就不必加上許多顯式參考 <code>&amp;</code> 與解參考 <code>*</code>。強制解參考還讓我們可以寫出能同時用於參考或智慧指標的程式碼。</p>
<p>為了展示強制解參考，讓我們使用範例 15-8 定義的 <code>MyBox&lt;T&gt;</code> 型別以及範例 15-10 所加上的 <code>Deref</code> 實作。範例 15-11 中定義的函式使用字串切片作為參數：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {name}!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 15-11：<code>hello</code> 函式且有參數 <code>name</code> 其型別為 <code>&amp;str</code></span></p>
<p>我們可以使用字串切片作為引數來呼叫函式 <code>hello</code>，比方說 <code>hello(&quot;Rust&quot;);</code>。強制解參考讓我們可以透過 <code>MyBox&lt;String&gt;</code> 型別數值的參考來呼叫 <code>hello</code>，如範例 15-12 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">範例 15-12：利用強制解參考透過 <code>MyBox&lt;String&gt;</code> 數值的參考來呼叫 <code>hello</code></span></p>
<p>我們在此使用 <code>&amp;m</code> 作為引數來呼叫函式 <code>hello</code>，這是 <code>MyBox&lt;String&gt;</code> 數值的參考。因為我們在範例 15-10 有對 <code>MyBox&lt;T&gt;</code> 實作 <code>Deref</code> 特徵，Rust 可以呼叫 <code>deref</code> 將 <code>&amp;MyBox&lt;String&gt;</code> 變成 <code>&amp;String</code>。標準函式庫對 <code>String</code> 也有實作 <code>Deref</code> 並會回傳字串切片，這可以在 <code>Deref</code> 的 API 技術文件中看到。所以 Rust 會再呼叫 <code>deref</code> 一次來將 <code>&amp;String</code> 變成 <code>&amp;str</code>，這樣就符合函式 <code>hello</code> 的定義了。</p>
<p>如果 Rust 沒有實作強制解參考的話，我們就得用範例 15-13 的方式才能辦到範例 15-12 使用型別 <code>&amp;MyBox&lt;String&gt;</code> 的數值來呼叫 <code>hello</code> 的動作。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {name}!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">範例 15-13：如果 Rust 沒有強制解參考，我們就得這樣寫程式碼</span></p>
<p><code>(*m)</code> 會將 <code>MyBox&lt;String&gt;</code> 解參考成 <code>String</code>，然後 <code>&amp;</code> 和 <code>[..]</code> 會從 <code>String</code> 中取得等於整個字串的字串切片，這就符合 <code>hello</code> 的簽名。沒有強制解參考的程式碼就難以閱讀、寫入或是理解，因為有太多的符號參雜其中。強制解參考能讓 Rust 自動幫我們做這些轉換。</p>
<p>當某型別有定義 <code>Deref</code> 特徵時，Rust 會分析該型別並重複使用 <code>Deref::deref</code> 直到能取得與參數型別相符的參考。<code>Deref::deref</code> 需要呼叫的次數會在編譯時期插入，所以使用強制解參考沒有任何的執行時開銷！</p>
<h3 id="強制解參考如何處理可變性"><a class="header" href="#強制解參考如何處理可變性">強制解參考如何處理可變性</a></h3>
<p>類似於你使用 <code>Deref</code> 特徵來覆蓋不可變參考的 <code>*</code> 運算子的方式，你也可以使用 <code>DerefMut</code> 特徵來覆蓋可變參考的 <code>*</code> 運算子。</p>
<p>當 Rust 發現型別與特徵實作符合以下三種情況時，它就會進行強制解參考：</p>
<ul>
<li>從 <code>&amp;T</code> 到 <code>&amp;U</code> 且 <code>T: Deref&lt;Target=U&gt;</code></li>
<li>從 <code>&amp;mut T</code> 到 <code>&amp;mut U</code> 且 <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>從 <code>&amp;mut T</code> 到 <code>&amp;U</code> 且 <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>前兩個除了第二個有實作可變性之外是相同的。第一個情況表示如果你有個 <code>&amp;T</code> 且 <code>T</code> 有實作 <code>Deref</code> 到某個型別 <code>U</code>，你就可以直接得到 <code>&amp;U</code>。第二種情況指的則是對可變參考的強制解參考。</p>
<p>第三種情況比較棘手：Rust 也能強制將可變參考轉為一個不可變參考。但反過來是<strong>不可行</strong>的：不可變參考永遠不可能強制解參考成可變參考。由於借用規則，如果你有個可變參考，該可變參考必須是該資料的唯一參考（不然程式無法編譯）。轉換可變參考成不可變參考不會破壞借用規則。轉換不可變參考成可變參考的話，就需要此不可變參考是該資料的唯一參考，但借用規則無法做擔保。因此 Rust 無法將不可變參考轉換成可變參考。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="透過-drop-特徵執行清除程式碼"><a class="header" href="#透過-drop-特徵執行清除程式碼">透過 <code>Drop</code> 特徵執行清除程式碼</a></h2>
<p>第二個對智慧指標模式很重要的特徵是 <code>Drop</code>，這讓你能自訂數值離開作用域時的行為。你可以對任何型別實作 <code>Drop</code> 特徵，然後你指定的程式碼就能用來釋放像是檔案或網路連線等資源。我們在智慧指標的章節介紹 <code>Drop</code> 的原因是因為 <code>Drop</code> 特徵的功能幾乎永遠會在實作智慧指標時用到。舉例來說，當 <code>Box&lt;T&gt;</code> 離開作用域時，它會釋放該 box 在堆積上指向的記憶體空間。</p>
<p>在某些語言中，當程式設計師使用完某些型別的實例後，每次都得呼叫釋放記憶體與資源的程式碼。例子包括檔案控制代碼（file handle）、插座（socket）或鎖。如果他們忘記的話，系統可能就會過載並崩潰。在 Rust 中你可以對數值離開作用域時指定一些程式碼，然後編譯器就會自動插入此程式碼。所以你就不用每次在特定型別實例使用完時，在程式的每個地方都寫上清理程式碼。而且你還不會泄漏資源！</p>
<p>透過實作 <code>Drop</code> 特徵我們可以指定當數值離開作用域時要執行的程式碼。<code>Drop</code> 特徵會要求我們實作一個方法叫做 <code>drop</code>，這會取得 <code>self</code> 的可變參考。為了觀察 Rust 何時會呼叫 <code>drop</code>，讓我們先用 <code>println!</code> 陳述式實作 <code>drop</code>。</p>
<p>範例 15-14 的結構體 <code>CustomSmartPointer</code> 只有一個功能，那就是在實例離開作用域時印出 <code>Dropping CustomSmartPointer!</code>。此範例能夠展示 Rust 何時會執行 <code>drop</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;釋放 CustomSmartPointer 的資料 `{}`！&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;我的東東&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;其他東東&quot;),
    };
    println!(&quot;CustomSmartPointers 建立完畢。&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 15-14：<code>CustomSmartPointer</code> 結構體實作了會放置清理程式碼的 <code>Drop</code> 特徵</span></p>
<p><code>Drop</code> 特徵包含在 prelude 中，所以我們不需要特地引入作用域。我們對 <code>CustomSmartPointer</code> 實作 <code>Drop</code> 特徵並提供會呼叫 <code>println!</code> 的 <code>drop</code> 方法實作。<code>drop</code> 的函式本體用來放置你想要在型別實例離開作用域時執行的邏輯。我們在此印出一些文字來展示 Rust 如何呼叫 <code>drop</code>。</p>
<p>在 <code>main</code> 中，我們建立了兩個 <code>CustomSmartPointer</code> 實例並印出 <code>CustomSmartPointers 建立完畢</code>。在 <code>main</code> 結尾，我們的 <code>CustomSmartPointer</code> 實例會離開作用域，然後 Rust 就會呼叫我們放在 <code>drop</code> 方法的程式碼，也就是印出我們的最終訊息。注意到我們不需要顯式呼叫 <code>drop</code> 方法。</p>
<p>當我們執行此程式時，我們會看到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers 建立完畢。
釋放 CustomSmartPointer 的資料 `其他東東`!
釋放 CustomSmartPointer 的資料 `我的東東`!
</code></pre>
<p>當我們的實例離開作用域時，Rust 會自動呼叫 <code>drop</code>，呼叫我們指定的程式碼。變數會以與建立時相反的順序被釋放，所以 <code>d</code> 會在 <code>c</code> 之前被釋放。此範例給了我們一個觀察 <code>drop</code> 如何執行的視覺化指引，通常你會指定該型別所需的清除程式碼，而不是印出訊息。</p>
<h3 id="透過-stdmemdrop-提早釋放數值"><a class="header" href="#透過-stdmemdrop-提早釋放數值">透過 <code>std::mem::drop</code> 提早釋放數值</a></h3>
<p>不幸的是，我們無法直接了當地取消自動 <code>drop</code> 的功能。停用 <code>drop</code> 通常是不必要的，整個 <code>Drop</code> 的目的本來就是要能自動處理。不過有些時候你可能會想要提早清除數值。其中一個例子是使用智慧指標來管理鎖：你可能會想要強制呼叫 <code>drop</code> 方法來釋放鎖，好讓作用域中的其他程式碼可以取得該鎖。Rust 不會讓你手動呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法。不過如果你想要一個數值在離開作用域前就被釋放的話，你可以使用標準函式庫提供的 <code>std::mem::drop</code> 函式來呼叫。</p>
<p>如果我們嘗試修改範例 15-14 的 <code>main</code> 函式來手動呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法，如範例 15-15 所示，我們會得到編譯錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;釋放 CustomSmartPointer 的資料 `{}`！&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;某些資料&quot;),
    };
    println!(&quot;CustomSmartPointer 建立完畢。&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer 在 main 結束前就被釋放了。&quot;);
}
</code></pre>
<p><span class="caption">範例 15-15：嘗試呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法來手動提早清除</span></p>
<p>當我們嘗試編譯此程式碼，我們會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre>
<p>此錯誤訊息表示我們不允許顯式呼叫 <code>drop</code>。錯誤訊息使用了一個術語<strong>解構子（destructor）</strong>，這是通用程式設計術語中表達會清除實例的函式。<strong>解構子</strong>對應的術語就是<strong>建構子（constructor）</strong>，這會建立實例。Rust 中的 <code>drop</code> 函式就是一種特定的解構子。</p>
<p>Rust 不讓我們顯式呼叫 <code>drop</code>，因為 Rust 還是會在 <code>main</code> 結束時自動呼叫 <code>drop</code>。這樣可能會導致<strong>重複釋放</strong>（double free）的錯誤，因為 Rust 可能會嘗試清除相同的數值兩次。</p>
<p>當數值離開作用域時我們無法停用自動插入的 <code>drop</code>，而且我們無法顯式呼叫 <code>drop</code> 方法，所以如果我必須強制讓一個數值提早清除的話，我們可以用 <code>std::mem::drop</code> 函式。</p>
<p><code>std::mem::drop</code> 函式不同於 <code>Drop</code> 中的 <code>drop</code> 方法，我們傳入想要強制提早釋放的數值作為引數。此函式也包含在 prelude，所以我們可以修改範例 15-15 的 <code>main</code> 來呼叫 <code>drop</code> 函式，如範例 15-16 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;釋放 CustomSmartPointer 的資料 `{}`！&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;某些資料&quot;),
    };
    println!(&quot;CustomSmartPointer 建立完畢。&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer 在 main 結束前就被釋放了。&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 15-16：在數值離開作用域前呼叫 <code>std::mem::drop</code> 來顯示釋放數值</span></p>
<p>執行此程式會印出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer 建立完畢。
釋放 CustomSmartPointer 的資料 `某些資料`!
CustomSmartPointer 在 main 結束前就被釋放了。
</code></pre>
<p><code>釋放 CustomSmartPointer 的資料 `某些資料`!</code> 這段文字會在 <code>CustomSmartPointer 建立完畢。</code> 與 <code>CustomSmartPointer 在 main 結束前就被釋放了。</code> 文字之間印出，顯示  <code>drop</code> 方法會在那時釋放 <code>c</code>。</p>
<p>你可以在許多地方使用 <code>Drop</code> 特徵實作所指定的程式碼，讓清除實例變得方便又安全。舉例來說，你可以用它來建立你自己的記憶體分配器！透過 <code>Drop</code> 特徵與 Rust 的所有權系統，你不必去擔心要記得清理，因為 Rust 會自動處理。</p>
<p>你也不必擔心會意外清理仍在使用的數值：所有權系統會確保所有參考永遠有效，並確保當數值不再需要使用時只會呼叫 <code>drop</code> 一次。</p>
<p>現在你看過 <code>Box&lt;T&gt;</code> 以及一些智慧指標的特性了，讓我們來看看一些其他定義在標準函式庫的智慧指標吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="rct-參考計數智慧指標"><a class="header" href="#rct-參考計數智慧指標"><code>Rc&lt;T&gt;</code> 參考計數智慧指標</a></h2>
<p>在大多數的場合，所有權是很明確的：你能確切知道哪些變數擁有哪些數值。然而還是有些情況會需要讓一個數值能有數個擁有者。舉例來說，在圖資料結構中數個邊可能就會指向同個節點，而該節點概念上就被所有指向它的邊所擁有。節點直到沒有任何邊指向它，也就是沒有任何擁有者時才會被清除。</p>
<p>你必須使用 Rust 的型別 <code>Rc&lt;T&gt;</code> 才能擁有多重所有權，這是<strong>參考計數</strong>（reference counting）的簡寫。<code>Rc&lt;T&gt;</code> 型別會追蹤參考其數值的數量來決定該數值是否還在使用中。如果數值沒有任何參考的話，該數值就可以被清除，因為不會產生任何無效參考。</p>
<p>想像 <code>Rc&lt;T&gt;</code> 是個在客廳裡的電視，當有人進入客廳要看電視時，它們就會打開它。其他人也能進來觀看電視。當最後一個人離開客廳時，它們會關掉電視，因為沒有任何人會再看了。如果當其他人還在看電視時，有人關掉了它，其他在看電視的人肯定會生氣。</p>
<p><code>Rc&lt;T&gt;</code> 型別的使用時機在於當我們想要在堆積上分配一些資料給程式中數個部分讀取，但是我們無法在編譯時期決定哪個部分會最後一個結束使用數值的部分。如果我們知道哪個部分會最後結束的話，我們可以將那個部分作為資料的擁有者就好，然後正常的所有權規則就會在編譯時生效。</p>
<p>注意到 <code>Rc&lt;T&gt;</code> 只適用於單一執行緒（single-threaded）的場合。當我們在第十六章討論並行（concurrency）時，我們會介紹如何在多執行緒程式達成參考計數。</p>
<h3 id="使用-rct-來分享資料"><a class="header" href="#使用-rct-來分享資料">使用 <code>Rc&lt;T&gt;</code> 來分享資料</a></h3>
<p>讓我們回顧範例 15-5 的 cons list 範例。回想一下我們當時適用 <code>Box&lt;T&gt;</code> 定義。這次我們會建立兩個列表，它們會同時共享第三個列表的所有權。概念上會如圖示 15-3 所示：</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">圖示 15-3：兩個列表 <code>b</code> 和 <code>c</code> 共享第三個列表 <code>a</code> 的所有權</span></p>
<p>我們會建立列表 <code>a</code> 來包含 5 然後是 10。然後我們會在建立兩個列表：<code>b</code> 以 3 為開頭而 <code>c</code> 以 4 為開頭。<code>b</code> 與 <code>c</code> 列表會同時連接包含 5 與 10 的第一個列表 <code>a</code>。換句話說，兩個列表會同時共享包含 5 與 10 的第一個列表。</p>
<p>嘗試使用 <code>Box&lt;T&gt;</code> 來定義這種情境的 <code>List</code> 的話會無法成功，如範例 15-17 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">範例 15-17：展示我們無法用 <code>Box&lt;T&gt;</code> 讓兩個列表嘗試共享第三個列表的所有權</span></p>
<p>當我們編譯此程式碼，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list` due to previous error
</code></pre>
<p><code>Cons</code> 變體擁有它們存有的資料，所以當我們建立列表 <code>b</code> 時，<code>a</code> 會移動到 <code>b</code>，所以 <code>b</code> 就擁有 <code>a</code>。然後當我們嘗試再次使用 <code>a</code> 來建立 <code>c</code> 時，這就不會被允許，因為 <code>a</code> 已經被移走了。</p>
<p>我們可以嘗試改用參考來變更 <code>Cons</code> 的定義，但是這樣我們就必須指定生命週期參數。透過指定生命週期參數，我們會指定列表中的每個元素會至少活得跟整個列表一樣久。範例 15-17 的元素和列表雖然可以這樣，但不是所有的場合都是如此。</p>
<p>我們最後可以改用 <code>Rc&lt;T&gt;</code> 來變更 <code>List</code> 的定義，如範例 15-18 所示。每個 <code>Cons</code> 變體都會存有一個數值以及一個由 <code>Rc&lt;T&gt;</code> 指向的 <code>List</code>。當我們建立 <code>b</code> 時，不會取走 <code>a</code> 的所有權，我們會克隆（clone） <code>a</code> 存有的 <code>Rc&lt;List&gt;</code>，因而增加參考的數量從一增加到二，並讓 <code>a</code> 與 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 資料的所有權。我們也在在建立 <code>c</code> 時克隆 <code>a</code>，增加參考的數量從二增加到三。每次我們呼叫 <code>Rc::clone</code> 時，對 <code>Rc&lt;List&gt;</code> 資料的參考計數就會成增加，然後資料不會被清除直到沒有任何參考為止。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">範例 15-18：使用 <code>Rc&lt;T&gt;</code> 來定義 <code>List</code></span></p>
<p>我們需要使用 <code>use</code> 陳述式來將 <code>Rc&lt;T&gt;</code> 引入作用域，因為它沒有被包含在 prelude 中。在 <code>main</code> 中，我們建立了一個包含 5 與 10 的列表並存入 <code>a</code> 的 <code>Rc&lt;List&gt;</code>。然後當我們建立 <code>b</code> 與 <code>c</code> 時，我們會呼叫函式 <code>Rc::clone</code> 來將 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 參考作為引數傳入。</p>
<p>當然我們可以呼叫 <code>a.clone()</code> 而非 <code>Rc::clone(&amp;a)</code>，但是在此情形中 Rust 的慣例是使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的實作不會像大多數型別的 <code>clone</code> 實作會深拷貝（deep copy）所有的資料。 <code>Rc::clone</code> 的呼叫只會增加參考計數，這花費的時間就相對很少。深拷貝通常會花費比較多的時間。透過使用 <code>Rc::clone</code> 來參考計數，我們可以以視覺辨別出這是深拷貝的克隆還是增加參考計數的克隆。當我們需要調查程式碼的效能問題時，我們就只需要考慮深拷貝的克隆，而不必在意 <code>Rc::clone</code>。</p>
<h3 id="克隆-rct-實例會增加其參考計數"><a class="header" href="#克隆-rct-實例會增加其參考計數">克隆 <code>Rc&lt;T&gt;</code> 實例會增加其參考計數</a></h3>
<p>讓我們改變範例 15-18 的範例，好讓我們能觀察參考計數在我們建立與釋放 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 參考時產生的變化。</p>
<p>範例 15-19，我們改變了 <code>main</code> 讓列表 <code>c</code> 寫在一個內部作用域中，然後我們就能觀察到當 <code>c</code> 離開作用域時參考計數產生的改變。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;建立 a 後的計數 = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;建立 b 後的計數 = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;建立 c 後的計數 = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;c 離開作用域後的計數 = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">範例 15-19：印出參考計數</span></p>
<p>在程式中每次參考計數產生改變的地方，我們就印出參考計數，我們可以透過呼叫函式 <code>Rc::strong_count</code> 來取得。此函式叫做 <code>strong_count</code> 而非 <code>count</code> 是因為 <code>Rc&lt;T&gt;</code> 型別還有個 <code>weak_count</code>，我們會在 <a href="ch15-06-reference-cycles.html#%E9%81%BF%E5%85%8D%E5%8F%83%E8%80%83%E5%BE%AA%E7%92%B0%E5%B0%87-rct-%E8%BD%89%E6%8F%9B%E6%88%90-weakt">「避免參考循環：將 <code>Rc&lt;T&gt;</code> 轉換成 <code>Weak&lt;T&gt;</code>」</a><!-- ignore --> 段落看到 <code>weak_count</code> 的使用方式。</p>
<p>此程式碼印出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
建立 a 後的計數 = 1
建立 b 後的計數 = 2
建立 c 後的計數 = 3
c 離開作用域後的計數 = 2
</code></pre>
<p>我們可以看到 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 會有個初始參考計數 1，然後我們每次呼叫 <code>clone</code> 時，計數會加 1。當 <code>c</code> 離開作用域時，計數會減 1。我們不必呼叫任何函式來減少參考計數，像呼叫 <code>Rc::clone</code> 時才會增加參考計數那樣。當 <code>Rc&lt;T&gt;</code> 數值離開作用域時，<code>Drop</code> 特徵的實作就會自動減少參考計數。</p>
<p>我們無法從此例觀察到的是當 <code>b</code> 然後是 <code>a</code> 從 <code>main</code> 的結尾離開作用域時，計數會是 0，然後 <code>Rc&lt;List&gt;</code> 在此時就會完全被清除。使用 <code>Rc&lt;T&gt;</code> 能允許單一數值能有數個擁有者，然後計數會確保只要有任何擁有者還存在的狀況下，數值會保持是有效的。</p>
<p>透過不可變參考，<code>Rc&lt;T&gt;</code> 能讓你分享資料給程式中數個部分來只做讀取的動作。如果 <code>Rc&lt;T&gt;</code> 允許你也擁有數個可變參考的話，你可能就違反了第四章提及的借用規則：數個對相同位置的可變借用會導致資料競爭（data races）與不一致。但可變資料還是非常實用的！在下個段落，我們會討論內部可變性模式與 <code>RefCell&lt;T&gt;</code> 型別，此型別能讓你搭配 <code>Rc&lt;T&gt;</code> 使用來處理不可變的限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="refcellt-與內部可變性模式"><a class="header" href="#refcellt-與內部可變性模式"><code>RefCell&lt;T&gt;</code> 與內部可變性模式</a></h2>
<p><strong>內部可變性</strong>（Interior mutability）是 Rust 中的一種設計模式，能讓你能對即使是不可變參考的資料也能改變。正常狀況下，借用規則是不允許這種動作的。為了改變資料，這樣的模式會在資料結構內使用 <code>unsafe</code> 程式碼來繞過 Rust 的常見可變性與借用規則。不安全（unsafe）的程式碼等於告訴編譯器我們會自己手動檢查，編譯器不會檢查全部的規則，我們會在第十九章討論更多關於不安全的程式碼。</p>
<p>當編譯器無法保障，但我們可以確保借用規則在執行時能夠遵循的話，我們就可以使用擁有內部可變性模式的型別。其內的 <code>unsafe</code> 程式碼會透過安全的 API 封裝起來，讓外部型別仍然是不可變的。</p>
<p>讓我們觀察擁有內部可變性模式的 <code>RefCell&lt;T&gt;</code> 型別來探討此概念。</p>
<h3 id="透過-refcellt-在執行時強制檢測借用規則"><a class="header" href="#透過-refcellt-在執行時強制檢測借用規則">透過 <code>RefCell&lt;T&gt;</code> 在執行時強制檢測借用規則</a></h3>
<p>不像 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 型別的資料只會有一個所有權。所以 <code>RefCell&lt;T&gt;</code> 與 <code>Box&lt;T&gt;</code> 這種型別有何差別呢？回憶一下你在第四章學到的借用規則：</p>
<ul>
<li>在任何時候，我們要麼<strong>只能有</strong>一個可變參考，要麼可以有<strong>任意數量</strong>的不可變參考。</li>
<li>參考必須永遠有效。</li>
</ul>
<p>對於參考與 <code>Box&lt;T&gt;</code>，借用規則會在編譯期強制檢測。對於 <code>RefCell&lt;T&gt;</code>，這些規則會在<strong>執行時</strong>才強制執行。對於參考來說，如果你打破這些規則，你會得到編譯錯誤。而對 <code>RefCell&lt;T&gt;</code> 來說，如果你打破這些規則，你的程式會恐慌並離開。</p>
<p>在編譯時期檢查借用規則的優勢在於錯誤能在開發過程及早獲取，而且這對執行時的效能沒有任何影響，因為所有的分析都預先完成了。基於這些原因，在編譯時檢查借用規則在大多數情形都是最佳選擇，這也是為何這是 Rust 預設設置的原因。</p>
<p>在執行時檢查借用規則的優勢則在於能允許一些特定記憶體安全的場合，而這些原本是不被編譯時檢查所允許的。像 Rust 編譯器這種靜態分析本質上是保守的。有些程式碼特性是無法透過分析程式碼檢測出的，最著名的範例就是停機問題（Halting Problem），這超出本書的範疇，但是是個有趣的研究議題。</p>
<p>因為有些分析是不可能的，如果 Rust 編譯器無法確定程式碼是否符合所有權規則，它可能會拒絕一支正確的程式，所以由此觀點來看能知道 Rust 編譯器是保守的。如果 Rust 接受不正確的程式，使用者就無法信任 Rust 帶來的保障。然而如果 Rust 拒絕正確的程式，對程式設計師就會很不方便，但沒有任何嚴重的災難會發生。<code>RefCell&lt;T&gt;</code> 型別就適用於當你確定你的程式碼有遵循借用規則，但是編譯器無法理解並保證的時候。</p>
<p>類似於 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 也只能用於單一執行緒（single-threaded）的場合，所以如果你嘗試用在多執行緒上的話就會出現編譯時錯誤。我們會在第十六章討論如何在多執行緒程式擁有 <code>RefCell&lt;T&gt;</code> 的功能。</p>
<p>以下是何時選擇 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 讓數個擁有者能共享相同資料；<code>Box&lt;T&gt;</code> 與 <code>RefCell&lt;T&gt;</code> 只能有一個擁有者。</li>
<li><code>Box&lt;T&gt;</code> 能有不可變或可變的借用並在編譯時檢查；<code>Rc&lt;T&gt;</code> 則只能有不可變借用並在編譯時檢查：<code>RefCell&lt;T&gt;</code> 能有不可變或可變借用但是在執行時檢查。</li>
<li>由於 <code>RefCell&lt;T&gt;</code> 允許在執行時檢查可變參考，你可以改變 <code>RefCell&lt;T&gt;</code> 內部的數值，就算 <code>RefCell&lt;T&gt;</code> 是不可變的。</li>
</ul>
<p>改變不可變數值內部的值就<strong>內部可變性</strong>模式。讓我們看看內部可變性何時會有用，且觀察為何是可行的。</p>
<h3 id="內部可變性不可變數值的可變借用"><a class="header" href="#內部可變性不可變數值的可變借用">內部可變性：不可變數值的可變借用</a></h3>
<p>借用規則的影響是當你有個不可變數值，你就無法取得可變參考。舉例來說，以下程式碼會無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>如果你嘗試編譯此程式碼，你會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` due to previous error
</code></pre>
<p>然而在某些特定情況，我們會想要能夠有個方法可以改變一個數值，但該數值對其他程式碼而言仍然是不可變的。數值提供的方法以外的程式碼都無法改變其值。使用 <code>RefCell&lt;T&gt;</code> 是取得內部可變性的方式之一。但 <code>RefCell&lt;T&gt;</code> 仍然要完全遵守借用規則：編譯器的借用檢查器會允許這些內部可變性，然後在執行時才檢查借用規則。如果你違反規則，你就會得到 <code>panic!</code> 而非編譯錯誤。</p>
<p>讓我們用一個實際例子來探討如何使用 <code>RefCell&lt;T&gt;</code> 來改變不可變數值，並瞭解為何這是很實用的。</p>
<h4 id="內部可變性的使用案例模擬物件"><a class="header" href="#內部可變性的使用案例模擬物件">內部可變性的使用案例：模擬物件</a></h4>
<p>程式設計師有時在進行測試時會將一個型別替換成其他型別，用以觀察特定行為並判定是否有正確實作。這種型別就稱為<strong>測試替身</strong>（test double）。你可以想成這和影視產業中的「特技替身演員」類似，有個人會代替原本的演員來拍攝一些特定的場景。測試替身會在執行測試時代替其他型別。<strong>模擬物件</strong>（Mock objects）是測試替身其中一種特定型別，這能紀錄測試過程中發生什麼事並讓你能判斷動作是否正確。</p>
<p>Rust 的物件與其他語言中的物件概念並不全然相同，而且 Rust 的標準函式庫內也沒有如其他語言會內建的模擬物件功能。不過你還是可以有方法來建立結構體來作為模擬物件。</p>
<p>以下是我們要測試的情境：我們建立一個函式庫來追蹤一個數值與最大值的差距，並依據該差距傳送訊息。舉例來說，此函式庫就能用來追蹤使用者允許呼叫 API 次數的上限。</p>
<p>我們的函式庫提供的功能只有追蹤與最大值的距離以及何時該傳送什麼訊息。使用函式庫的應用程式要提供傳送訊息的機制，應用程式可以將訊息存在應用程式內、傳送電子郵件、傳送文字訊息或其他等等。函式庫不需要知道細節，它只需要在意會有項目實作我們提供的 <code>Messenger</code> 特徵。範例 15-20 顯示了函式庫的程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;錯誤：你超過使用上限了！&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;緊急警告：你已經使用 90% 的配額了！&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;警告：你已經使用 75% 的配額了！&quot;);
        }
    }
}
</code></pre>
<p><span class="caption">範例 15-20：追蹤某個值與最大值差距的函式庫並以此值的特定層級傳送警告</span></p>
<p>此程式碼其中一個重點是 <code>Messenger</code> 特徵有個方法叫做 <code>send</code>，這會接收一個 <code>self</code> 的不可變參考與一串訊息文字。此特徵就是我們的模擬物件所需實作的介面，讓我們能模擬和實際物件一樣的行爲。另一個重點是我們想要測試 <code>LimitTracker</code> 中 <code>set_value</code> 方法的行為。我們可以改變傳給參數 <code>value</code> 的值，但是 <code>set_value</code> 沒有回傳任何東西好讓我們做判斷。我們希望如果我們透過某個實作 <code>Messenger</code> 的型別與特定數值 <code>max</code> 來建立 <code>LimitTracker</code> 時，傳送訊息者能被通知要傳遞合適的訊息。</p>
<p>我們需要有個模擬物件，而不是在呼叫 <code>send</code> 時真的傳送電子郵件或文字訊息，我們只想紀錄訊息被通知要傳送了。我們可以建立模擬物件的實例，以此建立 <code>LimitTracker</code>、呼叫 <code>LimitTracker</code> 的 <code>set_value</code>，並檢查模擬物件有我們預期的訊息。範例 15-21 展示一個嘗試實作此事的模擬物件，但借用檢查器卻不允許：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;錯誤：你超過使用上限了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;緊急警告：你已經使用 90% 的配額了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;警告：你已經使用 75% 的配額了！&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
</code></pre>
<p><span class="caption">範例 15-21：嘗試實作 <code>MockMessenger</code> 但借用檢查器不允許</span></p>
<p>此測試程式碼定義了一個結構體 <code>MockMessenger</code> 其有個 <code>sent_messages</code> 欄位並存有 <code>String</code> 數值的 <code>Vec</code> 來追蹤被通知要傳送的訊息。我們也定義了一個關聯函式 <code>new</code> 讓我們可以方便建立起始訊息列表為空的 <code>MockMessenger</code>。我們對 <code>MockMessenger</code> 實作 <code>Messenger</code> 特徵，這樣我們才能將 <code>MockMessenger</code> 交給 <code>LimitTracker</code>。在 <code>send</code> 方法的定義中，我們取得由參數傳遞的訊息，並存入 <code>MockMessenger</code> 的 <code>sent_messages</code> 列表中。</p>
<p>在測試中，我們測試當 <code>LimitTracker</code> 被通知將 <code>value</code> 設為超過 <code>max</code> 數值 75% 的某個值。首先，我們建立新的 <code>MockMessenger</code>，其起始為一個空的訊息列表。然後我們建立一個新的 <code>LimitTracker</code> 並將 <code>MockMessenger</code> 的參考與一個 <code>max</code> 為 100 的數值賦值給它。我們用數值 80 來呼叫 <code>LimitTracker</code> 的 <code>set_value</code> 方法，此值會超過 100 的 75%。然後我們判定 <code>MockMessenger</code> 追蹤的訊息列表需要至少有一個訊息。</p>
<p>但是此測試有個問題，如以下所示：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
2  |     fn send(&amp;self, msg: &amp;str);
   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` due to previous error
warning: build failed, waiting for other jobs to finish...
</code></pre>
<p>我們無法修改 <code>MockMessenger</code> 來追蹤訊息，因為 <code>send</code> 方法取得的是 <code>self</code> 的不可變參考。而我們也無法使用錯誤訊息中推薦使用的 <code>&amp;mut self</code>，因為 <code>send</code> 的簽名就會與 <code>Messenger</code> 特徵所定義的不相符（你可以試看看並觀察錯誤訊息）。</p>
<p>這就是內部可變性能帶來幫助的場合！我們會將 <code>sent_messages</code> 存入 <code>RefCell&lt;T&gt;</code> 內，然後 <code>send</code> 方法就也能夠進行修改存入訊息。範例 15-22 顯示了變更後的程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;錯誤：你超過使用上限了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;緊急警告：你已經使用 90% 的配額了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;警告：你已經使用 75% 的配額了！&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --省略--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
</code></pre>
<p><span class="caption">範例 15-22：在外部數值為不可變時，使用 <code>RefCell&lt;T&gt;</code> 來改變內部數值</span></p>
<p><code>sent_messages</code> 欄位現在是型別 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 而非 <code>Vec&lt;String&gt;</code>。在 <code>new</code> 函式中，我們用空的向量來建立新的 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>。</p>
<p>至於 <code>send</code> 方法的實作，第一個參數仍然是 <code>self</code> 的不可變借用，這就符合特徵所定義的。我們在 <code>self.sent_messages</code> 對 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 呼叫 <code>borrow_mut</code> 來取得 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 內的可變參考數值，也就是向量。然後我們對向量的可變參考呼叫 <code>push</code> 來追蹤測試中的訊息。</p>
<p>最後一項改變是判定：要看到內部向量有多少項目的話，我們對 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 呼叫 <code>borrow</code> 來取得向量的不可變參考。</p>
<p>現在你已經知道如何使用 <code>RefCell&lt;T&gt;</code>，讓我們進一步探討它如何運作的吧！</p>
<h4 id="透過-refcellt-在執行時追蹤借用"><a class="header" href="#透過-refcellt-在執行時追蹤借用">透過 <code>RefCell&lt;T&gt;</code> 在執行時追蹤借用</a></h4>
<p>當建立不可變與可變參考時，我們分別使用 <code>&amp;</code> 和 <code>&amp;mut</code> 語法。而對於 <code>RefCell&lt;T&gt;</code> 的話，我們使用 <code>borrow</code> 和 <code>borrow_mut</code> 方法，這是 <code>RefCell&lt;T&gt;</code> 所提供的安全 API 之一。<code>borrow</code> 方法回傳一個智慧指標型別 <code>Ref&lt;T&gt;</code>，而 <code>borrow_mut</code> 回傳智慧指標型別 <code>RefMut&lt;T&gt;</code>。這兩個型別都有實作 <code>Deref</code>，所以我們可以像一般參考來對待它們。</p>
<p><code>RefCell&lt;T&gt;</code> 會追蹤當前有多少 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智慧指標存在。每次我們呼叫 <code>borrow</code> 時，<code>RefCell&lt;T&gt;</code> 會增加不可變借用計數。當 <code>Ref&lt;T&gt;</code> 離開作用域時，不可變借用計數就會減一。就和編譯時借用規則一樣，<code>RefCell&lt;T&gt;</code> 讓我們同一時間要麼只能有一個可變參考，要麼可以有數個不可變參考。</p>
<p>如果我們嘗試違反這些規則，我們不會像參考那樣得到編譯器錯誤，<code>RefCell&lt;T&gt;</code> 的實作會在執行時恐慌。範例 15-23 修改了範例 15-22 的 <code>send</code> 實作。我們故意嘗試在同個作用域下建立兩個可變參考，來說明 <code>RefCell&lt;T&gt;</code> 會不允許我們在執行時這樣做。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;錯誤：你超過使用上限了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;緊急警告：你已經使用 90% 的配額了！&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;警告：你已經使用 75% 的配額了！&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 15-23：在同個作用域建立兩個可變參考並觀察到 <code>RefCell&lt;T&gt;</code> 會恐慌</span></p>
<p>我們從 <code>borrow_mut</code> 回傳的 <code>RefMut&lt;T&gt;</code> 智慧指標來建立變數 <code>one_borrow</code>。然後我們再以相同方式建立另一個變數 <code>two_borrow</code>。這在同個作用域下產生了兩個可變參考，而這是不允許的。我們執行函式庫的測試時，範例 15-23 可以編譯通過，但是執行測試會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>注意到程式碼恐慌時的訊息 <code>already borrowed: BorrowMutError</code>。這就是 <code>RefCell&lt;T&gt;</code> 如何在執行時處理違反借用規則的情況。</p>
<p>像我們在這裡選擇在執行時獲取借用錯誤而不是在編譯時，代表你會在開發過程之後才找到程式碼錯誤，甚至有可能一直到程式碼部署到正式環境後才查覺。而且你的程式碼也會多了一寫小小的執行時效能開銷，作為在執行時而非編譯時檢查的代價。不過使用 <code>RefCell&lt;T&gt;</code>  讓你能在只允許有不可變數值的環境中寫出能夠變更內部追蹤訊息的模擬物件。這是想獲得 <code>RefCell&lt;T&gt;</code> 帶來的功能時，要與一般參考之間作出的取捨。</p>
<h3 id="組合-rct-與-refcellt-來擁有多個可變資料的擁有者"><a class="header" href="#組合-rct-與-refcellt-來擁有多個可變資料的擁有者">組合 <code>Rc&lt;T&gt;</code> 與 <code>RefCell&lt;T&gt;</code> 來擁有多個可變資料的擁有者</a></h3>
<p><code>RefCell&lt;T&gt;</code> 的常見使用方法是搭配 <code>Rc&lt;T&gt;</code>。回想一下 <code>Rc&lt;T&gt;</code> 讓你可以對數個擁有者共享相同資料，但是它只能用於不可變資料。如果你有一個 <code>Rc&lt;T&gt;</code> 並存有 <code>RefCell&lt;T&gt;</code> 的話，你就可以取得一個有數個擁有者<strong>而且</strong>可變的數值！</p>
<p>舉例來說，回憶一下範例 15-18 cons list 的範例我們使用了 <code>Rc&lt;T&gt;</code> 來讓數個列表可以共享另一個列表的所有權。因為 <code>Rc&lt;T&gt;</code> 只能有不可變數值，我們一旦建立它們後就無法變更列表中的任何數值。讓我們加上 <code>RefCell&lt;T&gt;</code> 來獲得能改變列表數值的能力吧。範例 15-24 顯示了在 <code>Cons</code> 定義中使用 <code>RefCell&lt;T&gt;</code>，這樣一來我們就可以變更儲存在列表中的所有數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a 之後 = {:?}&quot;, a);
    println!(&quot;b 之後 = {:?}&quot;, b);
    println!(&quot;c 之後 = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">範例 15-24：使用 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 建立一個可變的 <code>List</code></span></p>
<p>我們建立了一個 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 實例數值並將其存入變數 <code>value</code> 好讓我們之後可以直接取得。然後我們在 <code>a</code> 用持有 <code>value</code> 的 <code>Cons</code> 變體來建立 <code>List</code>。我們需要克隆 <code>value</code>，這樣 <code>a</code> 和 <code>value</code> 才能都有內部數值 <code>5</code> 的所有權，而不是從 <code>value</code> 轉移所有權給 <code>a</code>，或是讓 <code>a</code> 借用 <code>value</code>。</p>
<p>我們用 <code>Rc&lt;T&gt;</code> 封裝列表 <code>a</code>，所以當我們建立列表 <code>b</code> 和 <code>c</code> 時，它們都可以參考 <code>a</code>，就像範例 15-18 一樣。</p>
<p>在我們建立完列表 <code>a</code>、<code>b</code> 和 <code>c</code> 之後，我們想對 <code>value</code> 的數值加上 10。我們對 <code>value</code> 呼叫 <code>borrow_mut</code>，其中使用到了我們在第五章討論過的自動解參考功能（請查閱<a href="ch05-03-method-syntax.html#--%E9%81%8B%E7%AE%97%E5%AD%90%E8%B7%91%E5%8E%BB%E5%93%AA%E4%BA%86">「<code>-&gt;</code> 運算子跑去哪了？」</a><!-- ignore -->的段落）來解參考 <code>Rc&lt;T&gt;</code> 成內部的 <code>RefCell&lt;T&gt;</code> 數值。<code>borrow_mut</code> 方法會回傳 <code>RefMut&lt;T&gt;</code> 智慧指標，而我們使用解參考運算子並改變其內部數值。</p>
<p>當我們印出 <code>a</code>、<code>b</code> 和 <code>c</code> 時，我們可以看到它們的數值都改成了 15 而非 5：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a 之後 = Cons(RefCell { value: 15 }, Nil)
b 之後 = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c 之後 = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>此技巧是不是很厲害！透過使用 <code>RefCell&lt;T&gt;</code>，我們可以得到一個外部是不可變的 <code>List</code> 數值，但是我們可以使用 <code>RefCell&lt;T&gt;</code> 提供的方法來取得其內部可變性，讓我們可以在我們想要時改變我們的資料。執行時的借用規則檢查能防止資料競爭，並在某些場合犧牲一點速度來換取資料結構的彈性。注意到 <code>RefCell&lt;T&gt;</code> 無法用在多執行緒的程式碼！<code>Mutex&lt;T&gt;</code> 才是執行緒安全版的 <code>RefCell&lt;T&gt;</code>，我們會在第十六章再討論 <code>Mutex&lt;T&gt;</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="參考循環會導致記憶體泄漏"><a class="header" href="#參考循環會導致記憶體泄漏">參考循環會導致記憶體泄漏</a></h2>
<p>意外情況下，執行程式時可能會產生永遠不會被清除的記憶體（通稱為<strong>記憶體泄漏／memory leak</strong>）。Rust 的記憶體安全性雖然可以保證令這種情況難以發生，但並非絕不可能。雖然 Rust 在編譯時可以保證做到禁止資料競爭（<strong>data races</strong>），但它無法保證完全避免記憶體泄漏，這是因為對 Rust 來說，記憶體泄漏是屬於安全範疇內的（<strong>memory safe</strong>)。透過使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> ，我們能觀察到 Rust 允許使用者自行產生記憶體泄漏：因為使用者可以產生兩個參考並互相參照，造成一個循環。這種情況下會導致記憶體泄漏，因為循環中的參考計數永遠不會變成 0，所以數值永遠不會被釋放。</p>
<h3 id="產生參考循環"><a class="header" href="#產生參考循環">產生參考循環</a></h3>
<p>讓我們看看參考循環是怎麼發生的，以及如何避免它。我們從範例 15-25 的 <code>List</code> 枚舉定義與一個 <code>tail</code> 方法開始：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 15-25：一個 cons list 定義並持有 <code>RefCell&lt;T&gt;</code>，所以我們可以修改 <code>Cons</code> 變體參考的值</span></p>
<p>我們用的是範例 15-5 中 <code>List</code> 的另一種定義寫法。<code>Cons</code> 變體的第二個元素現在是 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>，代表不同於範例 15-24 那樣能修改 <code>i32</code> 數值，我們想要能修改 <code>Cons</code> 變體指向的 <code>List</code> 數值。我們也加了一個 <code>tail</code> 方法讓我們如果有 <code>Cons</code> 變體的話，能方便取得第二個項目。</p>
<p>在範例 15-26 我們要加入 <code>main</code> 函式並使用範例 15-25 的定義。此程式碼建立了列表 <code>a</code> 與指向列表 <code>a</code> 的列表 <code>b</code>。然後它修改了列表 <code>a</code> 來指向 <code>b</code>，因而產生循環參考。在程序過程中 <code>println!</code> 陳述式會顯示不同位置時的參考計數。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a 初始參考計數 = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a 下個項目 = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a 在 b 建立後的參考計數 = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b 初始參考計數 = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b 下個項目 = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b 在變更 a 後的參考計數 = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a 在變更 a 後的參考計數 = {}&quot;, Rc::strong_count(&amp;a));

    // 取消下一行的註解可以看到循環產生
    // 這會讓堆疊溢位
    // println!(&quot;a 下個項目 = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">範例 15-26：透過兩個彼此指向對方的 <code>List</code> 數值來產生參考循環</span></p>
<p>我們在變數 <code>a</code> 建立了一個 <code>Rc&lt;List&gt;</code> 實例的 <code>List</code> 數值並持有 <code>5, Nil</code> 初始列表的。我們然後在變數  <code>b</code> 建立另一個 <code>Rc&lt;List&gt;</code> 實例的 <code>List</code> 數值並持有數值 10 與指向的列表 <code>a</code>。</p>
<p>我們將 <code>a</code> 修改為指向 <code>b</code> 而非 <code>Nil</code> 來產生循環。我們透過使用 <code>tail</code> 方法來取得 <code>a</code> 的 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 參考，並放入變數 <code>link</code> 中。然後我們對 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 使用 <code>borrow_mut</code> 方法來改變 <code>Rc&lt;List&gt;</code> 的值，從數值 <code>Nil</code> 改成 <code>b</code> 的 <code>Rc&lt;List&gt;</code>。</p>
<p>當我們執行此程式並維持將最後一行的 <code>println!</code> 註解掉的話，我們會得到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a 初始參考計數 = 1
a 下個項目 = Some(RefCell { value: Nil })
a 在 b 建立後的參考計數 = 2
b 初始參考計數 = 1
b 下個項目 = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b 在變更 a 後的參考計數 = 2
a 在變更 a 後的參考計數 = 2
</code></pre>
<p>在我們變更列表 <code>a</code> 來指向 <code>b</code> 後，<code>a</code> 和 <code>b</code> 的 <code>Rc&lt;List&gt;</code> 實例參考計數都是 2。在 <code>main</code> 結束後，Rust 會釋放 <code>b</code>，讓 <code>b</code> 的 <code>Rc&lt;List&gt;</code> 實例計數從 2 減到 1。此時堆積上 <code>Rc&lt;List&gt;</code> 的記憶體還不會被釋放，因爲參考計數還有 1，而非 0。然後 Rust 釋放 <code>a</code>，讓 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 實例也從 2 減到 1。此實例的記憶體也不會被釋放，因爲另一個 <code>Rc&lt;List&gt;</code> 的實例仍然參考著它。列表分配的記憶體會永遠不被釋放。為了視覺化參考循環，我們用圖示 15-4 表示。</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">圖示 15-4：列表 <code>a</code> 與 <code>b</code> 彼此指向對方的參考循環</span></p>
<p>如果你解除最後一個 <code>println!</code> 的註解並執行程式的話，Rust 會嘗試印出此循環，因為 <code>a</code> 會指向 <code>b</code> 會指向 <code>a</code> 以此循環下去，直到堆疊溢位（stack overflow）。</p>
<p>比起真實世界的程式，此循環造成的影響並不嚴重。因為當我們建立完循環參考，程式就結束了。不過要是有個更複雜的程式分配了大量的記憶體而產生循環，並維持很長一段時間的話，程式會用到比原本預期還多的記憶體，並可能壓垮系統，導致它將記憶體用光。</p>
<p>要產生循環參考並不是件容易的事，但也不是絕對不可能。如果你有包含 <code>Rc&lt;T&gt;</code> 數值的 <code>RefCell&lt;T&gt;</code> 數值，或是有類似具內部可變性與參考計數巢狀組合的話，你必須確保不會產生循環參考，你無法依靠 Rust 來檢查它們。產生循環參考是程式中的邏輯錯誤，你需要使用自動化測試、程式碼審查以及其他軟體開發技巧來最小化問題。</p>
<p>另一個避免參考循環的解決辦法是重新組織你的資料結構，確定哪些參考要有所有權，哪些參考不用。這樣一來，循環會由一些有所有權的關係與沒有所有權的關係所組成，而只有所有權關係能影響數值是否能被釋放。在範例 15-25 中。我們永遠會希望 <code>Cons</code> 變體擁有它們的列表，讓重新組織資料結構變得有可能。讓我們看看一個由父節點與子節點的圖形結構，來看看無所有權的關係何時適合用來避免循環參考。</p>
<h3 id="避免參考循環將-rct-轉換成-weakt"><a class="header" href="#避免參考循環將-rct-轉換成-weakt">避免參考循環：將 <code>Rc&lt;T&gt;</code> 轉換成 <code>Weak&lt;T&gt;</code></a></h3>
<p>目前，我們解釋過呼叫 <code>Rc::clone</code> 會增加 <code>Rc&lt;T&gt;</code> 實例的 <code>strong_count</code>，而 <code>Rc&lt;T&gt;</code> 只會在 <code>strong_count</code> 為 0 時被清除。你也可以對 <code>Rc&lt;T&gt;</code> 實例呼叫 <code>Rc::downgrade</code> 並傳入 <code>Rc&lt;T&gt;</code> 的參考來建立<strong>弱參考（weak reference）</strong>。強參考是你分享 <code>Rc&lt;T&gt;</code> 實例的方式。弱參考不會表達所有權關係，它們的計數與 <code>Rc&lt;T&gt;</code> 的清除無關。它們不會造成參考循環，因為弱參考的循環會在其強參考計數歸零時解除。</p>
<p>當你呼叫 <code>Rc::downgrade</code> 時，你會得到一個型別為 <code>Weak&lt;T&gt;</code> 的智慧指標。不同於對 <code>Rc&lt;T&gt;</code> 實例的 <code>strong_count</code> 增加 1，呼叫 <code>Rc::downgrade</code> 會對 <code>weak_count</code> 增加 1。<code>Rc&lt;T&gt;</code> 型別使用 <code>weak_count</code> 來追蹤有多少 <code>Weak&lt;T&gt;</code> 的參考存在，這類似於 <code>strong_count</code>。不同的地方在於 <code>weak_count</code> 不需要歸零才能將 <code>Rc&lt;T&gt;</code> 清除。</p>
<p>由於 <code>Weak&lt;T&gt;</code> 的參考數值可能會被釋放，要對 <code>Weak&lt;T&gt;</code> 指向的數值做任何事情時，你都必須確保該數值還存在。你可以透過對 <code>Weak&lt;T&gt;</code> 實例呼叫 <code>upgrade</code> 方法，這會回傳 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。如果 <code>Rc&lt;T&gt;</code> 數值還沒被釋放的話，你就會得到 <code>Some</code>；而如果 <code>Rc&lt;T&gt;</code> 數值已經被釋放的話，就會得到 <code>None</code>。因為 <code>upgrade</code> 回傳 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，Rust 會確保 <code>Some</code> 與 <code>None</code> 的分支都有處理好，所以不會取得無效指標。</p>
<p>為了做示範，與其使用知道下一項的列表的例子，我們會建立一個樹狀結構，每一個項目會知道它們的子項目<strong>以及</strong>它們的父項目。</p>
<h4 id="建立樹狀資料結構帶有子節點的-node"><a class="header" href="#建立樹狀資料結構帶有子節點的-node">建立樹狀資料結構：帶有子節點的 <code>Node</code></a></h4>
<p>首先我們建立一個帶有節點的樹，每個節點知道它們的子節點。我們會定義一個結構體 <code>Node</code> 來存有它自己的 <code>i32</code> 數值以及其子數值 <code>Node</code> 的參考：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>我們想要 <code>Node</code> 擁有自己的子節點，而且我們想要透過變數分享所有權，讓我們可以在樹中取得每個 <code>Node</code>。為此我們定義 <code>Vec&lt;T&gt;</code> 項目作為型別 <code>Rc&lt;Node&gt;</code> 的數值。我們還想要能夠修改哪些節點才是該項目的子節點，所以我們將 <code>children</code> 中的 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 加進 <code>RefCell&lt;T&gt;</code>。</p>
<p>接著，我們使用我們定義的結構體來建立一個 <code>Node</code> 實例叫做 <code>leaf</code>，其數值為 3 且沒有子節點；我們再建立另一個實例叫做 <code>branch</code>，其數值為 5 且有個子節點 <code>leaf</code>。如範例 15-27 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">範例 15-27：建立一個沒有子節點的 <code>leaf</code> 節點與一個有 <code>leaf</code> 作為子節點的 <code>branch</code> 節點</span></p>
<p>我們克隆 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 並存入 <code>branch</code>，代表 <code>leaf</code> 的 <code>Node</code> 現在有兩個擁有者：<code>leaf</code> 和 <code>branch</code>。我們可以透過 <code>branch.children</code> 從 <code>branch</code> 取得 <code>leaf</code>，但是從 <code>leaf</code> 無法取得 <code>branch</code>。原因是因為 <code>leaf</code> 沒有 <code>branch</code> 的參考且不知道它們之間是有關聯的。我們想要 <code>leaf</code> 能知道 <code>branch</code> 是它的父節點。這就是我們接下來要做的事。</p>
<h4 id="新增從子節點到父節點的參考"><a class="header" href="#新增從子節點到父節點的參考">新增從子節點到父節點的參考</a></h4>
<p>要讓子節點意識到它的父節點，我們需要在我們的 <code>Node</code> 結構體定義中加個 <code>parent</code> 欄位。問題在於 <code>parent</code> 應該要是什麼型別。我們知道它不能包含 <code>Rc&lt;T&gt;</code>，因為那就會造成參考循環，<code>leaf.parent</code> 就會指向 <code>branch</code> 且 <code>branch.children</code> 就會指向 <code>leaf</code>，導致同名的 <code>strong_count</code> 數值無法歸零。</p>
<p>讓我們換種方式思考此關係，父節點必須擁有它的子節點，如果父節點釋放的話，它的子節點也應該要被釋放。但子節點不應該擁有它的父節點，如果我們釋放子節點的話，父節點應該要還存在。這就是弱參考的使用時機！</p>
<p>所以與其使用 <code>Rc&lt;T&gt;</code>，我們使用 <code>Weak&lt;T&gt;</code> 來建立 <code>parent</code> 的型別，更明確的話就是 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>。現在我們的 <code>Node</code> 結構體定義看起來會像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf 的父節點 {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf 的父節點 {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<p>節點能夠參考其父節點但不會擁有它。在範例 15-28 中我們更新了 <code>main</code> 來使用新的定義，讓 <code>leaf</code> 節點有辦法參考它的父節點 <code>branch</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf 的父節點 {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf 的父節點 {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">範例 15-28：<code>leaf</code> 節點有其父節點 <code>branch</code> 的弱參考</span></p>
<p>建立 <code>leaf</code> 節點與範例 15-27 類似，只是要多加個 <code>parent</code> 欄位：<code>leaf</code> 一開始沒有任何父節點，所以我們建立一個空的 <code>Weak&lt;Node&gt;</code> 參考實例。</p>
<p>此時當我們透過 <code>upgrade</code> 方法嘗試取得 <code>leaf</code> 的父節點參考的話，我們會取得 <code>None</code> 數值。我們能在輸出結果的第一個 <code>println!</code> 陳述式看到：</p>
<pre><code class="language-text">leaf 的父節點 None
</code></pre>
<p>當我們建立 <code>branch</code> 節點，它的 <code>parent</code> 欄位也會有個新的 <code>Weak&lt;Node&gt;</code> 參考，因為 <code>branch</code> 沒有父節點。我們仍然有 <code>leaf</code> 作為 <code>branch</code> 其中一個子節點。一旦我們有了 <code>branch</code> 的 <code>Node</code> 實例，我們可以修改 <code>leaf</code> 使其擁有父節點的 <code>Weak&lt;Node&gt;</code> 參考。我們對 <code>leaf</code> 中 <code>parent</code> 欄位的 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 使用 <code>borrow_mut</code> 方法，然後我們使用 <code>Rc::downgrade</code> 函式來從 <code>branch</code> 的 <code>Rc&lt;Node&gt;</code> 建立一個 <code>branch</code> 的 <code>Weak&lt;Node&gt;</code> 參考。</p>
<p>當我們再次印出 <code>leaf</code> 的父節點，這次我們就會取得 <code>Some</code> 變體其內就是 <code>branch</code>，現在 <code>leaf</code> 可以取得它的父節點了！當我們印出 <code>leaf</code>，我們也能避免產生像範例 15-26 那樣最終導致堆疊溢位（stack overflow）的循環，<code>Weak&lt;Node&gt;</code> 會印成 <code>(Weak)</code>：</p>
<pre><code class="language-text">leaf 的父節點 Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>沒有無限的輸出代表此程式碼沒有產生參考循環。我們也能透過呼叫 <code>Rc::strong_count</code> 與 <code>Rc::weak_count</code> 的數值看出。</p>
<h4 id="視覺化-strong_count-與-weak_count-的變化"><a class="header" href="#視覺化-strong_count-與-weak_count-的變化">視覺化 <code>strong_count</code> 與 <code>weak_count</code> 的變化</a></h4>
<p>讓我們看看 <code>Rc&lt;Node&gt;</code> 實例中 <code>strong_count</code> 與 <code>weak_count</code> 的數值如何變化，我們建立一個新的內部作用域，並將 <code>branch</code> 的產生移入作用域中。這樣我們就能看到 <code>branch</code> 建立與離開作用域而釋放時發生了什麼事。如範例 15-29 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf 的強參考 = {}、弱參考 = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch 的強參考 = {}、弱參考 = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf 的強參考 = {}、弱參考 = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf 的父節點 {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf 的強參考 = {}、弱參考 = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">範例 15-29：在內部作用域建立 <code>branch</code> 並觀察強與弱參考計數</span></p>
<p>在 <code>leaf</code> 建立後，它的 <code>Rc&lt;Node&gt;</code> 有強計數為 1 與弱計數為 0。在內部作用域中，我們建立了 <code>branch</code> 並與 <code>leaf</code> 做連結，此時當我們印出計數時，<code>branch</code> 的 <code>Rc&lt;Node&gt;</code> 會有強計數為 1 與弱計數為 1（因為 <code>leaf.parent</code> 透過 <code>Weak&lt;Node&gt;</code> 指向 <code>branch</code>）。當我們印出 <code>leaf</code> 的計數時，我們會看到它會有強計數為 2，因為 <code>branch</code> 現在有個 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 克隆儲存在 <code>branch.children</code>，但弱計數仍為 0。</p>
<p>當內部作用域結束時，<code>branch</code> 會離開作用域且 <code>Rc&lt;Node&gt;</code> 的強計數會歸零，所以它的 <code>Node</code> 就會被釋放。<code>leaf.parent</code> 的弱計數 1 與 <code>Node</code> 是否被釋放無關，所以我們沒有產生任何記憶體泄漏！</p>
<p>如果我們嘗試在作用域結束後取得 <code>leaf</code> 的父節點，我們會再次獲得 <code>None</code>。在程式的最後，<code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 強計數為 1 且弱計數為 0，因為變數 <code>leaf</code> 現在是 <code>Rc&lt;Node&gt;</code> 唯一的參考。</p>
<p>所有管理計數與數值釋放都已經實作在 <code>Rc&lt;T&gt;</code> 與 <code>Weak&lt;T&gt;</code>，它們都有 <code>Drop</code> 特的實作。在 <code>Node</code> 的定義中指定子節點對父節點的關係應為 <code>Weak&lt;T&gt;</code> 參考，讓你能夠將父節點與子節點彼此關聯，且不必擔心產生參考循環與記憶體泄漏。</p>
<h2 id="總結-14"><a class="header" href="#總結-14">總結</a></h2>
<p>本章節涵蓋了如何使用智慧指標來得到一些不同於 Rust 預設參考所帶來的保障以及取捨。<code>Box&lt;T&gt;</code> 型別有已知大小並能將資料分配到堆積上。<code>Rc&lt;T&gt;</code> 型別會追蹤堆積上資料的參考數量，讓該資料能有數個擁有者。<code>RefCell&lt;T&gt;</code> 型別具有內部可變性，提供一個外部不可變的型別，但有方法可以改變內部數值，它會在執行時強制檢測借用規則，而非編譯時。</p>
<p>我們也討論了 <code>Deref</code> 與 <code>Drop</code> 特徵，這些對智慧指標提供了許多功能。我們探討了參考循環可能會導致記憶體泄漏以及如何使用 <code>Weak&lt;T&gt;</code> 避免它們。</p>
<p>如果本章節引起你的興趣，讓你想要實作你自己的智慧指標的話，歡迎查閱<a href="https://doc.rust-lang.org/nomicon/">「The Rustonomicon」</a>來學習更多實用資訊。</p>
<p>接下來，我們將討論 Rust 的並行性。你還會再學到一些新的智慧指標。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="無懼並行"><a class="header" href="#無懼並行">無懼並行</a></h1>
<p>能夠安全高效處理並行程式設計是 Rust 的另一項主要目標。<strong>並行程式設計</strong>（Concurrent programming）會讓程式的不同部分獨立執行，而<strong>平行程式設計</strong>（parallel programming）則是程式的不同部分同時執行。這些隨著電腦越能善用多處理器時也越顯得重要。歷史上，這種程式設計是很困難且容易出錯的，Rust 希望能改善這點。</p>
<p>起初 Rust 團隊認為確保記憶體安全與預防並行問題是兩個分別的問題，要用不同的解決方案。隨著時間過去，團隊發現所有權與型別系統同時是管理記憶體安全<strong>以及</strong>並行問題的強大工具！透過藉助所有權與型別檢查，許多並行錯誤在 Rust 中都是編譯時錯誤而非執行時錯誤。因此，你不用花大量時間嘗試重現編譯時並行錯誤出現時的特定情況，不正確的程式碼會在編譯時就被拒絕，並顯示錯誤解釋問題原因。這樣一來，你就可以在開發時就修正問題，而不用等到可能都部署到生產環境了才發現問題。我們稱呼這個 Rust 的特色為<strong>無懼並行（fearless concurrency）</strong>。無懼並行可以避免你寫出有微妙錯誤的程式碼，並能輕鬆重構，不用擔心產生新的程式錯誤。</p>
<blockquote>
<p>注意：出於簡潔考量，我們將把許多問題歸類為<strong>並行</strong>，而不是精確地區分是<strong>並行與／或平行</strong>。如果本書是本專注在並行與/或平行的書，我們才會更在意用詞。至於本章節，當我們使用<strong>並行</strong>的詞彙時，請記得這代表 <strong>並行與／或平行</strong>。</p>
</blockquote>
<p>許多語言對於處理並行問題所提供的解決方案都很有特色。舉例來說，Erlang 有非常優雅的訊息傳遞並行功能，但跨執行緒共享狀態就只有比較隱晦的方法。只提供支援可能解決方案的子集對於高階語言來說是合理的策略，因為高階語言所承諾的效益來自於犧牲一些掌控以換取大量的抽象層面。然而，低階語言則預期會提供在任何給定場合中能有最佳效能的解決方案，而且對硬體的抽象較少。因此 Rust 提供了多種工具來針對適合你的場合與需求將問題定義出來。</p>
<p>本章節中我們會涵蓋這些主題：</p>
<ul>
<li>如何建立執行緒（threads）來同時執行多段程式碼</li>
<li><strong>訊息傳遞</strong>（Message-passing）並行提供通道（channels）在執行緒間傳遞訊息</li>
<li><strong>共享狀態</strong>（Shared-state）並行提供多執行緒可以存取同一位置的資料</li>
<li><code>Sync</code> 與 <code>Send</code> 特徵擴展 Rust 的並行保障至使用者定義的型別與標準函式庫的型別中</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用執行緒同時執行程式碼"><a class="header" href="#使用執行緒同時執行程式碼">使用執行緒同時執行程式碼</a></h2>
<p>在大部分的現代作業系統中，被執行的程式碼會在<strong>程序（process）<strong>中執行，作業系統會負責同時處理數個程序。在你的程式中，你也可以將各自獨立的部分同時執行。執行這些獨立部分的功能就叫做</strong>執行緒（threads）</strong>。舉例來說，一個網路伺服器可以有數個執行緒來同時回應一個以上的請求。</p>
<p>將程式中的運算拆成數個執行緒可以提升效能，不過這也同時增加了複雜度。因為執行緒可以同時執行，所以無法保證不同執行緒的程式碼執行的順序。這會導致以下問題：</p>
<ul>
<li>競爭條件（Race conditions）：數個執行緒以不一致的順序取得資料或資源</li>
<li>死結（Deadlocks）：兩個執行緒彼此都在等待對方，因而讓執行緒無法繼續執行</li>
<li>只在特定情形會發生的程式錯誤，並難以重現與穩定修復</li>
</ul>
<p>Rust 嘗試降低使用執行緒所帶來的負面效果，不過對於多執行緒程式設計還是得格外小心，其所要求的程式結構也與單一執行緒的程式有所不同。</p>
<p>不同程式語言會以不同的方式實作執行緒，許多作業系統都有提供 API 來建立新的執行緒。Rust 標準函式庫使用的是 <em>1:1</em> 的執行緒實作模型，也就是每一個語言產生的執行緒就是一個作業系統的執行緒。有其他 crate 會實作其他種執行緒模型，讓我們能與 1:1 模型之間做取捨。</p>
<h3 id="透過-spawn-建立新的執行緒"><a class="header" href="#透過-spawn-建立新的執行緒">透過 <code>spawn</code> 建立新的執行緒</a></h3>
<p>要建立一個新的執行緒，我們呼叫函式 <code>thread::spawn</code> 並傳入一個閉包（我們在第十三章談過閉包），其包含我們想在新執行緒執行的程式碼。範例 16-1 會在主執行緒印出一些文字，並在新執行緒印出其他文字：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;數字 {} 出現在產生的執行緒中！&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;數字 {} 出現在主執行緒中！&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">範例 16-1：建立一個會印出一些字的新執行緒，而主執行緒會印出其他字</span></p>
<p>注意到當 Rust 程式的主執行緒完成的話，所有執行緒也會被停止，無論它有沒有完成任務。此程式的輸出結果每次可能都會有點不相同，但它會類似以下這樣：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">數字 1 出現在主執行緒中！
數字 1 出現在產生的執行緒中！
數字 2 出現在主執行緒中！
數字 2 出現在產生的執行緒中！
數字 3 出現在主執行緒中！
數字 3 出現在產生的執行緒中！
數字 4 出現在主執行緒中！
數字 4 出現在產生的執行緒中！
數字 5 出現在產生的執行緒中！
</code></pre>
<p><code>thread::sleep</code> 的呼叫強制執行緒短時間內停止運作，讓不同的執行緒可以執行。執行緒可能會輪流執行，但並不保證絕對如此，這會依據你的作業系統如何安排執行緒而有所不同。在這一輪中，主執行緒會先顯示，就算程式中是先寫新執行緒的 <code>println!</code> 陳述式。而且雖然我們是寫說新執行緒印出 <code>i</code> 一直到 9，但它在主執行緒結束前只印到 5。</p>
<p>如果當你執行此程式時只看到主執行緒的結果，或者沒有看到任何交錯的話，你可以嘗試增加數字範圍來增加作業系統切換執行緒的機會。</p>
<h3 id="使用-join-等待所有執行緒完成"><a class="header" href="#使用-join-等待所有執行緒完成">使用 <code>join</code> 等待所有執行緒完成</a></h3>
<p>範例 16-1 的程式碼在主執行緒結束時不只會在大多數的時候提早結束新產生的執行緒，還不能保證執行緒運行的順序，我們甚至無法保證產生的執行序真的會執行！</p>
<p>透過儲存 <code>thread::spawn</code> 回傳的數值為變數，我們可以修正產生的執行緒完全沒有執行或沒有執行完成的問題。<code>thread::spawn</code> 的回傳型別為 <code>JoinHandle</code>。<code>JoinHandle</code> 是個有所有權的數值，當我們對它呼叫 <code>join</code> 方法時，它就會等待它的執行緒完成。範例 16-2 顯示了如何使用我們在範例 16-1 中執行緒的 <code>JoinHandle</code> 並呼叫 <code>join</code> 來確保產生的執行緒會在 <code>main</code> 離開之前完成：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;數字 {} 出現在產生的執行緒中！&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;數字 {} 出現在主執行緒中！&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 16-2：從 <code>thread::spawn</code> 儲存 <code>JoinHandle</code> 以保障執行緒能執行完成</span></p>
<p>對其呼叫 <code>join</code> 會阻擋當前正在執行的執行緒中直到 <code>JoinHandle</code> 的執行緒結束為止。<strong>阻擋</strong>（Blocking）一條執行緒代表該執行緒不會繼續運作或離開。因為我們在主執行緒的 <code>for</code> 迴圈之後加上了 <code>join</code> 的呼叫，範例 16-2 應該會產生類似以下的輸出：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">數字 1 出現在主執行緒中！
數字 2 出現在主執行緒中！
數字 1 出現在產生的執行緒中！
數字 3 出現在主執行緒中！
數字 2 出現在產生的執行緒中！
數字 4 出現在主執行緒中！
數字 3 出現在產生的執行緒中！
數字 4 出現在產生的執行緒中！
數字 5 出現在產生的執行緒中！
數字 6 出現在產生的執行緒中！
數字 7 出現在產生的執行緒中！
數字 8 出現在產生的執行緒中！
數字 9 出現在產生的執行緒中！
</code></pre>
<p>兩條執行緒會互相交錯，但是主執行緒這次會因為 <code>handle.join()</code> 而等待，直到產生的執行緒完成前都不會結束。</p>
<p>那如果我們如以下這樣將 <code>handle.join()</code> 移到 <code>main</code> 中的 <code>for</code> 迴圈前會發生什麼事呢：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;數字 {} 出現在產生的執行緒中！&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;數字 {} 出現在主執行緒中！&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>主執行緒會等待產生的執行緒完成才會執行它的 <code>for</code> 迴圈，所以輸出結果就不會彼此交錯，如以下所示：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">數字 1 出現在產生的執行緒中！
數字 2 出現在產生的執行緒中！
數字 3 出現在產生的執行緒中！
數字 4 出現在產生的執行緒中！
數字 5 出現在產生的執行緒中！
數字 6 出現在產生的執行緒中！
數字 7 出現在產生的執行緒中！
數字 8 出現在產生的執行緒中！
數字 9 出現在產生的執行緒中！
數字 1 出現在主執行緒中！
數字 2 出現在主執行緒中！
數字 3 出現在主執行緒中！
數字 4 出現在主執行緒中！
</code></pre>
<p>像這樣將 <code>join</code> 呼叫置於何處的小細節，會影響你的執行緒會不會同時運行。</p>
<h3 id="透過執行緒使用-move-閉包"><a class="header" href="#透過執行緒使用-move-閉包">透過執行緒使用 <code>move</code> 閉包</a></h3>
<p>我們通常會使用 <code>thread::spawn</code> 時都會搭配有 <code>move</code> 關鍵字的閉包，因為該閉包能獲取周圍環境的數值，轉移那些數值的所有權到另一個執行緒中。在第十三章的<a href="ch13-01-closures.html#%E7%8D%B2%E5%8F%96%E5%8F%83%E8%80%83%E6%88%96%E7%A7%BB%E5%8B%95%E6%89%80%E6%9C%89%E6%AC%8A">「獲取參考或移動所有權」</a><!-- ignore-->段落我們討論過閉包如何運用 <code>move</code>。現在我們會來專注在 <code>move</code> 與 <code>thread::spawn</code> 之間如何互動。</p>
<p>在第十三章中，我們提到我們可以在閉包參數列表前使用 <code>move</code> 關鍵字來強制閉包取得其從環境獲取數值的所有權。此技巧在建立新的執行緒特別有用，讓我們可以從一個執行緒轉移數值所有權到另一個執行緒。</p>
<p>注意到範例 16-1 中我們傳入 <code>thread::spawn</code> 的閉包沒有任何引數，我們在產生的執行緒程式碼內沒有使用主執行緒的任何資料。要在產生的執行緒中使用主執行緒的資料的話，產生的執行緒閉包必須獲取它所需的資料。範例 16-3 嘗試在主執行緒建立一個向量並在產生的執行緒使用它。不過這目前無法執行，你會在稍後知道原因。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;這是個向量：{:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">範例 16-3：嘗試在其他執行緒使用主執行緒建立的向量</span></p>
<p>閉包想使用 <code>v</code>，所以它得獲取 <code>v</code> 並使其成為閉包環境的一部分。因為 <code>thread::spawn</code> 會在新的執行緒執行此閉包，我們要能在新的執行緒內存取 <code>v</code>。但當我們編譯此範例時，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;這是個向量：{:?}&quot;, v);
  |                                    - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;這是個向量：{:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust 會<strong>推斷</strong>如何獲取 <code>v</code> 而且因為 <code>println!</code> 只需要 <code>v</code> 的參考，閉包得借用 <code>v</code>。不過這會有個問題，Rust 無法知道產生的執行緒會執行多久，所以它無法確定 <code>v</code> 的參考是不是永遠有效。</p>
<p>範例 16-4 提供了一個情境讓 <code>v</code> 很有可能不再有效：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;這是個向量：{:?}&quot;, v);
    });

    drop(v); // 喔不！

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">範例 16-4：執行緒的閉包嘗試獲取 <code>v</code> 的參考，但主執行緒會釋放 <code>v</code></span></p>
<p>如果 Rust 允許執行此程式碼，產生的執行緒是有可能會置於背景而沒有馬上執行。產生的執行緒內部有 <code>v</code> 的參考，但主執行緒會立即釋放 <code>v</code>，使用我們在第十五章討論過的 <code>drop</code> 函式。然後當產生的執行緒開始執行時，<code>v</code> 就不再有效了，所以它的參考也是無效的了。喔不！</p>
<p>要修正範例 16-3 的編譯錯誤，我們可以使用錯誤訊息的建議：</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
</code></pre>
<p>透過在閉包前面加上 <code>move</code> 關鍵字，我們強制讓閉包取得它所要使用數值的所有權，而非任由 Rust 去推斷它是否該借用數值。範例 16-5 修改了範例 16-3 並能夠如期編譯與執行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;這是個向量：{:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 16-5：使用 <code>move</code> 關鍵字強制閉包取得它所使用數值的所有權</span></p>
<p>我們可能會想嘗試用範例 16-4 做的事來修正程式碼，使用 <code>move</code> 閉包的同時在主執行緒呼叫 <code>drop</code>。但這樣的修正沒有用，因為範例 16-4 想做的事情會因為不同原因而不被允許。如果我們對閉包加上了 <code>move</code>，我們將會把 <code>v</code> 移入閉包環境，而在主執行緒將無法再對它呼叫 <code>drop</code> 了。我們會得到另一個編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;這是個向量：{:?}&quot;, v);
   |                                    - variable moved due to use in closure
...
10 |     drop(v); // 喔不！
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust 的所有權規則再次拯救了我們！我們在範例 16-3 會得到錯誤是因為 Rust 是保守的，所以只會為執行緒借用 <code>v</code>，這代表主執行緒理論上可能會使產生的執行緒的參考無效化。透過告訴 Rust 將 <code>v</code> 的所有權移入產生的執行緒中，我們向 Rust 保證不會在主執行緒用到 <code>v</code>。如果我們用相同方式修改範例 16-4 的話，當我們嘗試在主執行緒使用 <code>v</code> 的話，我們就違反了所有權規則。<code>move</code> 關鍵字會覆蓋 Rust 保守的預設借用行為，且也不允許我們違反所有權規則。</p>
<p>有了對執行緒與執行緒 API 的基本瞭解，讓我們看看我們可以透過執行緒<strong>做些</strong>什麼。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用訊息傳遞在執行緒間傳送資料"><a class="header" href="#使用訊息傳遞在執行緒間傳送資料">使用訊息傳遞在執行緒間傳送資料</a></h2>
<p>有一種確保安全並行且漸漸流行起來的方式是<strong>訊息傳遞（message passing）</strong>，執行緒或 actors 透過傳遞包含資料的訊息給彼此來溝通。此理念源自於 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 語言技術文件</a>中的口號：「別透過共享記憶體來溝通，而是透過溝通來共享記憶體。」 </p>
<p>對於訊息傳遞的並行，Rust 的標準函式庫有提供<strong>通道</strong>（channel）的實作。通道是一種程式設計的概念，會把資料從一個執行緒傳送到另一個。</p>
<p>你可以把程式設計的通道想像成水流的通道，像是河流或小溪。如果你將橡皮小鴨或船隻放入河流中，它會順流而下到下游。</p>
<p>一個通道會包含兩個部分：發送者（transmitter）與接收者（receiver）。發送者正是你會放置橡皮小鴨到河流中的上游，而接收者則是橡皮小鴨最後漂流到的下游。你程式碼中的一部分會呼叫發送者的方法來傳送你想要傳遞的資料，然後另一部分的程式碼會檢查接收者收到的訊息。當發送者或接收者有一方被釋放掉時，該通道就會被<strong>關閉</strong>。</p>
<p>我們在此將寫一支程式，它會在一個執行緒中產生數值，傳送給通道，然後另一個執行緒會接收到數值並印出來。我們會使用通道在執行緒間傳送簡單的數值來作為這個功能的解說。一旦你熟悉此技巧後，你可以使用通道讓執行緒間可以互相溝通。像是實作個聊天系統，或是一個利用數個執行緒進行運算，然後將結果傳入一個執行緒統整結果的分散式系統。</p>
<p>首先在範例 16 -6，我們會建立個通道但還不會做任何事。注意這樣不會編譯通過因為 Rust 無法知道我們想對通道傳入的數值型別為何。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<p><span class="caption">範例 16-6：建立通道並賦值分別兩個部分給 <code>tx</code> 與 <code>rx</code></span></p>
<p>我們使用 <code>mpsc::channel</code> 函式來建立新的通道，<code>mpsc</code> 指的是<strong>多重生產者、唯一消費者（multiple producer, single consumer）</strong>。簡單來說，Rust 標準函式庫實作通道的方式讓通道可以有多個<strong>發送端</strong>來產生數值，不過只有一個<strong>接收端</strong>能消耗這些數值。想像有數個溪流匯聚成一條大河流，任何溪流傳送的任何東西最終都會流向河流的下游。我們會先從單一生產者開始，等這個範例能夠執行後我們再來增加數個生產者。</p>
<p><code>mpsc::channel</code> 函式會回傳一個元組，第一個元素是發送者然後第二個元素是接收者。<code>tx</code> 與 <code>rx</code> 通常分別作為<strong>發送者</strong>（transmitter）與<strong>接收者</strong>（receiver）的縮寫，所以我們以此作為我們的變數名稱。我們的 <code>let</code> 陳述式使用到了能解構元組的模式我們會在第十八章討論 <code>let</code> 陳述式的模式與解構方式。用這樣的方式使用 <code>let</code> 能輕鬆取出 <code>mpsc::channel</code> 回傳的元組每個部分。</p>
<p>讓我們將發送端移進一個新產生的執行緒並讓它傳送一條字串，這樣產生的執行緒就可以與主執行緒溝通了，如範例 16-7 所示。這就像是在河流上游放了一隻橡皮小鴨，或是從一條執行緒傳送一條聊天訊息給別條執行緒一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;嗨&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">範例 16-7：將 <code>tx</code> 移入產生的執行緒並傳送「hi」</span></p>
<p>我們再次使用 <code>thread::spawn</code> 來建立新的執行緒並使用 <code>move</code> 將 <code>tx</code> 移入閉包，讓產生的執行緒擁有 <code>tx</code>。產生的執行緒必須要擁有發送者才能夠傳送訊息至通道。發送端有個 <code>send</code> 方法可以接受我們想傳遞的數值。<code>send</code> 方法會回傳 <code>Result&lt;T, E&gt;</code> 型別，所以如果接收端已經被釋放因而沒有任何地方可以傳遞數值的話，傳送的動作就會回傳錯誤。在此例中，我們呼叫 <code>unwrap</code> 所以有錯誤時就會直接恐慌。但在實際的應用程式中，我們會更妥善地處理它，你可以回顧第九章來複習如何適當地處理錯誤。</p>
<p>在範例 16-8 我們會在主執行緒中從接收者取得數值。這就像在河流下游取回順流而下的橡皮小鴨，或是像取得一條聊天訊息一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;嗨&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;取得：{}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">範例 16-8：在主執行緒取得數值「hi」並顯示出來</span></p>
<p>接收者有兩個實用的方法：<code>recv</code> 與 <code>try_recv</code>。我們使用 <code>recv</code> 作為<strong>接收</strong>（receive）的縮寫，這會阻擋主執行緒的運行並等待直到通道有訊息傳入。一旦有數值傳遞，<code>recv</code> 會就以此回傳 <code>Result&lt;T, E&gt;</code>。當發送者關閉時，<code>recv</code> 會回傳錯誤來通知不會再有任何數值出現了。</p>
<p><code>try_recv</code> 方法則不會阻擋，而是會立即回傳 <code>Result&lt;T, E&gt;</code>。如果有數值的話，就會是存有訊息的 <code>Ok</code> 數值，如果尚未有任何數值的話，就會是 <code>Err</code> 數值。<code>try_recv</code> 適用於如果此執行緒在等待訊息的同時有其他事要做的情形。我們可以寫個迴圈來時不時呼叫 <code>try_recv</code>，當有數值時處理訊息，不然的話就先做點其他事直到再次檢查為止。</p>
<p>我們出於方便考量在此例使用 <code>recv</code>，我們的主執行緒除了等待訊息以外沒有其他事好做，所以阻擋主執行緒是合理的。</p>
<p>當我們執行範例 16-8 的程式碼，我們會看到主執行緒印出的數值：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">取得：嗨
</code></pre>
<p>太棒了！</p>
<h3 id="通道與所有權轉移"><a class="header" href="#通道與所有權轉移">通道與所有權轉移</a></h3>
<p>所有權規則在訊息傳遞中扮演了重要的角色，因為它們可以幫助你寫出安全的並行程式碼。在 Rust 程式中考慮所有權的其中一項好處就是你能在並行程式設計避免錯誤發生。讓我們做個實驗來看通道與所有權如何一起合作來避免問題發生，我們會在 <code>val</code> 數值傳送給通道<strong>之後</strong>嘗試使用其值。請嘗試編譯範例 16-9 的程式碼並看看為何此程式碼不被允許：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;嗨&quot;);
        tx.send(val).unwrap();
        println!(&quot;val 為 {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;取得：{}&quot;, received);
}
</code></pre>
<p><span class="caption">範例 16-9：在我們將 <code>val</code> 傳入通道後嘗試使用其值</span></p>
<p>我們在這裡透過 <code>tx.send</code> 將 <code>val</code> 傳入通道之後嘗試印出其值。允許這麼做的話會是個壞主意，一旦數值被傳至其他執行緒，該執行緒就可以在我們嘗試再次使用該值之前修改或釋放其值。其他執行緒的修改有機會因為不一致或不存在的資料而導致錯誤或意料之外的結果。不過如果我試著編譯範例 16-9 的程式碼的話，Rust 會給我們一個錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;嗨&quot;);
   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val 為 {}&quot;, val);
   |                               ^^^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing` due to previous error
</code></pre>
<p>我們的並行錯誤產生了一個編譯時錯誤。<code>send</code> 函式會取走其參數的所有權，並當數值移動時，接收端會再取得其所有權。這能阻止我們在傳送數值過後不小心再次使用其值，所有權系統會檢查一切是否符合規則。</p>
<h3 id="傳送多重數值並觀察接收者等待"><a class="header" href="#傳送多重數值並觀察接收者等待">傳送多重數值並觀察接收者等待</a></h3>
<p>範例 16-8 的程式碼可以編譯通過並執行，但它並沒有清楚表達出兩個不同的執行緒正透過通道彼此溝通。在範例 16-10 中我們做了些修改來證明範例 16-8 的程式有正確執行，產生的執行緒現在會傳送數個訊息，並在每個訊息間暫停個一秒鐘。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust noplayground">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;執行緒&quot;),
            String::from(&quot;傳來&quot;),
            String::from(&quot;的&quot;),
            String::from(&quot;嗨&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;取得：{}&quot;, received);
    }
}
</code></pre>
<p><span class="caption">範例 16-10：傳送數個訊息並在之間暫停片刻</span></p>
<p>這次產生的執行緒有個字串向量，我們希望能傳送它們到主執行緒中。我們遍歷它們，單獨傳送每個值，然後透過 <code>Duration</code> 數值呼叫 <code>thread::sleep</code> 來暫停一秒。</p>
<p>在主執行緒中，我們不再顯式呼叫 <code>recv</code> 函式，我們改將 <code>rx</code> 作為疊代器使用。對每個接收到的數值，我們印出它。當通道關閉時，疊代器就會結束。</p>
<p>當執行範例 16-10 的程式碼，你應該會看到以下輸出，每一行會間隔一秒鐘：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">取得：執行緒
取得：傳來
取得：的
取得：嗨
</code></pre>
<p>因為我們在主執行緒中的 <code>for</code> 迴圈內沒有任何會暫停或延遲的程式碼，所以我們可以看出主執行緒是在等待產生的執行緒傳送的數值。</p>
<h3 id="透過克隆發送者來建立多重生產者"><a class="header" href="#透過克隆發送者來建立多重生產者">透過克隆發送者來建立多重生產者</a></h3>
<p>稍早之前我們提過 <code>mpsc</code> 是<strong>多重生產者、唯一消費者</strong>（multiple producer, single consumer）的縮寫。讓我們來使用 <code>mpsc</code> 並擴展範例 16-10 的程式碼來建立數個執行緒，它們都將傳遞數值給同個接收者。為此我們可以克隆發送者，如範例 16-11 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --省略--

    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;執行緒&quot;),
            String::from(&quot;傳來&quot;),
            String::from(&quot;的&quot;),
            String::from(&quot;嗨&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;更多&quot;),
            String::from(&quot;給你&quot;),
            String::from(&quot;的&quot;),
            String::from(&quot;訊息&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;取得：{}&quot;, received);
    }

    // --省略--
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 16-11：從多重生產者傳遞數個訊息</span></p>
<p>這次在我們建立第一個產生的執行緒前，我們會對發送者呼叫 <code>clone</code>。這能給我們一個新的發送者，讓我們可以移入第一個產生的執行緒。接著我們將原本的通道發送端移入第二個產生的執行緒中。這樣我們就有了兩條執行緒，每條都能傳送不同的訊息給接收者。</p>
<p>當你執行程式碼時，你的輸出應該會類似以下結果：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">取得：執行緒
取得：更多
取得：傳來
取得：給你
取得：的
取得：的
取得：嗨
取得：訊息
</code></pre>
<p>依據你的系統你可能會看到數值以不同順序排序。這正是並行程式設計既有趣卻又困難的地方。如果你加上 <code>thread::sleep</code> 來實驗，並在不同執行緒給予不同數值的話，就會發現每一輪都會更不確定，每次都會產生不同的輸出結果。</p>
<p>現在我們已經看完通道如何運作，接著讓我們來看看並行的不同方法吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="共享狀態並行"><a class="header" href="#共享狀態並行">共享狀態並行</a></h2>
<p>雖然我們之前說過 Go 語言技術文件中的口號：「別透過共享記憶體來溝通。」而訊息傳遞是個很好的並行處理方式，但它不是唯一的選項。另一種方式就是在多重執行緒間共享資料。</p>
<p>透過共享記憶體來溝通會是什麼樣子呢？除此之外，為何訊息傳遞愛好者不喜歡這種共享記憶體的方式呢？</p>
<p>任何程式語言的通道某方面來說類似於單一所有權，因為一旦你轉移數值給通道，你就不該使用該數值。共享記憶體並行則像多重所有權，數個執行緒可以同時存取同個記憶體位置。如同你在第十五章所見到的，智慧指標讓多重所有權成為可能，但多重所有權會增加複雜度，因為我們會需要管理這些不同的擁有者。Rust 的型別系統與所有權規則大幅地協助了正確管理這些所有權。作為範例就讓我們看看互斥鎖（mutexes），這是共享記憶體中常見的並行原始元件之一。</p>
<h3 id="使用互斥鎖在同時間只允許一條執行緒存取資料"><a class="header" href="#使用互斥鎖在同時間只允許一條執行緒存取資料">使用互斥鎖在同時間只允許一條執行緒存取資料</a></h3>
<p><strong>互斥鎖</strong>（Mutex）是 <em>mutual exclusion</em> 的縮寫，顧名思義互斥鎖在任意時刻只允許一條執行緒可以存取一些資料。要取得互斥鎖中的資料，執行緒必須先透過獲取互斥鎖的<strong>鎖（lock）<strong>來表示它想要進行存取。鎖是互斥鎖其中一部分的資料結構，用來追蹤當前誰擁有資料的獨佔存取權。因此互斥鎖被描述為會透過鎖定系統</strong>守護</strong>（guarding）其所持有的資料。</p>
<p>互斥鎖以難以使用著名，因為你必須記住兩個規則：</p>
<ul>
<li>你必須在使用資料前獲取鎖。</li>
<li>當你用完互斥鎖守護的資料，你必須解鎖資料，所以其他的執行緒才能獲取鎖。</li>
</ul>
<p>要用真實世界來比喻互斥鎖的話，想像在會議中有個座談會只有一支麥克風。如果有講者想要發言時，他們需要請求或示意他們想要使用麥克風。當他們取得麥克風時，他們想講多久都沒問題，直到將麥克風遞給下個要求發言的講者。如果講者講完後忘記將麥克風遞給其他人的話，就沒有人有辦法發言。如果麥克風的分享出狀況的話，座談會就無法如期進行！</p>
<p>互斥鎖的管理要正確處理是極為困難的，這也是為何這麼多人傾向於使用通道。然而有了 Rust 的型別系統與所有權規則，你就不會在鎖定與解鎖之間出錯了。</p>
<h4 id="mutext-的-api"><a class="header" href="#mutext-的-api"><code>Mutex&lt;T&gt;</code> 的 API</a></h4>
<p>作為使用互斥鎖的範例，讓我們先在單執行緒使用互斥鎖，如範例 16-12 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">範例 16-12：基於簡便考量先用單一執行緒探討 <code>Mutex&lt;T&gt;</code> 的 API</span></p>
<p>就像許多型別一樣，我們使用關聯函式 <code>new</code> 建立 <code>Mutex&lt;T&gt;</code>。要取得互斥鎖內的資料，我們使用 <code>lock</code> 方法來獲取鎖。此呼叫會阻擋當前執行緒做任何事，直到輪到它取得鎖。</p>
<p>如果其他持有鎖的執行緒恐慌的話 <code>lock</code> 的呼叫就會失敗。在這樣的情況下，就沒有任何人可以獲得鎖，因此當我們遇到這種情況時，我們選擇 <code>unwrap</code> 並讓此執行緒恐慌。</p>
<p>在我們獲取鎖之後，我們在此例可以將回傳的數值取作 <code>num</code>，作為內部資料的可變參考。型別系統能確保我們在使用數值 <code>m</code> 之前有獲取鎖，<code>Mutex&lt;i32&gt;</code> 並不是 <code>i32</code>，所以我們<strong>必須</strong>取得鎖才能使用 <code>i32</code> 數值。我們不可能會忘記這麼做，不然型別系統不會讓我們存取內部的 <code>i32</code>。</p>
<p>如同你所想像的，<code>Mutex&lt;T&gt;</code> 就是個智慧指標。更精確的來說，<code>lock</code> 的呼叫會<strong>回傳</strong>一個智慧指標叫做 <code>MutexGuard</code>，這是我們從 <code>LockResult</code> 呼叫 <code>unwrap</code> 取得的型別。<code>MutexGuard</code> 智慧指標有實作 <code>Deref</code> 特徵來指向我們的內部資料。此智慧指標也有 <code>Drop</code> 的實作，這會在 <code>MutexGuard</code> 離開作用域時自動釋放鎖，也就是在內部作用域結尾就會執行此動作。這樣一來，我們就不會忘記釋放鎖，怕互斥鎖會阻擋其他執行緒，因為鎖會自動被釋放。</p>
<p>在釋放鎖之後，我們就能印出互斥鎖的數值並觀察到我們能夠變更內部的 <code>i32</code> 為 6。</p>
<h4 id="在數個執行緒間共享-mutext"><a class="header" href="#在數個執行緒間共享-mutext">在數個執行緒間共享 <code>Mutex&lt;T&gt;</code></a></h4>
<p>現在讓我們來透過 <code>Mutex&lt;T&gt;</code> 來在數個執行緒間分享數值。我們會建立 10 個執行緒並讓它們都會對一個計數增加 1，讓計數能從 0 加到 10。作為下個例子的範例 16-13 會出現一個編譯錯誤，我們會用此錯誤瞭解如何使用 <code>Mutex&lt;T&gt;</code> 以及 Rust 如何協助我們來正確使用它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;結果：{}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">範例 16-13：十個執行緒都會對 <code>Mutex&lt;T&gt;</code> 守護的計數增加 1</span></p>
<p>我們建立個變數 <code>counter</code> 並在 <code>Mutex&lt;T&gt;</code> 內存有 <code>i32</code>，就像我們在範例 16-12 所做的一樣。接著我們透過指定的範圍建立 10 個執行緒。我們使用 <code>thread::spawn</code> 讓所有的執行緒都有相同的閉包，此閉包會將計數移入執行緒、呼叫 <code>lock</code> 以獲取 <code>Mutex&lt;T&gt;</code> 的鎖，然後將互斥鎖內的數值加 1。當有執行緒執行完它的閉包時，<code>num</code> 會離開作用域並釋放鎖，讓其他的執行緒可以獲取它。</p>
<p>在主執行緒中，我們要收集所有的執行緒。然後如同我們在範例 16-2 所做的，我們呼叫每個執行緒的 <code>join</code> 來確保所有執行緒都有完成。在這時候，主執行緒就能獲取鎖並印出此程式的結果。</p>
<p>我們曾暗示範例不會編譯過，讓我們看看是為何吧！</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>錯誤訊息表示 <code>counter</code> 數值在之前的迴圈循環中被移動了，所以 Rust 告訴我們我們無法將 <code>counter</code> 鎖的所有權移至數個執行緒中。讓我們用第十五章提到的多重所有權方法來修正此編譯錯誤吧。</p>
<h4 id="多重執行緒中的多重所有權"><a class="header" href="#多重執行緒中的多重所有權">多重執行緒中的多重所有權</a></h4>
<p>在第十五章中，我們透過智慧指標 <code>Rc&lt;T&gt;</code> 來建立參考計數數值讓該資料可以擁有數個擁有者。讓我們在此也做同樣的動作來看看會發生什麼事。我們會在範例 16-14 將 <code>Mutex&lt;T&gt;</code> 封裝進 <code>Rc&lt;T&gt;</code> 並在將所有權移至執行緒前克隆 <code>Rc&lt;T&gt;</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;結果：{}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">範例 16-14：嘗試使用 <code>Rc&lt;T&gt;</code> 來允許數個執行緒擁有 <code>Mutex&lt;T&gt;</code></span></p>
<p>再編譯一次的話我們會得到... 不同的錯誤！編譯器真的是教了我們很多事。</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:36
   |
11 |           let handle = thread::spawn(move || {
   |                        ------------- ^------
   |                        |             |
   |  ______________________|_____________within this `[closure@src/main.rs:11:36: 11:43]`
   | |                      |
   | |                      required by a bound introduced by this call
12 | |             let mut num = counter.lock().unwrap();
13 | |
14 | |             *num += 1;
15 | |         });
   | |_________^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 11:43]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
note: required because it's used within this closure
  --&gt; src/main.rs:11:36
   |
11 |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^
note: required by a bound in `spawn`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>哇，這個錯誤訊息的內容真多！這是我們需要注意到的部分：<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。編譯器也告訴了我們原因：<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>。我們會在下一個段落討論 <code>Send</code>，這是其中一種確保我們在執行緒中所使用的型別可以用於並行場合的特徵。</p>
<p>不幸的是 <code>Rc&lt;T&gt;</code> 無法安全地跨執行緒分享。當 <code>Rc&lt;T&gt;</code> 管理參考計數時，它會在每個 <code>clone</code> 的呼叫增加計數，並在每個克隆釋放時減少計數。但是它沒有使用任何並行原始元件來確保計數的改變不會被其他執行緒中斷。這樣的計數可能會導致微妙的程式錯誤，像是記憶體泄漏或是在數值釋放時嘗試使用其值。我們需要一個型別和 <code>Rc&lt;T&gt;</code> 一模一樣，但是其參考計數在執行緒間是安全的。</p>
<h4 id="原子參考計數-arct"><a class="header" href="#原子參考計數-arct">原子參考計數 <code>Arc&lt;T&gt;</code></a></h4>
<p>幸運的是 <code>Arc&lt;T&gt;</code> <strong>正是</strong>一個類似 <code>Rc&lt;T&gt;</code> 且能安全用在並行場合的型別。字母 <em>A</em> 指的是<strong>原子性</strong>（atomic）代表這是個<strong>原子性參考的計數</strong>型別。原子型別是另一種我們不會在此討論的並行原始元件，你可以查閱標準函式庫的 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> 技術文件以瞭解更多詳情。在此你只需要知道原子型別和原始型別類似，但它們可以安全在執行緒間共享。</p>
<p>你可能會好奇為何原始型別不是原子性的，以及為何標準函式庫的型別預設不使用 <code>Arc&lt;T&gt;</code> 來實作。原因是因為執行緒安全意味著效能開銷，你會希望在你真的需要時才買單。如果你只是在單一執行緒對數值做運算的話，你的程式碼就不必強制具有原子性的保障並能執行地更快。</p>
<p>讓我們回到我們的範例：<code>Arc&lt;T&gt;</code> 與 <code>Rc&lt;T&gt;</code> 具有相同的 API，所以我們透過更改 <code>use</code> 這行、<code>new</code> 的呼叫以及 <code>clone</code> 的呼叫來修正我們程式，。範例 16-15 的程式碼最終將能夠編譯並執行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;結果：{}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">範例 16-15：使用 <code>Arc&lt;T&gt;</code> 封裝 <code>Mutex&lt;T&gt;</code> 來在數個執行緒間分享所有權</span></p>
<p>此程式碼會印出以下結果：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">結果：10
</code></pre>
<p>我們辦到了！我們從 0 數到了 10，雖然看起來不是很令人印象深刻，但這的確教會了我們很多有關 <code>Mutex&lt;T&gt;</code> 與執行緒安全的知識。你也可以使用此程式結構來做更多複雜的運算，而不只是數數而已。使用此策略，你可以將運算拆成數個獨立部分，將它們分配給執行緒，然後使用 <code>Mutex&lt;T&gt;</code> 來讓每個執行緒更新該部分的結果。</p>
<p>如果你只是想做單純的數值運算，其實標準函式庫提供的 <a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>std::sync::atomic</code></a><!-- ignore --> 模組會比 <code>Mutex&lt;T&gt;</code> 型別來得簡單。這些型別對原生型別提供安全、並行且原子性的順取。我們在此例對原生型別使用 <code>Mutex&lt;T&gt;</code>，是因為我們想解釋 <code>Mutex&lt;T&gt;</code> 是如何運作的。</p>
<h3 id="refcelltrct-與-mutextarct-之間的相似度"><a class="header" href="#refcelltrct-與-mutextarct-之間的相似度"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 與 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 之間的相似度</a></h3>
<p>你可能已經注意到 <code>counter</code> 是不可變的，但我們卻可以取得數值其內部的可變參考，這代表 <code>Mutex&lt;T&gt;</code> 有提供內部可變性，就像 <code>Cell</code> 家族一樣。我們在第十五章也以相同的方式使用 <code>RefCell&lt;T&gt;</code> 來讓我們能改變 <code>Rc&lt;T&gt;</code> 內部的數值，而在此我們使用 <code>Mutex&lt;T&gt;</code> 改變 <code>Arc&lt;T&gt;</code> 內部的內容。</p>
<p>另一個值得注意的細節是當你使用 <code>Mutex&lt;T&gt;</code> 時，Rust 無法避免所有種類的邏輯錯誤。回憶一下第十五章使用 <code>Rc&lt;T&gt;</code> 時會有可能產生參考循環的風險，兩個 <code>Rc&lt;T&gt;</code> 數值可能會彼此參考，造成記憶體泄漏。同樣地，<code>Mutex&lt;T&gt;</code> 有產生<strong>死結</strong>（deadlocks）的風險。這會發生在當有個動作需要鎖定兩個資源，而有兩個執行緒分別擁有其中一個鎖，導致它們永遠都在等待彼此。如果你對此有興趣的話，歡迎嘗試建立一個有死結的 Rust 程式，然後研究看看任何語言中避免的互斥鎖死結的策略，並嘗試實作它們在 Rust 中。標準函式庫中 <code>Mutex&lt;T&gt;</code> 與 <code>MutexGuard</code> 的 API 技術文件可以提供些實用資訊。</p>
<p>接下來在本章結尾我們會來討論 <code>Send</code> 與 <code>Sync</code> 特徵以及我們如何在自訂型別中使用它們。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="可延展的並行與-sync-及-send-特徵"><a class="header" href="#可延展的並行與-sync-及-send-特徵">可延展的並行與 <code>Sync</code> 及 <code>Send</code> 特徵</a></h2>
<p>有一個有趣的點是 Rust 語言提供的並行功能並<strong>沒有很多</strong>。本章節討論到的並行功能幾乎都來自於標準函式庫，並不是語言本身。你能處理並行的選項並不限於語言或標準函式庫，你可以寫出你自己的並行功能或使用其他人提供的。</p>
<p>然而，還有有兩個並行概念深植於語言中，那就是 <code>std::marker</code> 中的 <code>Sync</code> 與 <code>Send</code> 特徵。</p>
<h3 id="透過-send-來允許所有權能在執行緒間轉移"><a class="header" href="#透過-send-來允許所有權能在執行緒間轉移">透過 <code>Send</code> 來允許所有權能在執行緒間轉移</a></h3>
<p><code>Send</code> 標記特徵（marker traits）指定有實作 <code>Send</code> 特徵的型別才能將其數值的所有權在執行緒間轉移。幾乎所有的 Rust 型別都有 <code>Send</code>，但有些例外。這包含 <code>Rc&lt;T&gt;</code>，此型別沒有 <code>Send</code> 是因為如果你克隆了 <code>Rc&lt;T&gt;</code> 數值並嘗試轉移克隆的所有權到其他執行緒，會有兩條執行緒可能同時更新參考計數。基於此原因，<code>Rc&lt;T&gt;</code> 是用於當你不想要付出執行緒安全效能開銷時而在單一執行緒使用的情況。</p>
<p>因此 Rust 的型別系統與特徵界限確保你無法意外不安全地傳送 <code>Rc&lt;T&gt;</code> 數值到其他執行緒。當我們嘗試範例 16-14 時，我們就會得到錯誤 <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>。當我們切換成有實作 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 的話，程式碼就能編譯通過。</p>
<p>任何由具有 <code>Send</code> 的型別所組成的型別也都會自動標記為 <code>Send</code>。幾乎所有原始型別都是 <code>Send</code>，除了我們將在第十九章提及的裸指標（raw pointers）。</p>
<h3 id="透過-sync-來允許多重執行緒存取"><a class="header" href="#透過-sync-來允許多重執行緒存取">透過 <code>Sync</code> 來允許多重執行緒存取</a></h3>
<p><code>Sync</code> 標記特徵指定有實作 <code>Sync</code> 的型別都能安全從多個執行緒來參考。換句話說，對於任何型別 <code>T</code>，如果 <code>&amp;T</code>（對 <code>T</code> 的不可變參考）有 <code>Send</code> 的話，<code>T</code> 就是 <code>Sync</code> 的，這代表參考可以安全地傳給其他執行緒。與 <code>Send</code> 類似，原始型別都是 <code>Sync</code>，所以由具有 <code>Sync</code> 的型別所組成的型別也都有 <code>Sync</code>。</p>
<p>智慧指標 <code>Rc&lt;T&gt;</code> 沒有 <code>Sync</code> 的原因和沒有 <code>Send</code> 的原因一樣。<code>RefCell&lt;T&gt;</code> 型別（我們在第十五章提過）與其 <code>Cell&lt;T&gt;</code> 也都沒有 <code>Sync</code>。 <code>RefCell&lt;T&gt;</code> 在執行時的借用檢查實作沒有執行緒安全。智慧指標 <code>Mutex&lt;T&gt;</code> 才有 <code>Sync</code> 並能像你在<a href="ch16-03-shared-state.html#%E5%9C%A8%E6%95%B8%E5%80%8B%E5%9F%B7%E8%A1%8C%E7%B7%92%E9%96%93%E5%85%B1%E4%BA%AB-mutext">「在數個執行緒間共享 <code>Mutex&lt;T&gt;</code>」</a><!-- ignore -->段落看到的那樣用來在多個執行緒間分享存取。</p>
<h3 id="手動實作-send-與-sync-是不安全的"><a class="header" href="#手動實作-send-與-sync-是不安全的">手動實作 <code>Send</code> 與 <code>Sync</code> 是不安全的</a></h3>
<p>因為由具有 <code>Send</code> 與 <code>Sync</code> 的型別組成的型別自動就會有 <code>Send</code> 與 <code>Sync</code>，我們不需要親自實作這些特徵。至於標記特徵，它們甚至沒有任何方法需要實作。它們只是用於強制確保並行相關的不變性。</p>
<p>要手動實作這些特徵會需要實作不安全（unsafe）的 Rust 程式碼。我們會在第十九章討論如何使用不安全的 Rust 程式碼，現在最重要的資訊是要從不具有 <code>Send</code> 與 <code>Sync</code> 的元件來組成新的並行型別需要格外小心才能確保其安全保障。<a href="https://doc.rust-lang.org/nomicon/index.html">「The Rustonomicon」</a> 有更多關於這些保障與如何維持它們的資訊。</p>
<h2 id="總結-15"><a class="header" href="#總結-15">總結</a></h2>
<p>這不會是你在本書中最後一次看到並行程式碼，第二十章的專案將會在更實際的場合中使用本章節的概念，而非這裡討論的簡單範例。</p>
<p>如之前提過的，因為 Rust 語言本身很少處理並行的部分，許多並行解決方案都實作成 crate。這些 crate 通常發展的比標準函式庫還快，所以別忘了到線上尋找目前最先進的 crate 來在多執行緒場合中使用喔。</p>
<p>Rust 標準函式庫提供訊息傳遞的通道與智慧指標，像是 <code>Mutex&lt;T&gt;</code> 與 <code>Arc&lt;T&gt;</code>，能夠在並行環境中安全使用。型別系統與借用檢查器中確保使用這些解決方案的程式碼不會發生資料競爭或是無效參考。一旦你讓你的程式碼能編譯通過後，你可以放心地認定它會開開心心地在多執行緒中執行，並且不會發生任何在其他語言中常見且難以追蹤的程式錯誤。並行程式設計就不再是個令人害怕的概念，無畏無懼地開發並行程式吧！</p>
<p>接下來，我們要討論當你的 Rust 程式成長時，定義出問題並組織解決辦法的慣用方案。除此之外，我們也將討論 Rust 有哪些與物件導向程式設計（object-oriented programming）類似的概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-的物件導向程式設計特色"><a class="header" href="#rust-的物件導向程式設計特色">Rust 的物件導向程式設計特色</a></h1>
<p>物件導向程式設計（Object-oriented programming, OOP）是一種模組化程式的方式，物件這種程式設計的概念始於 1960 年的 Simula。這些物件影響了 Alan Kay 的程式設計架構中物件彼此之間訊息的傳遞。他在 1967 年提出了<strong>物件導向程式設計</strong>來描述此架構。對於 OOP 的定義有許多種描述，有些定義會將 Rust 歸類為屬於物件導向的，而有些則不會。在本章節中，我們會探討特定常視為是物件導向的特色並看看這些特色如何轉換成慣用的 Rust 程式碼。然後我們會向你展示如何在 Rust 中實作物件導向設計模式，並討論這麼做與利用 Rust 自身的優勢實現的版本有何取捨差別。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="物件導向語言的特色"><a class="header" href="#物件導向語言的特色">物件導向語言的特色</a></h2>
<p>對於一個被視為物件導向的語言該有哪些功能，在程式設計語言社群中並沒有達成共識。Rust 受到許多程式設計理念影響，這當然包括 OOP。舉例來說，我們在第十三章探討了源自於函式語言的特性。同樣地，OOP 語言有一些特定常見特色，諸如物件、封裝（encapsulation）與繼承（inheritance）。讓我們看看這些特色分別是什麼意思以及 Rust 有沒有支援。</p>
<h3 id="物件包含資料與行為"><a class="header" href="#物件包含資料與行為">物件包含資料與行為</a></h3>
<p>由 Erich Gamma、Richard Helm、Ralph Johnson 與 John Vlissides（Addison-Wesley Professional, 1994) 所寫的書 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> 俗稱為 <em>The Gang of Four</em>，這是本物件導向設計模式的目錄。它是這樣定義 OOP 的：</p>
<blockquote>
<p>物件導向程式由物件所組成。<strong>物件</strong>會包裝資料以及運作在資料上的行為。此行為常稱為<strong>方法（methods）<strong>或</strong>操作（operations）</strong>。</p>
</blockquote>
<p>在此定義下，Rust 是物件導向的，結構體與枚舉擁有資料，而 <code>impl</code> 區塊對結構體與枚舉提供方法。就算有方法的結構體與枚舉不會被稱為<strong>物件</strong>，依據 Gang of Four 對物件的定義，它們還是有提供相同的功能。</p>
<h3 id="隱藏實作細節的封裝"><a class="header" href="#隱藏實作細節的封裝">隱藏實作細節的封裝</a></h3>
<p>另外一個常和 OOP 相關的概念就是<strong>封裝（encapsulation）</strong>，這指的是物件的實作細節不會讓使用物件的程式碼取得。因此要與該物件互動的方式是透過它的公開 API，使用物件的程式碼不該有辦法觸及物件內部並直接變更資料的行為。這讓程式設計師能變更並重構物件內部，無需擔心要變更使用物件的程式碼。</p>
<p>我們在第七章討論過如何控制封裝，我們可以使用 <code>pub</code> 關鍵字來決定程式中的哪些模組、型別、函式與方法要公開出來，且預設一切都是私有的。舉例來說，我們可以定義個結構體 <code>AveragedCollection</code> 並有個欄位包含一個 <code>i32</code> 數值的向量。此結構體還有個欄位包含向量數值的平均值，讓我們不必在每次呼叫時都得重新計算平均值。換句話說，<code>AveragedCollection</code> 會為我們快取計算出的平均值。範例 17-1 展示了結構體 <code>AveragedCollection</code> 的定義：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
</code></pre>
<p><span class="caption">範例 17-1：結構體 <code>AveragedCollection</code> 有個整數列表與集合中的項目平均值
collection</span></p>
<p>此結構體有 <code>pub</code> 標記所以其他程式碼可以使用它，但結構體內部的欄位是私有的。這在此例中是很重要的，因為我們希望在有數值加入或移出列表時，平均值也能更新。我們會實作結構體的 <code>add</code>、<code>remove</code> 與 <code>average</code> 方法來達成，如範例 17-2 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
</code></pre>
<p><span class="caption">範例 17-2：對 <code>AveragedCollection</code> 實作公開方法 <code>add</code>、<code>remove</code> 與 <code>average</code></span></p>
<p>公開的方法 <code>add</code>、<code>remove</code> 與 <code>average</code> 是存取或修改 <code>AveragedCollection</code> 實例資料的唯一方法。當有個項目透過 <code>add</code> 方法加入或透過 <code>remove</code> 方法移出 <code>list</code> 中時，每個方法會同時呼叫 <code>update_average</code> 方法來更新 <code>average</code> 欄位。</p>
<p>我們讓 <code>list</code> 與 <code>average</code> 欄位維持私有，所以外部的程式碼不可能直接新增或移除 <code>list</code> 欄位的項目。不然的話，<code>average</code> 欄位可能就無法與變更的 <code>list</code> 同步了。<code>average</code> 方法會回傳 <code>average</code> 欄位的數值，讓外部程式碼能夠讀取 <code>average</code> 但不會修改它。</p>
<p>由於我們封裝了 <code>AveragedCollection</code> 結構體的實作細節，我們可以在未來輕鬆變更像是資料結構等內部細節。舉例來說，我們可以用 <code>HashSet&lt;i32&gt;</code> 來替換 <code>list</code> 欄位的 <code>Vec&lt;i32&gt;</code>。只要 <code>add</code>、<code>remove</code> 與 <code>average</code> 的公開方法簽名維持一樣，使用到 <code>AveragedCollection</code> 的程式碼就不需要改變。如果我們讓 <code>list</code> 公開的話，情況可能就不相同了，<code>HashSet&lt;i32&gt;</code> 與 <code>Vec&lt;i32&gt;</code> 有不同的方法來新增和移除項目，所以外部的程式碼如果會直接修改 <code>list</code> 的話，可能會需要做些改變。</p>
<p>如果封裝是物件導向的必備條件的話，Rust 也符合此條件。對程式碼中不同部分使用 <code>pub</code> 可以封裝實作細節。</p>
<h3 id="作為型別系統與程式碼共享來繼承"><a class="header" href="#作為型別系統與程式碼共享來繼承">作為型別系統與程式碼共享來繼承</a></h3>
<p><strong>繼承</strong>（Inheritance）是指一個物件可以繼承其他物件定義的機制，使其可以獲取繼承物件的資料與行為，不必再定義一次。</p>
<p>如果一個語言一定要有繼承才算物件導向語言的話，那麼 Rust 就不是。在定義結構體時我們無法繼承父結構體欄位的方法實作，除非使用巨集。</p>
<p>然而如果你在程式設計時常常用到繼承的話，依據你想使用繼承的原因，Rust 還是有提供其他方案。</p>
<p>你想選擇繼承通常會有兩個主要原因。第一個是想能重複使用程式碼，你可以定義一個型別的特定行為，然後繼承讓你可以在不同的型別重複使用該實作。為此你可以使用預設的特徵方法實作來分享 Rust 程式碼，你在範例 10-14 就有看到我們在 <code>Summary</code> 特徵加上的預設 <code>summarize</code> 方法實作。任何有實作 <code>Summary</code> 特徵的型別都不必加上更多程式碼就能有 <code>summarize</code> 可以呼叫。這就類似於父類型（class）實作的方法可以在繼承的子類型擁有該方法實作。我們也可以在實作 <code>Summary</code> 特徵時，覆寫 <code>summarize</code> 方法的預設實作，這就類似於子類型覆寫父類型的方法實作。</p>
<p>另一個想使用繼承的原因與型別系統有關，讓子類型可以視為父類型來使用。這也稱為<strong>多型（polymorphism）</strong>，代表要是數個物件有共享特定特性的話，你可以在執行時彼此替換使用。</p>
<blockquote>
<h3 id="多型"><a class="header" href="#多型">多型</a></h3>
<p>對許多人來說，多型就是繼承的代名詞。不過這其實是個更通用的概念，用來指程式碼可適用於多種型別資料。而對繼承來說，這些型別通常都是子類型。</p>
<p>Rust 則是使用泛型來抽象化不同可能的型別，並以特徵界限來加強約束這些型別必須提供的內容。這有時會稱為<strong>限定的參數多型（bounded parametric polymorphism）</strong>。</p>
</blockquote>
<p>近年來像繼承這種程式設計的解決方案在許多程式設計語言中都漸漸失寵了，因為這經常有分享不必要程式碼的風險。子類型不應該永遠分享其父類型的所有特性，但繼承會這樣做。這會讓程式的設計較不具有彈性。這還可能產生不具意義或導致錯誤的子類型方法呼叫，因為該方法不適用於子類型。除此之外，有些語言只會允許單一繼承，也就是一個子類型只能繼承一個類別，進一步限制了程式設計的彈性。</p>
<p>基於這些原因，Rust 採取了不同的方案，使用特徵物件（trait objects）而非繼承。讓我們看看 Rust 的特徵物件如何達成多型。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="允許不同型別數值的特徵物件"><a class="header" href="#允許不同型別數值的特徵物件">允許不同型別數值的特徵物件</a></h2>
<p>在第八章中，我們提及向量其中一項限制是它儲存的元素只能有一種型別。我們在範例 8-9 提出一個替代方案，那就是我們定義 <code>SpreadsheetCell</code> 枚舉且其變體能存有整數、浮點數與文字。這讓我們可以對每個元素儲存不同的型別，且向量仍能代表元素的集合。當我們的可變換的項目有固定的型別集合，而且我們在編譯程式碼時就知道的話，這的確是完美的解決方案。</p>
<p>然而，有時我們會希望函式庫的使用者能夠在特定的情形下擴展型別的集合。為了展示我們如何達成，我們來建立個圖形使用者介面（graphical user interface, GUI）工具範例來遍歷一個項目列表，呼叫其內每個項目的 <code>draw</code> 方法將其顯示在螢幕上，這是 GUI 工具常見的技巧。我們會建立個函式庫 crate 叫做 <code>gui</code>，這會包含 GUI 函式庫的結構體。此 crate 可能會包含一些人們會使用到的型別，像是 <code>Button</code> 或 <code>TextField</code>。除此之外，<code>gui</code> 使用者也能夠建立他們自己的型別來顯示出來。舉例來說，有些開發者可以加上 <code>Image</code> 而其他人可能會加上 <code>SelectBox</code>。</p>
<p>我們在此例中不會實作出整個 GUI 函式庫，但會展示各個元件是怎麼組合起來的。在寫函式庫時，我們無法知道並定義開發者想建立出來的所有型別。但我們知道 <code>gui</code> 需要追蹤許多不同型別的數值，且它需要能夠對這些不同的型別數值呼叫 <code>draw</code> 方法。它不需要知道當我們呼叫 <code>draw</code> 方法時實際發生了什麼事，只需要知道該數值有我們可以呼叫的方法。</p>
<p>在有繼承的語言中，我們可能會定義一個類型（class）叫做 <code>Component</code> 且其有個方法叫做 <code>draw</code>。其他的類型像是 <code>Button</code>、<code>Image</code> 和 <code>SelectBox</code> 等等，可以繼承 <code>Component</code> 以取得 <code>draw</code> 方法。它們可以覆寫 <code>draw</code> 方法來定義它們自己的自訂行為，但是整個框架能將所有型別視為像是 <code>Component</code> 實例來對待，並對它們呼叫 <code>draw</code>。但由於 Rust 並沒有繼承，我們需要其他方式來組織 <code>gui</code> 函式庫，好讓使用者可以透過新的型別來擴展它。</p>
<h3 id="定義共同行為的特徵"><a class="header" href="#定義共同行為的特徵">定義共同行為的特徵</a></h3>
<p>要定義我們希望 <code>gui</code> 能擁有的行為，我們定義一個特徵叫做 <code>Draw</code> 並有個方法叫做 <code>draw</code>。然後我們可以定義一個接收<strong>特徵物件</strong>（trait object）的向量。一個特徵物件會指向有實作指定特徵的型別以及一個在執行時尋找該型別方法的尋找表（look up table）。要建立特徵物件，我們指定一些指標，像是參考 <code>&amp;</code> 或者智慧指標 <code>Box&lt;T&gt;</code>，然後加上 <code>dyn</code> 關鍵字與指定的相關特徵。（我們會在第十九章的<a href="ch19-03-advanced-types.html#%E5%8B%95%E6%85%8B%E5%A4%A7%E5%B0%8F%E5%9E%8B%E5%88%A5%E8%88%87-sized-%E7%89%B9%E5%BE%B5">「動態大小型別與 <code>Sized</code> 特徵」</a><!-- ignore -->段落討論特徵物件必須使用指標的原因）我們可以對泛型或實際型別使用特徵物件。當我們使用特徵物件時，Rust 的型別系統會確保在編譯時該段落使用到的任何數值都有實作特徵物件的特徵。於是我們就不必在編譯時知道所有可能的型別。</p>
<p>我們提到在 Rust 中，我們避免將結構體和枚舉稱為「物件」，來與其他語言的物件做區別。在結構體或枚舉中，結構體欄位中的資料與 <code>impl</code> 區塊的行為是分開來的。在其他語言中，資料與行為會組合成一個概念，也就是所謂的物件。然而特徵物件才比較像是其他語言中的物件，因為這才會將資料與行為組合起來。但特徵物件與傳統物件不同的地方在於，我們無法向特徵物件新增資料。特徵物件不像其他語言的物件那麼通用，它們是特別用於對共同行為產生的抽象概念。</p>
<p>範例 17-3 定義了一個特徵叫做 <code>Draw</code> 以及一個方法叫做 <code>draw</code>：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait Draw {
    fn draw(&amp;self);
}
</code></pre>
<p><span class="caption">範例 17-3：<code>Draw</code> 特徵的定義</span></p>
<p>此語法和我們在第十章介紹過的特徵定義方式相同。接下來才是新語法用到的地方，範例 17-4 定義了一個結構體叫做 <code>Screen</code> 並持有個向量叫做 <code>components</code>。此向量的型別為 <code>Box&lt;dyn Draw&gt;</code>，這是一個特徵物件，這代表 <code>Box</code> 內的任何型別都得有實作 <code>Draw</code> 特徵。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
</code></pre>
<p><span class="caption">範例 17-4：定義結構體 <code>Screen</code> 且有個 <code>components</code> 欄位來持有一個實作 <code>Draw</code> 特徵的特徵物件向量</span></p>
<p>在 <code>Screen</code> 結構體中，我們定義了一個方法叫做 <code>run</code> 來對其 <code>components</code> 呼叫 <code>draw</code> 方法，如範例 17-5 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">範例 17-5：<code>Screen</code> 的方法 <code>run</code> 會呼叫每個 <code>component</code> 的 <code>draw</code> 方法</span></p>
<p>這與定義一個結構體並使用附有特徵界限的泛型型別參數的方式不相同。泛型型別參數一次只能替換成一個實際型別，特徵物件則是在執行時允許數個實際型別能填入特徵物件中。舉例來說，我們可以使用泛型型別與特徵界限來定義 <code>Screen</code>，如範例 17-6 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
</code></pre>
<p><span class="caption">範例 17-6：<code>Screen</code> 結構體的另種實作方式，它的方法 <code>run</code> 則使用泛型與特徵界限</span></p>
<p>這樣我們會限制 <code>Screen</code> 實例必須擁有一串全是 <code>Button</code> 型別或全是 <code>TextField</code> 型別的列表。如果你只會有同型別的集合，使用泛型與特徵界限的確是比較合適的，因為其定義就會在編譯時單態化為使用實際型別。</p>
<p>另一方面，透過使用特徵物件的方法，<code>Screen</code> 實例就能有個同時包含 <code>Box&lt;Button&gt;</code> 與 <code>Box&lt;TextField&gt;</code> 的 <code>Vec&lt;T&gt;</code>。讓我們看看這如何辦到的，然後我們會討論其對執行時效能的影響。</p>
<h3 id="實作特徵"><a class="header" href="#實作特徵">實作特徵</a></h3>
<p>現在我們來加上一些有實作 <code>Draw</code> 特徵的型別。我們會提供 <code>Button</code> 型別。再次重申 GUI 函式庫的實際實作超出了本書的範疇，所以 <code>draw</code> 的本體不會有任何有意義的實作。為了想像該實作會像是什麼，<code>Button</code> 型別可能會有欄位 <code>width</code>、<code>height</code> 與 <code>label</code>，如範例 17-7 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // 實際畫出按鈕的程式碼
    }
}
</code></pre>
<p><span class="caption">範例 17-7：結構體 <code>Button</code> 實作了 <code>Draw</code> 特徵</span></p>
<p>在 <code>Button</code> 中的 <code>width</code>、<code>height</code> 與 <code>label</code> 欄位會與其他元件不同，像是 <code>TextField</code> 可能就會有前面所有的欄位在加上 <code>placeholder</code> 欄位。每個我們想在螢幕上顯示的型別都會實作 <code>Draw</code> 特徵，但在 <code>draw</code> 方法會使用不同程式碼來定義如何印出該特定型別，像是這裡的 <code>Button</code> 型別（不包含實際 GUI 程式碼）。舉例來說，<code>Button</code> 可能會有額外的 <code>impl</code> 區塊來包含使用者點擊按鈕時該如何反應的方法。這種方法就不適用於 <code>TextField</code>。</p>
<p>如果有人想用我們的函式庫來實作個 <code>SelectBox</code> 結構體並擁有 <code>width</code>、<code>height</code> 與 <code>options</code> 欄位的話，他們也可以對 <code>SelectBox</code> 實作 <code>Draw</code> 特徵，如範例 17-8 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // 實際畫出選擇框的程式碼
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 17-8：別的 crate 使用 <code>gui</code> 來對 <code>SelectBox</code> 結構體實作 <code>Draw</code> 特徵</span></p>
<p>我們的函式庫使用者現在可以在他們的 <code>main</code> 建立個 <code>Screen</code> 實例。在 <code>Screen</code> 實例中，他們可以透過將 <code>SelectBox</code> 和 <code>Button</code> 放入 <code>Box&lt;T&gt;</code> 來成為特徵物件並加入元件中。他們接著就可以對 <code>Screen</code> 實例呼叫 <code>run</code> 方法，這會呼叫每個元件的 <code>draw</code> 方法。如範例 17-9 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // 實際畫出選擇框的程式碼
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">範例 17-9：使用特徵物件來儲存實作相同特徵的不同型別數值</span></p>
<p>我們在寫函式庫時，我們並不知道有人會想要新增 <code>SelectBox</code> 型別，但我們的 <code>Screen</code> 實作能夠運用新的型別並顯示出來，因為 <code>SelectBox</code> 有實作 <code>Draw</code> 特徵，這代表它就有實作 <code>draw</code> 方法。</p>
<p>這種只在意數值回應的訊息而非數值實際型別的概念，類似於動態型別語言中<strong>鴨子型別</strong>（duck typing）的概念。如果它走起來像隻鴨子、叫起來像隻鴨子，那它必定是隻鴨子！在範例 17-5 中 <code>Screen</code> 的 <code>run</code> 實作不需要知道每個元件的實際型別為何。它不會檢查一個元件是 <code>Button</code> 還是 <code>SelectBox</code> 實例，它只會呼叫元件的 <code>draw</code> 方法。透過指定 <code>Box&lt;dyn Draw&gt;</code> 來作為 <code>components</code>向量中的數值型別，我們定義 <code>Screen</code> 需要我們能夠呼叫 <code>draw</code> 方法的數值。</p>
<p>我們使用特徵物件與 Rust 型別系統能寫出類似鴨子型別的程式碼，這樣的優勢在於我們在執行時永遠不必檢查一個數值有沒有實作特定方法，或擔心我們會不會呼叫了一個沒有實作該方法的數值而產生錯誤。如果數值沒有實作特徵物件要求的特徵的話，Rust 不會編譯通過我們的程式碼。</p>
<p>舉例來說，範例 17-10 展示了要是我們嘗試使用 <code>String</code> 作為元件來建立 <code>Screen</code> 的話會發生什麼事：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;嗨&quot;))],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">範例 17-10：嘗試使用沒有實作特徵物件的特徵的型別</span></p>
<p>我們會因為 <code>String</code> 沒有實作 <code>Draw</code> 特徵而得到錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `String: Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;嗨&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`
  |
  = help: the trait `Draw` is implemented for `Button`
  = note: required for the cast from `String` to the object type `dyn Draw`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui` due to previous error
</code></pre>
<p>此錯誤讓我們知道要麼我們傳遞了不希望傳給 <code>Screen</code> 的型別所以應該要傳遞其他型別，要麼我們應該要對 <code>String</code> 實作 <code>Draw</code>，這樣 <code>Screen</code> 才能對其呼叫 <code>draw</code>。</p>
<h3 id="特徵物件執行動態調度"><a class="header" href="#特徵物件執行動態調度">特徵物件執行動態調度</a></h3>
<p>回想一下第十章的<a href="ch10-01-syntax.html#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%95%88%E8%83%BD">「使用泛型的程式碼效能」</a><!-- ignore -->段落我們討論過，當我們對泛型使用閉包時，編譯器會執行單態化（monomorphization）的過程。編譯器會在我們對每個用泛型型別參數取代的實際型別產生非泛型的函式與方法實作。單態化產生程式碼的動作會稱為「靜態調度（static dispatch）」，這代表編譯器在編譯時知道我們呼叫的方法為何。與其相反的則是<strong>動態調度（dynamic dispatch）</strong>，這種方式時編譯器在編譯時無法知道你呼叫的方法為何。在動態調度的情況下，編譯器會生成在執行時能夠確定會呼叫何種方法的程式碼。</p>
<p>當我們使用特徵物件時，Rust 必須使用動態調度。編譯器無法知道使用特徵物件的程式碼會使用到的所有型別為何，所以它會不知道該呼叫哪個型別的哪個實作方法。取而代之的是，Rust 在執行時會使用特徵物件內部的指標來知道該呼叫哪個方法。這樣尋找的動作會產生靜態調度所沒有的執行時開銷。動態調度也讓編譯器無法選擇內聯（inline）方法的程式碼，這樣會因而阻止一些優化。不過我們的確對範例 17-5 的程式碼增加了額外的彈性，並能夠支援範例 17-9，所以這是個權衡取捨。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="實作物件導向設計模式"><a class="header" href="#實作物件導向設計模式">實作物件導向設計模式</a></h2>
<p><strong>狀態模式</strong>（state pattern）是種物件導向設計模式。此模式的關鍵在於我們會定義一個數值擁有些內部狀態，以<strong>狀態物件</strong>（state objects）呈現，然後數值的行為會依據內部狀態而有所改變。我們將向用一個網誌文章結構體作為範例，讓它持有個狀態能在「草稿」、「審核」「發佈」間轉換，成為狀態物件。</p>
<p>狀態物件會分享功能，當然在 Rust 中我們使用結構體與特徵，而不是使用物件與繼承。每個狀態物件負責本身的行為並監測何時要改變成其他狀態。持有狀態物件的數值不會知道狀態中不同的行為，或是何時要轉換狀態。</p>
<p>使用狀態模式的優勢在於當程式的業務需求改變時，我們不需要改變持有狀態的數值或使用其數值的程式碼。我們只需要變更其中一個狀態物件的程式碼來改變其規則，或者新增更多狀態物件。</p>
<p>我們先用比較傳統的物件導向方式實作狀態模式，然後我們會再來改成比較符合 Rust 的形式。讓我們來用狀態模式一步步實作網誌文章流程吧：</p>
<p>網誌最終的功能會長得像這樣：</p>
<ol>
<li>網誌文章從空白草稿開始。</li>
<li>當草稿完成時，請求審核文章。</li>
<li>當文章通過時，它就會被發佈。</li>
<li>只有發佈的網誌文章內容會顯示出來，所以沒被通過的文章不會被意外顯示出來。</li>
</ol>
<p>其他任何對文章的修改不會有任何影響。舉例來說，如果我們嘗試在請求審核一個文章前，通過其他網誌文章草稿的話，該文章應維持未發佈的狀態。</p>
<p>此範例顯示了此工作流程的程式碼形式，這是個會用到我們等等會實作的函式庫 crate <code>blog</code> API 的範例。這目前還無法編譯，因為我們還沒有實作 <code>blog</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;我今天午餐吃了沙拉&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;我今天午餐吃了沙拉&quot;, post.content());
}
</code></pre>
<p><span class="caption">範例 17-11：展示我們所希望的 <code>blog</code> crate 預期行為的程式碼</span></p>
<p>我們想要讓使用者能透過 <code>Post::new</code> 來建立新的網誌文章草稿，然後我們希望能對網誌文章加入文字。如果我們想在通過前立即取得文章內容的話，我們什麼都不會看到，因為該文章還只是個草稿。我們加入的 <code>assert_eq!</code> 在此只是作為解釋目的。更好地做法是寫個判定網誌文章草稿是否會從 <code>content</code> 方法回傳空字串的單元測試，不過我們在此例不會寫任何測試。</p>
<p>接著，我們想要請求文章審核，且我們希望在等待審核時 <code>content</code> 仍是回傳空字串。當文章通過時，它就會被發佈，代表當 <code>content</code> 呼叫時，文章中的文字就會回傳。</p>
<p>注意到我們要使用此 crate 時只會接觸到到一個型別 <code>Post</code>。此型別會使用狀態模式，並持有個數值能包含三種狀態物件其中之一，來代表文章狀態可以是擬稿中、等待審核或已發佈。變更狀態由 <code>Post</code> 型別內部管理。狀態依據函式庫使用者對 <code>Post</code> 實例呼叫的方法而改變，但他們不用手動管理狀態的變更。而且使用者也不可能會在狀態中出錯，像是在審核前就發佈文章。</p>
<h3 id="定義-post-並在草稿階段建立新實例"><a class="header" href="#定義-post-並在草稿階段建立新實例">定義 <code>Post</code> 並在草稿階段建立新實例</a></h3>
<p>讓我們開始實作出函式庫吧！我們知道我們需要一個公開的結構體 <code>Post</code> 來存有些內容，所以我們先從結構體的定義開始，它會有個公開的關聯函式 <code>new</code> 來建立 <code>Post</code> 的實例，如範例 17-12 所示。我們還會再定義一個私有的特徵 <code>State</code>，定義<code>Post</code> 所有狀態物件該有的行為。</p>
<p>然後 <code>Post</code> 會有個私有欄位 <code>state</code> 來擁有 <code>Option&lt;T&gt;</code> 且其內會存有一個特徵物件 <code>Box&lt;dyn State&gt;</code>。你會在之後瞭解為何 <code>Option&lt;T&gt;</code> 在此是必要的。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
</code></pre>
<p><span class="caption">範例 17-12：<code>Post</code> 結構體、能建立新的 <code>Post</code> 實例的 <code>new</code> 函式、<code>State</code> 特徵與 <code>Draft</code> 結構體的定義</span></p>
<p><code>State</code> 定義了不同文章狀態共享的行為。<code>Draft</code>、<code>PendingReview</code> 與 <code>Published</code> 這些狀態物件都會實作 <code>State</code> 特徵。目前特徵還沒有任何方法，而且我們也只先定義 <code>Draft</code> 狀態，因為這是文章的初始狀態。</p>
<p>當我們建立新的 <code>Post</code>，我們對其 <code>state</code> 欄位給予存有 <code>Box</code> 的 <code>Some</code> 數值。此 <code>Box</code> 會指向一個新的 <code>Draft</code> 結構體實例。這確保每當我們建立 <code>Post</code> 的新實例時，它會從草稿起始。因為 <code>Post</code> 的 <code>state</code> 欄位是私有的，我們沒有任何方法可以建立處於其他狀態的 <code>Post</code>！在 <code>Post::new</code> 函式中，我們設置 <code>content</code> 欄位為一個新的空 <code>String</code>。</p>
<h3 id="儲存文章內容的文字"><a class="header" href="#儲存文章內容的文字">儲存文章內容的文字</a></h3>
<p>在範例 17-11 我們想要能夠呼叫一個叫做 <code>add_text</code> 的函式並傳入 <code>&amp;str</code> 來對網誌文章增加文字內容。我們實作此方法，而不是將 <code>content</code> 欄位透過 <code>pub</code> 公開出去，這樣我們之後就可以實作個方法來控制 <code>content</code> 欄位資料該怎麼讀取。<code>add_text</code> 方法非常直觀，所以讓我們在 <code>impl Post</code> 區塊中加上範例 17-13 的實作吧：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --省略--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">範例 17-13：實作 <code>add_text</code> 方法來將文字加入文章的 <code>content</code> 中</span></p>
<p><code>add_text</code> 方法接收 <code>self</code> 的可變參考，因為我們在呼叫 <code>add_text</code> 時會改變 <code>Post</code> 實例。然後我們對 <code>content</code> 中的 <code>String</code> 呼叫<code>push_str</code>，並傳入 <code>text</code> 引數來存到 <code>content</code> 之中。此行為與文章的狀態無關，所以它沒有被包含在狀態模式中。<code>add_text</code> 方法不會與 <code>state</code> 欄位有關係，但它是我們想支援的部分行為之一。</p>
<h3 id="確保文章草稿的內容為空"><a class="header" href="#確保文章草稿的內容為空">確保文章草稿的內容為空</a></h3>
<p>儘管我們已經能透過 <code>add_text</code> 來為我們的文章加些內容，但我們還是希望 <code>content</code> 方法會回傳空字串切片，因為文章還在草稿階段中，如範例 17-11 的第七行所示。現在先讓我們用能滿足需求最簡單的方式來實作 <code>content</code> 方法，也就是永遠回傳空字串切片。之後一旦我們實作出能改變文章狀態為已發佈的能力，我們會回來修改這部分。目前文章只能處於草稿階段，所以文章內容應該要永遠為空。範例 17-14 顯示了此暫時的實作方式：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --省略--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span></code></pre>
<p><span class="caption">範例 17-14：<code>Post</code> 暫時實作的 <code>content</code> 方法，這會永遠回傳一個空字串切片</span></p>
<p>透過此 <code>content</code> 方法，範例 17-11 的程式碼到地七行都能如期執行。</p>
<h3 id="請求文章審核來變更它的狀態"><a class="header" href="#請求文章審核來變更它的狀態">請求文章審核來變更它的狀態</a></h3>
<p>接下來，我們需要增加請求文章審核的功能，這會將其狀態從 <code>Draft</code> 變更為 <code>PendingReview</code>。如範例 14-15 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --省略--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">範例 17-15：對 <code>Post</code> 與 <code>State</code> 特徵實作的 <code>request_review</code> 方法</span></p>
<p><code>Post</code> 現在有個公開方法叫做 <code>request_review</code>，這會接收 <code>self</code> 的可變參考。然後我們對 <code>Post</code> 目前的狀態呼叫其內部的 <code>request_review</code> 方法，然後此 <code>request_review</code> 方法會消耗目前的狀態並回傳新的狀態。</p>
<p>我們對 <code>State</code> 特徵也加上了 <code>request_review</code> 方法，所有有實作此特徵的型別現在都需要實作 <code>request_review</code> 方法。注意到不同於擁有 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code> 來作為方法的第一個參數，我們用的是 <code>self: Box&lt;Self&gt;</code>。此語法代表對持有型別的 <code>Box</code> 呼叫方法才有效。此語法取得 <code>Box&lt;Self&gt;</code> 的所有權，將舊的狀態無效化，讓 <code>Post</code> 的狀態數值可以轉換成新的狀態。</p>
<p>要消耗掉舊的狀態，<code>request_review</code> 方法需要取得狀態數值的所有權。這正是 <code>Post</code> 的 <code>state</code> 欄位中使用 <code>Option</code> 的用途，我們呼叫 <code>take</code> 方法來取得 <code>state</code> 欄位中 <code>Some</code> 的數值，並留下 <code>None</code>，因為 Rust 不允許結構體的欄位為空。這讓我們將 <code>Post</code> 的 <code>state</code> 移出來，而不只是借用。然後我們會將文章 <code>state</code> 數值設為此運算的結果。</p>
<p>我們需要暫時將 <code>state</code> 設為 <code>None</code>，而非只是像這樣 <code>self.state = self.state.request_review();</code> 直接設置來取得 <code>state</code> 的數值。這確保 <code>Post</code> 不會在我們轉換到新狀態時，使用到舊的 <code>state</code> 數值。</p>
<p><code>Draft</code> 的 <code>request_review</code> 方法需要回傳一個新的結構體 <code>PendingReview</code> box 實例，這代表文章正在等待審核的狀態。<code>PendingReview</code> 結構體也實作了 <code>request_review</code> 方法但沒有做任何轉換。反之，它只會回傳自己，因為當我們向已經處於 <code>PendingReview</code> 狀態的文章請求審核的話，它應該會維持 <code>PendingReview</code> 的狀態。</p>
<p>現在我們可以開始看出狀態模式的優勢了，<code>Post</code> 的 <code>request_review</code> 方法不管其 <code>state</code> 數值為何都是一樣的。每個狀態負責自己的規則。</p>
<p>我們維持 <code>Post</code> 的方法 <code>content</code> 不變，依然回傳一個空字串切片。我們現在的 <code>Post</code> 可以處於 <code>PendingReview</code> 狀態與 <code>Draft</code> 狀態，但我們想要 <code>PendingReview</code> 狀態也有相同的行為。現在範例 17-11 可以運行到第十行了！</p>
<h3 id="透過-approve-改變-content-的行為"><a class="header" href="#透過-approve-改變-content-的行為">透過 <code>approve</code> 改變 <code>content</code> 的行為</a></h3>
<p><code>approve</code> 方法會類似於 <code>request_review</code> 方法，它會設置 <code>state</code> 的數值為目前狀態審核通過時該處於的狀態，如範例 17-16 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --省略--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --省略--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --省略--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
</code></pre>
<p><span class="caption">範例 17-16：對 <code>Post</code> 與 <code>State</code> 特徵實作 <code>approve</code> 方法</span></p>
<p>我們在 <code>State</code> 特徵加上 <code>approve</code> 方法，並新增一個也有實作 <code>State</code> 的新結構體 <code>Published</code> 特徵。</p>
<p>和 <code>PendingReview</code> 的 <code>request_review</code> 類似，如果我們對 <code>Draft</code> 呼叫 <code>approve</code> 方法，它不會有任何效果，因為它會回傳 <code>self</code>。當我們對 <code>PendingReview</code> 呼叫 <code>approve</code>，它會回傳一個新的結構體 <code>Published</code> box 實例。<code>Published</code> 也有實作 <code>State</code> 特徵，對於 <code>request_review</code> 方法與 <code>approve</code> 方法，它只會回傳自己，因為文章在這些情況下都應該維持 <code>Published</code> 狀態。</p>
<p>現在我們需要更新 <code>Post</code> 的 <code>content</code> 方法。我們想依據 <code>Post</code> 當前的狀態回傳 <code>content</code>，所以我們將用 <code>Post</code> 來回傳它自己 <code>state</code> 所定義的 <code>content</code> 方法，如範例 17-17 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --省略--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --省略--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 17-17：更新 <code>Post</code> 的 <code>content</code> 方法來呼叫 <code>State</code> 的 <code>content</code> 方法</span></p>
<p>因為目標是將這些所有規則維持在實作 <code>State</code> 的結構體內，我們對 <code>state</code> 呼叫 <code>content</code> 方法並傳遞文章實例（也就是 <code>self</code>）來作為引數。然後我們的回傳值就是對 <code>state</code> 數值使用 <code>content</code> 的回傳值。</p>
<p>我們對 <code>Option</code> 呼叫 <code>as_ref</code> 方法，因為我們希望取得 <code>Option</code> 內的數值參考，而不是該值的所有權。因為 <code>state</code> 的型別是 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>，當我們呼叫 <code>as_ref</code> 時會回傳 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>。如果我們沒有呼叫 <code>as_ref</code> 的話，我們會得到錯誤，因為我們無法從借用的函式參數 <code>&amp;self</code> 移動 <code>state</code>。</p>
<p>然後我們呼叫 <code>unwrap</code> 方法，我們知道這絕對不會恐慌，因為我們知道當 <code>Post</code> 的方法完成執行時，它們會確保 <code>state</code> 永遠包含一個 <code>Some</code> 數值。這是我們在第九章的<a href="ch09-03-to-panic-or-not-to-panic.html#%E7%95%B6%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%AF%94%E7%B7%A8%E8%AD%AF%E5%99%A8%E9%82%84%E5%A4%9A%E7%9A%84%E6%99%82%E5%80%99">「當你知道的比編譯器還多的時候」</a><!-- ignore -->段落介紹過的其中一種情況。雖然編譯器不能理解，但我們知道永遠不可能會有 <code>None</code> 數值。</p>
<p>此時當我們呼叫 <code>&amp;Box&lt;dyn State&gt;</code> 的 <code>content</code>，強制解參考（deref coercion）對 <code>&amp;</code> 與 <code>Box</code> 產生影響，讓 <code>content</code> 方法最終對有實作 <code>State</code> 特徵的型別呼叫。這代表我需要在 <code>State</code> 特徵定義加上 <code>content</code>，而這正是我們要填入依據狀態為何來回傳何種內容的地方，如範例 17-18 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --省略--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --省略--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --省略--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
</code></pre>
<p><span class="caption">範例 17-18：在 <code>State</code> 特徵加上 <code>content</code> 方法</span></p>
<p>我們對 <code>content</code> 方法加上預設實作來回傳一個空字串切片。這代表我們不需要在 <code>Draft</code> 與 <code>PendingReview</code> 結構體實作 <code>content</code>。<code>Published</code> 結構體會覆寫 <code>content</code> 方法並回傳 <code>post.content</code> 的數值。</p>
<p>注意到我們在此方法需要生命週期詮釋，如我們在第十章所討論到的。我們取得 <code>post</code> 的參考作為引數並回傳 <code>post</code> 的部分參考，所以回傳參考的生命週期與 <code>post</code> 引數的生命週期有關聯。</p>
<p>這樣就完成了！範例 17-11 可以成功執行！我們實作了網誌文章工作流程規則的狀態模式。規則邏輯會位於狀態物件中，而不會分散在 <code>Post</code> 中。</p>
<blockquote>
<h4 id="為何不用枚舉"><a class="header" href="#為何不用枚舉">為何不用枚舉？</a></h4>
<p>你可能會好奇為何我們不使用 <code>enum</code> 的變體來表達不同的文章狀態。這的確是個可能的解法，歡迎嘗試親自實作看看，然後比較出你傾向於何者！使用枚舉的缺點會是當你每次想要檢查枚舉數值時，就需要使用 <code>match</code> 表達式或類似的方式才能處理每種變體。這可能會比特徵物件的做法還麻煩。</p>
</blockquote>
<h3 id="狀態模式的權衡取捨"><a class="header" href="#狀態模式的權衡取捨">狀態模式的權衡取捨</a></h3>
<p>我們展示了 Rust 能夠實作出物件導向狀態模式，來封裝文章每個狀態之間不同的行為。<code>Post</code> 的方法不會知道這些不同的行為。我們組織程式碼的方式，讓我們可以只看一個地方就能知道已發佈文章會擁有的各種行為，也就是實作 <code>State</code> 特徵的 <code>Published</code> 結構體。</p>
<p>如果我們要建立個不使用狀態模式的替代實作，我們可能會在 <code>Post</code> 或甚至在 <code>main</code> 程式碼中改使用 <code>match</code> 表達式檢查文章狀態並變更行為。這意味著我們得查看許多地方才能知道已發佈文章狀態的含義！而且當我們增加的狀態越多，每個 <code>match</code> 表達式就需要更多分支。</p>
<p>透過狀態模式，<code>Post</code> 方法以及我們使用 <code>Post</code> 的地方就不需要 <code>match</code> 表達式，而且要加入新的狀態的話，我們只需要新增一個結構體並對其實作特徵方法。</p>
<p>使用狀態模式的實作能非常容易地擴展功能。為了觀察維護使用狀態模式的程式碼有多簡單，你可以嘗試以下一些建議：</p>
<ul>
<li>新增一個 <code>reject</code> 方法讓文章狀態從 <code>PendingReview</code> 變回 <code>Draft</code>。</li>
<li>要求要呼叫兩次 <code>approve</code> 狀態才會變成 <code>Published</code>。</li>
<li>只允許使用者在 <code>Draft</code> 狀態才能新增文字內容。提示：讓狀態物件負責內容會發生什麼改變，但不負責修改 <code>Post</code>。</li>
</ul>
<p>不過狀態模式有個劣勢，由於狀態實作狀態的轉換，有些狀態之間是彼此耦合的。如果我們在 <code>PendingReview</code> 與 <code>Published</code> 之間再加上另一個狀態像是 <code>Scheduled</code> 的話，我們就需要變更 <code>PendingReview</code> 的程式碼改轉換成
<code>Scheduled</code>。如果 <code>PendingReview</code> 不需要因為新狀態的加入做改變的話，我們可以少寫些程式碼，但這就意味著切換成其他種設計模式。</p>
<p>另一項劣勢是我們重複了一些邏輯。要消除掉一些重複的部分，我們可以試著對 <code>State</code> 的 <code>request_review</code> 和 <code>approve</code> 方法提供回傳 <code>self</code> 的預設實作。但是這樣就違反物件安全了，因為特徵不知道 <code>self</code> 的實際型別為何。我們想要能將 <code>State</code> 用在特徵物件中，所以它的方法必須是物件安全的。</p>
<p>另一個重複的部分包含 <code>Post</code> 的 <code>request_review</code> 與 <code>approve</code> 方法都以類似的方式實作。兩者均呼叫 <code>state</code> 欄位中 <code>Option</code> 內數值對應的相同方法。如果 <code>Post</code> 有很多方法都遵循這樣的模式的話，我們可以考慮定義巨集（macro）來消除重複的部分（請查閱第十九章的<a href="ch19-05-macros.html#macros">「巨集」</a><!-- ignore -->段落）。</p>
<p>如其他物件導向語言所定義的來實作狀態模式，我們並沒有完全發揮出 Rust 的所有潛力。讓我們看看我們能對 <code>blog</code> crate 做些什麼改善，讓無效的狀態與轉換會產生成編譯時錯誤。</p>
<h4 id="定義狀態與行為成型別"><a class="header" href="#定義狀態與行為成型別">定義狀態與行為成型別</a></h4>
<p>我們會向你展示如何重新思考狀態模式，來達到不同的取捨效果。與其完全封裝狀態與轉換，讓外部程式碼完全看不到它們，我們會將狀態定義成不同的型別。這樣一來，Rust 的型別檢查系統就能避免在只能使用已發佈文章的地方使用到了文章草稿，並在編譯時就回傳錯誤。</p>
<p>讓我們先想一下範例 17-11 中 <code>main</code> 的第一個部分：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;我今天午餐吃了沙拉&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;我今天午餐吃了沙拉&quot;, post.content());
</span>}
</code></pre>
<p>我們仍使用 <code>Post::new</code> 來建立新文章的草稿狀態以及能對文章內容新增文字的能力。但不同於在文章草稿的 <code>content</code> 方法中回傳空字串，我們這次選擇文章草稿不會實作 <code>content</code> 方法。這樣如果我們嘗試取得文章草稿內容時，我們會得到編譯錯誤告訴我們該方法不存在。如此一來，我們就不可能在生產環境意外顯示出文章草稿內容了，因為程式碼根本不會編譯過。範例 17-19 顯示了 <code>Post</code> 結構體與 <code>DraftPost</code> 結構體的定義，以及它們個別的方法：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
</code></pre>
<p><span class="caption">範例 17-19：<code>Post</code> 有 <code>content</code> 方法，而 <code>DraftPost</code> 則沒有 <code>content</code> 方法</span></p>
<p><code>Post</code> 與 <code>DraftPost</code> 結構體都有個私有欄位 <code>content</code> 來儲存網誌文章文字。結構體不再有 <code>state</code> 欄位，因為我們將狀態的定義移到了結構體的型別中。<code>Post</code> 結構體就代表已發佈的文章，且其有個 <code>content</code> 方法來回傳 <code>content</code>。</p>
<p>我們仍然有 <code>Post::new</code> 函式，但是它沒有回傳 <code>Post</code> 實例，而是回傳了 <code>DraftPost</code> 的實例。因為 <code>content</code> 是私有的，而且沒有任何函式回傳 <code>Post</code>，所以目前沒有任何辦法能建立 <code>Post</code> 的實例。</p>
<p><code>DraftPost</code> 結構體有個 <code>add_text</code> 方法，所以我們可以像之前一樣為 <code>content</code> 新增文字，但注意到 <code>DraftPost</code> 沒有定義 <code>content</code> 方法！所以現在程式確保所有文章都已草稿為起始，而且文章草稿不會提供顯示其內容的方法。任何想嘗試繞過此約束的方式都會產生變意錯誤。</p>
<h4 id="透過不同型別的轉移來實作狀態轉換"><a class="header" href="#透過不同型別的轉移來實作狀態轉換">透過不同型別的轉移來實作狀態轉換</a></h4>
<p>所以我們該怎麼取得發佈的文章呢？我們想要遵守執行的規則，文章草稿在審核並通過後才能夠發佈。在審核中的文章狀態應保持不顯示任何內容。讓我們新增另一個結構體 <code>PendingReviewPost</code> 來遵守這些約束吧。在 <code>DraftPost</code> 中訂一個會回傳 <code>PendingReviewPost</code> 的 <code>request_review</code> 方法，再對 <code>PendingReviewPost</code> 定義 <code>approve</code> 方法來回傳 <code>Post</code>，如範例 17-20 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --省略--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
</code></pre>
<p><span class="caption">範例 17-20：呼叫 <code>DraftPost</code> 的 <code>request_review</code> 來建立 <code>PendingReviewPost</code>，且其有個 <code>approve</code> 方法能將 <code>PendingReviewPost</code> 轉換成已發佈的 <code>Post</code></span></p>
<p><code>request_review</code> 與 <code>approve</code> 方法都會取得 <code>self</code> 的所有權，因此會消耗 <code>DraftPost</code> 與 <code>PendingReviewPost</code> 實例，並分別轉換成 <code>PendingReviewPost</code> 與已發佈的 <code>Post</code>。這樣在我們呼叫 <code>request_review</code> 時，就不會有殘留的 <code>DraftPost</code> 實例，以此類推。<code>PendingReviewPost</code> 結構體也沒有定義 <code>content</code> 方法，所以嘗試讀取其內容會導致編譯錯誤，就如同 <code>DraftPost</code>。由於唯一能取得有 <code>content</code> 方法定義的已發佈 <code>Post</code> 是透過呼叫 <code>PendingReviewPost</code> 的 <code>approve</code> 方法，而唯一能取得 <code>PendingReviewPost</code> 的方法是呼叫 <code>DraftPost</code> 的 <code>request_review</code> 方法，我們現在將網誌文章工作流程寫進了型別系統中。</p>
<p>但我們也得對 <code>main</code> 做些小修改。<code>request_review</code> 與 <code>approve</code> 方法會回傳新的實例，而不是修改它們所呼叫的結構體，所以我們需要加些 <code>let post =</code> 來遮蔽賦值來儲存回傳的實例。我們也無法判定草稿與審核中的文章內容是否是空字串，不過我們其實也不需要它們，我們不再能編譯嘗試讀取這些狀態文章內容的程式碼了。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;我今天午餐吃了沙拉&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;我今天午餐吃了沙拉&quot;, post.content());
}
</code></pre>
<p><span class="caption">範例 17-21：修改 <code>main</code> 來使用新的網誌文章工作流程實作</span></p>
<p>我們修改 <code>main</code> 來重新賦值 <code>post</code> 意味著此實作不再遵循物件導向狀態模式了，狀態的轉換不再完全封裝在 <code>Post</code> 實作內部。然而我們得到的好處是的是無效狀態是不可能發生的了，這都多虧了型別系統與編譯時型別檢查！這確保了特定程式錯誤會在進入生產環境前就被察覺，像是顯示尚未發佈的文章內容。</p>
<p>你可以試試看在範例 17-20 之後，對 <code>blog</code> crate 實作稍早提及的額外需求任務建議，來看看你覺得此版本的程式碼設計如何。注意有些任務很可能在此設計就已經實作完成了。</p>
<p>我們看到儘管 Rust 能夠實作物件導向設計模式、其他像是將狀態寫入型別系統中的模式在 Rust 中也是可行的。這些模式有不同的取捨。雖然你可能非常熟悉物件導向模式，但重新思考問題，並善用 Rust 的特色可以帶來不少優勢，像是在執行時就避免錯誤發生。物件導向模式在 Rust 中不會永遠是最好的解決方案，因為 Rust 有像是所有權這樣物件導向語言所沒有的特定功能。</p>
<h2 id="總結-16"><a class="header" href="#總結-16">總結</a></h2>
<p>無論你讀完此章後，認為 Rust 是否屬於物件導向語言，你都知道在 Rust 中你可以使用特徵物件來取得一些物件導向的特色。動態分配能給予你的程式碼更多的彈性，但會犧牲一點執行時效能。你可以使用此彈性來實作物件導向模式，幫助提升程式碼可維護性。Rust 還有其他像是所有權等物件導向語言所沒有的功能。物件導向模式不會永遠是善用 Rust 潛能的最佳方案，不過仍是個不錯的選項。</p>
<p>接下來，我們要看看模式（patterns），這是 Rust 另一個可以提供大量彈性的功能。我們在書中一路下來簡單看過它們好幾次了，不過我們還沒見識到它們全部的本事。讓我們來探索吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式與配對"><a class="header" href="#模式與配對">模式與配對</a></h1>
<p><strong>模式</strong>（Patterns）是 Rust 中的特殊語法，能用來配對複雜與簡單的型別結構。搭配 <code>match</code> 表達式與其他結構來使用模式的話，可以給予你對程式控制流更多的掌控權。模式與以下元件組合而成：</p>
<ul>
<li>字面值（Literals）</li>
<li>解構的陣列、枚舉結構體或元組</li>
<li>變數</li>
<li>萬用字元（Wildcards）</li>
<li>佔位符（Placeholders）</li>
</ul>
<p>模式的範例包含 <code>x</code>、<code>(a, 3)</code> 以及 <code>Some(Color::Red)</code>。當我們提到哪些模式是有效的時候，這些元件描述了我們要處理的資料形狀。我們的程式與其數值配對來決定我們的程式是否有取得正確的資料來繼續執行特定部分的程式碼。</p>
<p>要使用模式，我們將其與一些數值做比較。如果模式配對到數值的話，我們就能在程式碼中使用該數值部分。回憶一下第六章中使用模式的 <code>match</code> 表達式，像是硬幣分類機器的範例。如果有數值符合模式的形狀，我們就可以使用這些命名的部分。如果沒有的話，配對相關的程式碼就不會執行。</p>
<p>本章節會涵蓋所有與模式相關的內容。我們會討論能使用模式的地方，可反駁（refutable）與不可反駁（irrefutable）模式間的差別，以及不同種類的模式語法。在本章結束後，你便能知道如何使用模式來清楚表達許多概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="所有能使用模式的地方"><a class="header" href="#所有能使用模式的地方">所有能使用模式的地方</a></h2>
<p>模式常出現於 Rust 中數個位置，而你已經不經意使用了很多模式了！此段落會介紹所有模式能有效出現的地方。</p>
<h3 id="match-分支"><a class="header" href="#match-分支"><code>match</code> 分支</a></h3>
<p>如同第六章所討論過的，我們可以在 <code>match</code> 表達式中的分支使用模式。正式來說，<code>match</code> 表達式的定義為 <code>match</code> 關鍵字加上一個要配對的數值，然後會有一或數個包含模式的分支，以及如果數值配對到該分支模式之後要執行的表達式，如以下所示：</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>舉例來說，以下是範例 6-5 的變數 <code>x</code> 對 <code>Option&lt;i32&gt;</code> 進行配對：</p>
<pre><code class="language-rust ignore">match x {
    None =&gt; None,
    Some(i) =&gt; Some(i + 1),
}
</code></pre>
<p>在此 <code> match</code> 表達式中的模式有 <code>None</code> 與 <code>Some(i)</code>，顯示在每個箭頭的左方。</p>
<p><code>match</code> 表達式有個要求就是它們必須是<strong>徹底的（exhaustive）</strong>，所有 <code>match</code> 表達式數值可能的結果都必須涵蓋到。其中一個確保你有考慮到所有可能性的方式是在最後一個分支使用捕獲模式，命名一個能配對任何數值的變數就絕不會失敗，因此可以涵蓋剩餘的情況。</p>
<p>還有一個特定模式 <code>_</code> 可以獲取任意可能情況，但它不會綁定到變數中，所以它也很常用在最後的配對分支。舉例來說，<code>_</code> 模式就很適合用來忽略任何沒指明的數值。我們會在本章之後的 <a href="ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%95%B8%E5%80%BC">「忽略模式中的數值」</a><!-- ignore -->段落談到更多 <code>_</code> 的細節。</p>
<h3 id="if-let-條件表達式"><a class="header" href="#if-let-條件表達式"><code>if let</code> 條件表達式</a></h3>
<p>在第六章中我們介紹了如何使用 <code>if let</code> 表達式，它等同於只配對一種情況的 <code>match</code> 表達式，主要作為更簡潔的語法。此外，<code>if let</code> 可以再加上 <code>else</code> 來包含如果 <code>if let</code> 模式不符的話能執行的程式碼。</p>
<p>範例 18-1 展示了我們能夠混合並配對 <code>if let</code>、<code>else if</code> 與 <code>else if let</code> 表達式。這樣做可以比 <code>match</code> 表達式還來得有彈性，因為 <code>match</code> 只能有一個數值與模式們配對。另外，Rust 也不需要 <code>if let</code>、<code>else if</code> 與 <code>else if let</code> 分支之間的條件彼此要有關聯。</p>
<p>範例 18-1 的程式碼依據一系列的條件檢查來決定背景顏色該為何。在此例中，我們建立一個寫死的變數數值，在實際程式中應該會由使用者輸入。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;使用你最喜歡的顏色{color}作為背景&quot;);
    } else if is_tuesday {
        println!(&quot;星期二就用綠色！&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;使用紫色作為背景顏色&quot;);
        } else {
            println!(&quot;使用橘色作為背景顏色&quot;);
        }
    } else {
        println!(&quot;使用藍色作為背景顏色&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-1：混合 <code>if let</code>、<code>else if</code>、<code>else if let</code> 與 <code>else</code></span></p>
<p>如果使用者指定的最喜歡的顏色，該顏色就是背景顏色。如果沒有喜歡的顏色且今天是星期二的話，背景顏色就是綠色。如果使用者用字串指定他們的年齡且可以成功轉換成數字的話，背景顏色依據數字結果就是紫色或橘色。如果以上條件都不符合的話，背景顏色就是藍色。</p>
<p>這樣的條件結構讓我們可以支援複雜的需求。透過我們在此寫死的數值，此例會印出 <code>使用紫色作為背景顏色</code>。</p>
<p>你可以看到 <code>if let</code> 也能如同 <code>match</code> 的分支一樣遮蔽變數，<code>if let Ok(age) = age</code> 這行就產生了新的遮蔽變數 <code>age</code> 來包含 <code>Ok</code> 變體內的數值。這意味著我們需要將 <code>if age &gt; 30</code> 的條件放在區塊內，我們不能組合這兩個條件成 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>。遮蔽的 <code>age</code> 在大括號開始之後的新作用域才有效，此時才能與 30 做比較。</p>
<p>使用 <code>if let</code> 表達式的缺點是編譯器不會徹底檢查，而 <code>match</code> 表達式則會。如果我們省略最後一個 <code>else</code> 區塊而因此忘了處理一些情況，編譯器不會警告我們這種可能的邏輯錯誤。</p>
<h3 id="while-let-條件迴圈"><a class="header" href="#while-let-條件迴圈"><code>while let</code> 條件迴圈</a></h3>
<p>與 <code>if let</code> 的結構類似，<code>while let</code> 條件迴圈允許 <code>while</code> 迴圈只要在模式持續配對符合的情況下一直執行。在範例 18-2 的例子我們寫了一個 <code>while let</code> 迴圈使用向量做為堆疊，並以數值被插入向量時相反的順序印出它們。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-2：使用 <code>while let</code> 迴圈，且只要 <code>stack.pop()</code> 有回傳 <code>Some</code> 就持續印出數值</span></p>
<p>此範例會依序顯示 3、2 然後是 1。<code>pop</code> 方法會取得向量最後一個數值並回傳 <code>Some(value)</code>。如果向量是空的，<code>pop</code> 就回傳 <code>None</code>。只要 <code>pop</code> 有回傳 <code>Some</code>，<code>while</code> 迴圈就會持續執行其區塊中的程式碼。當 <code>pop</code> 回傳 <code>None</code> 時，迴圈就會結束。我們可以使用 <code>while let</code> 來取得堆疊彈出的每個數值。</p>
<h3 id="for-迴圈"><a class="header" href="#for-迴圈"><code>for</code> 迴圈</a></h3>
<p>在 <code>for</code> 迴圈中，<code>for</code> 關鍵字之後的數值就是模式。舉例來說，在 <code>for x in y</code> 中 <code>x</code> 就是模式範例 18-3 展示了如何在 <code>for</code> 迴圈使用模式來解構或拆開一個 <code>for</code> 迴圈中的元組。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} 位於索引 {}&quot;, value, index);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-3：使用模式來解構 <code>for</code> 迴圈中的元組</span></p>
<p>範例 18-3 的程式碼會顯示以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a 位於索引 0
b 位於索引 1
c 位於索引 2
</code></pre>
<p>我們使用 <code>enumerate</code> 方法來配接一個疊代器來產生一個數值與該數值在疊代器中的索引，並放入元組中。第一個產生的數值爲元組 <code>(0, 'a')</code>。當此數值配對到 <code>(index, value)</code> 模式時，<code>index</code> 會是 <code>0</code> 而 <code>value</code> 會是 <code>'a'</code>，並印出第一行的輸出。</p>
<h3 id="let-陳述式"><a class="header" href="#let-陳述式"><code>let</code> 陳述式</a></h3>
<p>在本章節之前，我們只有告訴你模式能用在 <code>match</code> 和 <code>if let</code>，但事實上我們在其他地方也早就使用過模式了，這包含 <code>let</code> 陳述式。舉例來說，請看看以下這個使用 <code>let</code> 賦值變數的直白例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>每次當你像這樣使用 <code>let</code> 陳述式時，你就已經在使用模式了，儘管你還沒有察覺到！所以更正式地來說，<code>let</code> 陳述式是這樣定義的：</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>像 <code>let x = 5;</code> 這樣的陳述式中變數名稱會位於 <code>PATTERN</code> 的位置，變數名稱恰好是種特別簡單的模式。Rust 會將表達式與模式做比較，並賦值給它找到的任何名稱。所以在 <code>let x = 5;</code> 的範例中，<code>x</code> 是個模式並表示「將配對到的數值綁定給變數 <code>x</code>」。因為名稱 <code>x</code> 就是整個模式，此模式實際上等同於「將任何數值綁定給變數 <code>x</code>，無論該數值為何」。</p>
<p>為了更清楚理解 <code>let</code> 怎麼使用模式配對，請參考範例 18-4，這對 <code>let</code> 使用模式來解構一個元組。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-4：使用模式來解構元組，並同時建立三個變數</span></p>
<p>我們在此用一個元組來配對一個模式。Rust 會將數值 <code>(1, 2, 3)</code> 與模式 <code>(x, y, z)</code> 做比較，並看出數值能配對到模式中，所以 Rust 將 <code>1</code> 綁定給 <code>x</code>、<code>2</code> 給 <code>y</code> 然後 <code>3</code> 給 <code>z</code>。你可以把此元組模式想成是三個獨立的變數模式組合在一起。</p>
<p>如果模式中的元素個數與元組中的元素個數不符合的話，整體型別就無法配對，所以我們會得到編譯錯誤。舉例來說，範例 18-5 嘗試將有三個元素的元組解構到兩個變數中，這樣就無法成功。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-5：錯誤的模式結構，因為變數數量與元組元素個數不符</span></p>
<p>嘗試編譯此程式碼的話，會得到此型別錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>要修正錯誤的話，我們可以使用 <code>_</code> 或 <code>..</code> 來忽略元組中的一或數個數值，你會在<a href="ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%95%B8%E5%80%BC">「忽略模式中的數值」</a><!-- ignore -->段落中瞭解更多詳情。如果問題出在於我們模式中有太多變數的話，解決辦法就是移除些變數使變數數量等同於元組元素個數，讓型別可以配對。</p>
<h3 id="函式參數"><a class="header" href="#函式參數">函式參數</a></h3>
<p>函式參數也可以是模式。範例 18-6 的程式碼宣告了一個函式叫做 <code>foo</code> 來接收一個參數叫做 <code>x</code> 其型別為 <code>i32</code>，現在這看起來你應該都還很熟悉。</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // 內部的程式碼
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 18-6：在參數中使用模式的函式簽名</span></p>
<p><code>x</code> 的部分就是模式！就如同我們在 <code>let</code> 所做的一樣，我們可以在函式引數中使用模式來配對元組，範例 18-7 將傳遞給函式的元組拆為不同數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;目前位置：({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">範例 18-7：函式透過參數來解構元組</span></p>
<p>此程式碼會顯示 <code>目前位置：(3, 5)</code>。數值 <code>&amp;(3, 5)</code> 能配對到模式 <code>&amp;(x, y)</code>，所以 <code>x</code> 會是數值 <code>3</code> 而 <code>y</code> 會是數值 <code>5</code>。</p>
<p>我們還可以在閉包參數列表中像函式參數列表這樣使用模式，因為第十三章就提過閉包類似於函式。</p>
<p>到目前為止，你已經見過許多使用模式的方式，但模式在我們能使用的地方並不都會有相同的行為。在某些地方，模式必須是不可反駁的（irrefutable），而在其他場合它們則是可反駁的（refutable）。接下來我們會來討論這兩個概念。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="可反駁性何時模式可能會配對失敗"><a class="header" href="#可反駁性何時模式可能會配對失敗">可反駁性：何時模式可能會配對失敗</a></h2>
<p>模式有兩種形式：可反駁的（refutable）與不可反駁的（irrefutable）。可以配對任何可能數值的模式屬於<strong>不可反駁的（irrefutable）</strong>。其中一個例子就是陳述式 <code>let x = 5;</code> 中的 <code>x</code>，因為 <code>x</code> 可以配對任何數值，因此不可能會配對失敗。而可能會對某些數值配對失敗的模式則屬於<strong>可反駁的（refutable）</strong>。其中一個例子是表達式 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code>，因為如果 <code>a_value</code> 變數中的數值為 <code>None</code> 而非 <code>Some</code> 的話， <code>Some(x)</code> 模式就會配對失敗。</p>
<p>函式參數、<code>let</code> 陳述式與 <code>for</code> 迴圈只能接受不可反駁的模式，當數值無法配對時，程式無法作出任何有意義的事。<code>if let</code> 與 <code>while let</code> 表達式接受可反駁與不可反駁的模式，但是編譯器會警告不可反駁的模式，因為定義上來說它們用來處理可能會失敗的場合，條件表達式的功能就是依據成功或失敗來執行不同動作。</p>
<p>大致上來說，你通常不需要擔心可反駁與不可反駁模式之間的區別，不過你會需要熟悉可反駁性這樣的概念，所以當你看到錯誤訊息時，能及時反應理解。在這樣的場合，你需要依據程式碼的預期行為來改變模式或是使用模式的結構。</p>
<p>讓我們看看當我們嘗試在 Rust 要求不可反駁模式的地方使用可反駁模式的範例與其反例。範例 18-8 顯示了一個 <code>let</code> 陳述式，但是我們指定的模式是 <code>Some(x)</code>，這是可反駁模式。如我們所預期的，此程式碼無法編譯。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-8：嘗試在 <code>let</code> 使用可反駁模式</span></p>
<p>如果 <code>some_option_value</code> 是數值 <code>None</code>，它會無法與模式 <code>Some(x)</code> 做配對，這意味著此模式是可反駁的。但是 <code>let</code> 陳述式只能接受不可反駁的模式，因為 程式碼對 <code>None</code> 數值就無法作出任何有效的動作。在編譯時 Rust 就會抱怨我們嘗試在需要不可反駁模式的地方使用了可反駁模式：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
   --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
note: `Option&lt;i32&gt;` defined here
  = note: the matched value is of type `Option&lt;i32&gt;`
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     let x = if let Some(x) = some_option_value { x } else { todo!() };
  |     ++++++++++                                 ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns` due to previous error
</code></pre>
<p>因為 <code>Some(x)</code> 模式沒有涵蓋（且也涵蓋不了！）所有有效的數值，Rust 合理地產生了編譯錯誤。</p>
<p>如果我們在需要不可反駁模式的地方使用可反駁模式的錯誤，我們可以變更程式碼使用模式的方式來修正：與其使用 <code>let</code>，我們可以改用 <code>if let</code>。這樣如果模式不符的話，程式碼就會跳過大括號中的程式碼，讓我們可以繼續有效執行下去。範例 18-9 顯示了如何修正範例 18-8 的程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-9：使用 <code>if let</code> 而非 <code>let</code> 來使用可反駁模式</span></p>
<p>我們給了程式碼出路！此程式碼可以完美執行，雖然這也代表我們使用不可反駁模式的話會得到一些警告。如果我們給予 <code>if let</code> 一個像是 <code>x</code> 這樣永遠能配對的模式的話，編譯器會出現警告，如範例 18-10 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-10：嘗試在 <code>if let</code> 使用不可反駁的模式</span></p>
<p>Rust 會抱怨說在 <code>if let</code> 使用不可反駁的模式沒有任何意義：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable `if let` pattern
 --&gt; src/main.rs:2:8
  |
2 |     if let x = 5 {
  |        ^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

warning: `patterns` (bin &quot;patterns&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>基於此原因，<code>match</code> 的分支必須是可反駁模式。除了最後一個分支因為要配對任何剩餘數值，所以會是不可反駁模式。Rust 允許我們在 <code>match</code> 只使用一個不可反駁模式的分支，不過這樣做並不是很實用，且可以直接用簡單的 <code>let</code> 陳述式取代。</p>
<p>現在你知道哪裡能使用模式，以及可反駁與不可反駁模式的不同了。讓我們來涵蓋模式建立時可以使用的所有語法吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模式語法"><a class="header" href="#模式語法">模式語法</a></h2>
<p>在此段落中，我們會收集所有模式中的有效語法，並討論你會怎麼使用它們。</p>
<h3 id="配對字面值"><a class="header" href="#配對字面值">配對字面值</a></h3>
<p>如同你在第六章所見的，你可以直接使用字面值來配對模式，以下程式碼展示了一些範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;一&quot;),
        2 =&gt; println!(&quot;二&quot;),
        3 =&gt; println!(&quot;三&quot;),
        _ =&gt; println!(&quot;任意數字&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會顯示「一」因為 x 的數值為 1。此語法適用於當你想要程式碼取得一個特定數值時，就馬上採取行動的情況。</p>
<h3 id="配對變數名稱"><a class="header" href="#配對變數名稱">配對變數名稱</a></h3>
<p>變數名稱是能配對任何數值的不可反駁模式，而且我們在本書中已經使用非常多次。不過當你在 <code>match</code> 表達式中使用變數名稱時會複雜一點。因為 <code>match</code> 會初始一個新的作用域，作為 <code>match</code> 表達式部分模式的宣告變數會遮蔽 <code>match</code> 結構外同名的變數，和所有變數一樣。在範例 18-11 中，我宣告了一個變數叫做 <code>x</code> 其有數值 <code>Some(5)</code> 和一個變數 <code>y</code> 其有數值 <code>10</code>。然後我們建立一個數值 <code>x</code> 的 <code>match</code> 表達式。檢查配對分之中的模式並在最後用 <code>println!</code> 顯示出來，並嘗試在程式碼執行或進一步閱讀之前推測其會顯示的結果會為何。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;取得 50&quot;),
        Some(y) =&gt; println!(&quot;配對成功，y = {y}&quot;),
        _ =&gt; println!(&quot;預設情形，x = {:?}&quot;, x),
    }

    println!(&quot;最後結果：x = {:?}, y = {y}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-11：<code>match</code> 表達式其中一個分支宣告了遮蔽的變數 <code>y</code></span></p>
<p>讓我們跑一遍看看當 <code>match</code> 執行時發生了什麼事。第一個配對分支並不符合 <code>x</code> 定義的數值，所以程式繼續執行下去。</p>
<p>第二個配對分支宣告了一個新的變數叫做 <code>y</code> 來配對 <code>Some</code> 內的任何數值。因為我們位於 <code>match</code> 表達式內的新作用域，此新的 <code>y</code> 變數並不是我們一開始宣告有數值 10 的 <code>y</code>。這個新的 <code>y</code> 會配對 <code>Some</code> 內的任何數值，也就是 <code>x</code> 擁有的數值。因此，這個新的 <code>y</code> 會綁定 <code>x</code> 中 <code>Some</code> 的內部數值。該數值是 <code>5</code>，所以該分支的表達式就會執行並印出 <code>配對成功，y = 5</code>。</p>
<p>如果 <code>x</code> 是 <code>None</code> 數值而非 <code>Some(5)</code> 的話，前兩個分支的模式都不會配對到，所以數值會配對到底線的分支。我們沒有在底線分支的模式中宣告 <code>x</code> 變數，所以表達式中的 <code>x</code> 仍然是外部沒有被遮蔽的 <code>x</code> 。在這樣的假設狀況下，<code>match</code> 會印出 <code>預設情形，x = None</code>。</p>
<p>當 <code>match</code> 完成時，其作用域就會結束，所以作用域內的內部 <code>y</code> 也會結束。最後一個 <code>println!</code> 會顯示 <code>最後結果：x = Some(5), y = 10</code>。</p>
<p>要建立個能對外部 <code>x</code> 與 <code>y</code> 數值做比較的 <code>match</code> 表達式而非遮蔽變數的話，我們需要改用條件配對守護。我們會在之後的<a href="ch18-03-pattern-syntax.html#%E6%8F%90%E4%BE%9B%E9%A1%8D%E5%A4%96%E6%A2%9D%E4%BB%B6%E7%9A%84%E9%85%8D%E5%B0%8D%E5%AE%88%E8%AD%B7">「提供額外條件的配對守護」</a><!-- ignore -->段落討論配對守護。</p>
<h3 id="多重模式"><a class="header" href="#多重模式">多重模式</a></h3>
<p>在 <code>match</code> 表達式中，你可以使用 <code>|</code> 語法來配對數個模式，這是 <strong>OR（或）</strong> 運算子模式。舉例來說，以下程式碼會配對 <code>x</code> 的數值到配對分支，第一個分支有個 <em>OR</em> 的選項，代表如果 <code>x</code> 的數值配對的到分支中任一數值的話，該分支的程式碼就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;一或二&quot;),
        3 =&gt; println!(&quot;三&quot;),
        _ =&gt; println!(&quot;任意數字&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出 <code>一或二</code>。</p>
<h3 id="透過--配對數值範圍"><a class="header" href="#透過--配對數值範圍">透過 <code>..=</code> 配對數值範圍</a></h3>
<p><code>..=</code> 語法讓我們可以配對一個範圍內包含的數值。在以下程式碼中，當模式配對的到範圍內的任何數值時，該分支就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;一到五&quot;),
        _ =&gt; println!(&quot;其他&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5 的話，第一個分支就能配對到。在配對多重數值時，此語法比使用 <code>|</code> 運算子來表達相同概念還輕鬆得多。如果我們使用 <code>|</code> 的話，就得指明 <code>1 | 2 | 3 | 4 | 5</code> 而非 <code>1..=5</code>。指定範圍相對就簡短許多，尤其是如果我們得配對像是數字 1 到 1,000 的話！</p>
<p>編譯器會在編譯時檢查範圍是否為空，然後因為<code>char</code> 與數字數值是 Rust 中唯一能判斷範圍是否為空的型別，所以範圍只允許使用數字或 <code>char</code> 數值。</p>
<p>以下是使用 <code>char</code> 數值作為範圍的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;前半部 ASCII 字母&quot;),
        'k'..='z' =&gt; println!(&quot;後半部 ASCII 字母&quot;),
        _ =&gt; println!(&quot;其他&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust 可以知道 <code>'c'</code> 有包含在第一個模式的範圍內，所以印出 <code>前半部 ASCII 字母</code>。</p>
<h3 id="解構拆開數值"><a class="header" href="#解構拆開數值">解構拆開數值</a></h3>
<p>我們可以使用模式來解構結構體、枚舉與元組，以便使用這些數值的不同部分。讓我們依序來看看。</p>
<h4 id="解構結構體"><a class="header" href="#解構結構體">解構結構體</a></h4>
<p>範例 18-12 有個結構體 <code>Point</code> 其有兩個欄位 <code>x</code> 與 <code>y</code>，我們可以在 <code>let</code> 陳述式使用模式來拆開它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">範例 18-12：解構結構體欄位成獨立的變數</span></p>
<p>此程式碼建立了變數 <code>a</code> 與 <code>b</code> 來配對 <code>p</code> 結構體中 <code>x</code> 與 <code>y</code> 的欄位。此範例顯示出模式中的變數名稱不必與結構體中的欄位名稱一樣。不過通常還是建議變數名稱與欄位名稱一樣，以便記得哪些變數來自於哪個欄位。因為用變數名稱來配對欄位是十分常見的，而且因為 <code>let Point { x: x, y: y } = p;</code> 會包含許多重複部分，所以配對結構體欄位的模式有另一種簡寫方式，你只需要列出結構體欄位的名稱，這樣從結構體建立的變數名稱就會有相同名稱。範例 18-13 顯示的程式碼行為與範例 18-12 一樣，但是在 <code>let</code> 模式建立的變數是 <code>x</code> 與 <code>y</code> 而非 <code>a</code> 與 <code>b</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">範例 18-13：使用結構體欄位簡寫來解構結構體欄位</span></p>
<p>此程式碼建立了變數 <code>x</code> 與 <code>y</code> 並配對到變數 <code>p</code> 的 <code>x</code> 與 <code>y</code> 欄位。結果就是變數 <code>x</code> 與 <code>y</code> 會包含 <code>p</code> 結構體中的數值。</p>
<p>我們也可以將字面值數值作為結構體模式中的一部分，而不用建立所有欄位的變數。這樣做我們可以在解構一些欄位成變數時，測試其他欄位是否有特定數值。</p>
<p>在範例 18-14 的 <code>match</code> 表達式將 <code>Point</code> 的數值分成三種情況：位於 <code>x</code> 軸的點（也就是 <code>y = 0</code>）、位於 <code>y</code> 軸的點（<code>x = 0</code>）或不在任何軸的點。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;位於 x 軸的 {x}&quot;),
        Point { x: 0, y } =&gt; println!(&quot;位於 y 軸的 {y}&quot;),
        Point { x, y } =&gt; println!(&quot;不在任一軸：({x}, {y})&quot;),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-14：解構並配對模式中的字面值數值</span></p>
<p>第一個分支透過指定 <code>y</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>x</code> 軸上的點。此模式仍然會建立變數 <code>x</code> 能讓我們在此分支的程式碼中使用。</p>
<p>同樣地，第二個分支透過指定 <code>x</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>y</code> 軸上的點，並建立擁有 <code>y</code> 欄位數值的變數 <code>y</code>。第三個分支沒有指定任何字面值，所以它能配對任何其他 <code>Point</code> 並建立 <code>x</code> 與 <code>y</code> 欄位對應的變數。</p>
<p>在此例中，數值 <code>p</code> 會配對到第二個分支，因為其 <code>x</code> 為 0，所以此程式碼會印出 <code>位於 y 軸的 7</code>。</p>
<p>回想一下 <code>match</code> 表達式在找到第一個符合的配對模式之後就會停止檢查分支，所以就算 <code>Point { x: 0, y: 0}</code> 真的在 <code>x</code> 軸與 <code>y</code> 軸，此程式碼也只會印出 <code>On the x axis at 0</code>。</p>
<h4 id="解構枚舉"><a class="header" href="#解構枚舉">解構枚舉</a></h4>
<p>我們已經在本書中之前的章節就解構過枚舉（比如第六章的範例 6-5）。但我們還沒談到的細節是解構枚舉的模式必須與枚舉定義中其所儲存的資料相符。作為示範，我們在範例 18-15 中使用範例 6-2 的 <code>Message</code> 枚舉並寫一個 <code>match</code> 來提供會解構每個內部數值的模式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;Quit 變體沒有資料能解構。&quot;);
        }
        Message::Move { x, y } =&gt; {
            println!(&quot;Move 往 x 的方向為 {x} 且往 y 的方向為 {y}&quot;);
        }
        Message::Write(text) =&gt; println!(&quot;文字訊息：{text}&quot;),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(&quot;變更顏色為紅色 {r}、綠色 {g} 與藍色 {b}&quot;)
        }
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-15：解構持有不同種數值的枚舉變體</span></p>
<p>此程式碼會印出 <code>變更顏色為紅色 0、綠色 160 與藍色 255</code>。請嘗試變更 <code>msg</code> 的數值來看看其他分支的程式碼會執行出什麼。</p>
<p>對於像是 <code>Message::Quit</code> 這種沒有任何資料的枚舉，我們無法進一步解構出任何資料。我們只能配對其本身的數值 <code>Message::Quit</code>，所以在該模式中沒有任何變數。</p>
<p>對於像是 <code>Message::Move</code> 這種類結構體枚舉變體，我們可以使用類似於指定配對結構體的模式。在變體名稱之後，我們加上大括號以及列出欄位名稱作為變數，讓我們能拆成不同部分並在此分支的程式碼中使用。我們在此使用範例 18-13 一樣的簡寫形式。</p>
<p>對於像是 <code>Message::Write</code> 這種持有一個元素，以及 <code>Message::ChangeColor</code> 這種持有三個元素的類元組枚舉變體，我們可以使用類似於配對元組的模式。模式中的變數數量必須與我們要配對的變體中元素個數相符。</p>
<h4 id="解構巢狀結構體與枚舉"><a class="header" href="#解構巢狀結構體與枚舉">解構巢狀結構體與枚舉</a></h4>
<p>到目前為止，我們所有的結構體或枚舉配對範例的深度都只有一層，但配對也可以用於巢狀項目中！舉例來說，我們可以重構範例 18-15 的程式碼，在 <code>ChangeColor</code> 中支援 RGB 與 HSV 顏色，如範例 18-16 所示。</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(&quot;變更顏色為紅色 {r}、綠色 {g} 與藍色 {b}&quot;);
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(&quot;變更顏色為色相 {h}、飽和度 {s} 與明度 {v}&quot;);
        }
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-16：配對巢狀枚舉</span></p>
<p><code>match</code> 表達式的第一個分支模式會配對包含 <code>Color::Rgb</code> 變體的 <code>Message::ChangeColor</code> 枚舉變體，然後該模式會綁定內部三個 <code>i32</code> 數值。第二個分支也是配對到 <code>Message::ChangeColor</code> 枚舉變體，但是內部枚舉會改配對 <code>Color::Hsv</code>。我們可以在一個 <code>match</code> 表達式指定這些複雜條件，即使有兩個枚舉參與其中。</p>
<h4 id="解構結構體與元組"><a class="header" href="#解構結構體與元組">解構結構體與元組</a></h4>
<p>我們甚至可以用更複雜的方式來混合、配對並巢狀解構模式。以下範例展示了一個複雜的結構模式，其將一個結構體與一個元組置於另一個元組中，並將所有的原始數值全部解構出來：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼讓我們將複雜的型別拆成部分元件，讓我們可以分別使用我們有興趣的數值。</p>
<p>解構模式是個能方便使用部分數值的方式，比如結構體每個欄位分別獨立的數值。</p>
<h3 id="忽略模式中的數值"><a class="header" href="#忽略模式中的數值">忽略模式中的數值</a></h3>
<p>你已經看過有時候在模式中忽略數值是很實用的，像是在 <code>match</code> 中的最後一個分支能捕獲所有剩餘用不到的可能數值。模式有一些方式可以忽略所有或部分數值：使用（你已經看過的） <code>_</code> 模式、在其他模式使用 <code>_</code> 模式、在名稱前加上底線，或是使用 <code>..</code> 來忽略剩餘部分的數值。讓我們來探討如何與為何要使用這些模式吧。</p>
<h4 id="透過-_-忽略整個數值"><a class="header" href="#透過-_-忽略整個數值">透過 <code>_</code> 忽略整個數值</a></h4>
<p>我們使用底線在來作為萬用字元（wildcard）模式，這會配對任何數值，但不會綁定其值。雖然底線 <code>_</code> 模式特別適合作為 <code>match</code> 表達式最後一個分支，但我們可以將它用在任何模式中，包含函式參數，如範例 18-17 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;此程式碼只使用了參數 y：{}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">範例 18-17：在函式簽名中使用 <code>_</code></span></p>
<p>此程式碼會完全忽略第一個引數傳入的數值 <code>3</code>，並會印出 <code>此程式碼只使用了參數 y：4</code>。</p>
<p>在大多數情況中如果當你不再需要特定函式參數的話，你會直接變更簽名讓它不會包含沒有使用到的參數。但忽略函式參數在某些場合會很有用。舉例來說，當你實作的特徵有個特定的型別簽名，但是你實作的函式本體不需要其中某個參數。這樣你就不會被編譯器警告沒有使用到的函式參數，會當做你有使用參數名稱一樣。</p>
<h4 id="透過巢狀-_-忽略部分數值"><a class="header" href="#透過巢狀-_-忽略部分數值">透過巢狀 <code>_</code> 忽略部分數值</a></h4>
<p>我們也可以在其他模式中使用 <code>_</code> 來忽略部分數值。舉例來說，當我們只想測試部分數值，但不會用到執行的程式碼中其他部分數值的情況。範例 18-18 的程式碼負責管理設定值的數值。業務要求使用者不能覆寫已經存在的自訂數訂值，但可以取消設定值，也可以在目前未設定時提供數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;無法覆寫已經存在的自訂數值&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;設定為 {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-18：當我們不需要使用 <code>Some</code> 內部數值時，在模式中使用底線來配對 <code>Some</code> 變體</span></p>
<p>此程式碼會印出 <code>無法覆寫已經存在的自訂數值</code> 接著印出 <code>設定為 Some(5)</code>。在第一個配對分支中，我們不需要去配對或使用任一 <code>Some</code> 變體內的數值，但我們的確需要檢測  <code>setting_value</code> 與 <code>new_setting_value</code> 是否都為 <code>Some</code> 變體的情況。在此情況下，我們印出為何不能變更 <code>setting_value</code>，且不讓它被改變。</p>
<p>在其他所有情況下（無論是 <code>setting_value</code> 還是 <code>new_setting_value</code> 為 <code>None</code>），我們用第二個分支的 <code>_</code> 模式來配對，我們讓 <code>new_setting_value</code> 變成 <code>setting_value</code>。</p>
<p>我們也可以在同個模式中的多重位置使用底線來忽略特定數值。範例 18-19 忽略了有五個元素的元組中第二個與第四個數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;一些數字：{first}、{third}、{fifth}&quot;)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-19：忽略元組中數個位置</span></p>
<p>此程式碼會印出 <code>一些數字2、8、32</code>，然後數值 4 與 16 會被忽略。</p>
<h4 id="在名稱前加上-_-來忽略未使用的變數"><a class="header" href="#在名稱前加上-_-來忽略未使用的變數">在名稱前加上 <code>_</code> 來忽略未使用的變數</a></h4>
<p>如果你建立了一個變數但沒有在任何地方使用到它，Rust 通常會提出警告，因為未使用的變數可能會是個錯誤。但有時候先建立個你還沒有使用的變數是很有用的，像是你還在寫原型或是才剛開個專案而已。在這種場合，你可以在尚未使用的變數名稱前加上底線，來告訴 Rust 不用提出警告。在範例 18-20 中，我們建立了兩個未使用的變數，但當我們編譯此程式碼時，我們應該會只收到其中一個的警告而已。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">範例 18-20：在變數名稱前加上底線來避免未使用變數的警告</span></p>
<p>我們在此收到沒有使用變數 <code>y</code> 的警告，但是我們沒有收到 <code>_x</code> 的警告。</p>
<p>注意到只使用 <code>_</code> 與在名稱前加上底線之間是有些差別的。<code>_x</code> 仍會綁定數值到變數中，但 <code>_</code> 不會做任何綁定。為了展示這樣的區別是有差的，我們用範例 18-21 來展示一個錯誤。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;哈囉！&quot;));

    if let Some(_s) = s {
        println!(&quot;發現字串&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-21：以底線開頭的未使用變數仍會綁定數值，因而造成數值所有權被移動</span></p>
<p>我們會收到錯誤，因為 <code>s</code> 的數值仍會被移至 <code>_s</code>，讓我們無法再使用 <code>s</code>。不過只使用底線的話就不會綁定數值。範例 18-22 就能夠編譯不會產生任何錯誤，因為 <code>s</code> 沒有移至 <code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;哈囉！&quot;));

    if let Some(_) = s {
        println!(&quot;發現字串&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-22：使用底線不會綁定數值</span></p>
<p>此程式碼就能執行，因為我們沒有將 <code>s</code> 綁定給誰，它沒被移動。</p>
<h4 id="透過--忽略剩餘部分數值"><a class="header" href="#透過--忽略剩餘部分數值">透過 <code>..</code> 忽略剩餘部分數值</a></h4>
<p>對於有許多部分的數值，我們可以用 <code>..</code> 語法來使用特定部分，然後忽略剩餘部分，來避免需要對每個要忽略的數值都得加上底線。<code>..</code> 模式會忽略模式中剩餘尚未配對的任何部分數值。在範例 18-23 中，我們有個 <code>Point</code> 結構體存有三維空間中的座標。而在 <code>match</code> 表達式中，我們想要只處理 <code>x</code> 座標並忽略 <code>y</code> 與 <code>z</code> 欄位的數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x 為 {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-23：透過使用 <code>..</code> 來忽略 <code>Point</code> 中除了 <code>x</code> 以外的所有數值</span></p>
<p>我們列出 <code>x</code> 數值接著只包含 <code>..</code> 模式。這比需要列出 <code>y: _</code> 和 <code>z: _</code> 還要快，尤其是當我們要處理有許多欄位的結構體，但只需要用到一或兩個欄位的狀況下。</p>
<p><code>..</code> 語法會擴展其所有所需得數值。範例 18-24 展示如何在元組使用 <code>..</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;一些數字：{first}、{last}&quot;);
        }
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-24：只配對元組中的第一個與最後一個數值，並忽略其他所有數值</span></p>
<p>在此程式碼中，第一個與最後一個數值會配對到 <code>first</code> 與 <code>last</code>。<code>..</code> 會配對並忽略中間所有數值。</p>
<p>然而，使用 <code>..</code> 必須是明確的。如果 Rust 無法確定是哪些數值要配對，而哪些是要忽略的話，它會回傳錯誤給我們。範例 18-25 含糊地使用了 <code>..</code>，所以它無法編譯。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;一些數字：{}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">範例 18-25：嘗試含糊地使用 <code>..</code></span></p>
<p>當我們編譯此範例時，我們會得到此錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: could not compile `patterns` due to previous error
</code></pre>
<p>Rust 不可能會知道在配對 <code>second</code> 之前要忽略多少元組中的數值，以及在之後得再忽略多少數值此程式碼可以代表我們想要忽略 <code>2</code>、綁定 <code>second</code> 到 <code>4</code> 然後忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或者我們想要忽略 <code>2</code> 和 <code>4</code>、綁定 <code>second</code> 到 <code>8</code> 然後忽略 <code>16</code> 和 <code>32</code>，以及更多可能。變數名稱 <code>second</code> 對 Rust 沒有任何特別意義，所以我們得到編譯錯誤，因為像這樣在兩個地方使用 <code>..</code> 是含糊不清的。</p>
<h3 id="提供額外條件的配對守護"><a class="header" href="#提供額外條件的配對守護">提供額外條件的配對守護</a></h3>
<p><strong>配對守護</strong>（match guard）是個在 <code>match</code> 分支之後額外指定的 <code>if</code> 條件，此條件也必須符合配對才能選擇該分支。配對守護適用於比單獨模式所能表達的還複雜的情況。</p>
<p>該條件能使用配對建立的變數。範例 18-26 展示 <code>match</code> 的第一個分支有個模式 <code>Some(x)</code> 並使用配對守護 <code>if x % 2 == 0</code>（如果數字為偶數就會成立）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;數字 {x} 是偶數&quot;),
        Some(x) =&gt; println!(&quot;數字 {x} 是基數&quot;),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-26：對模式加上配對守護</span></p>
<p>此範例會印出 <code>數字 4 是偶數</code>。當 <code>num</code> 與第一個分支做比較時，它會配對到，因為 <code>Some(4)</code> 能與 <code>Some(x)</code> 做配對。然後配對守護會檢查數值 <code>x</code> 除以 2 的餘數是否為 0，然後因為的確如此，所以就選擇了第一個分支。</p>
<p>如果 <code>num</code> 為 <code>Some(5)</code> 的話，第一個分支的配對守護則會是否，因為 5 除以 2 的餘數為 1，並不等於 0。Rust 就會接著檢查第二條分支，然後因為第二條分支沒有任何配對守護所以能配對到任何 <code>Some</code> 變體。</p>
<p>在模式中沒有任何方式能夠表達 <code>if x % 2 == 0</code>，所以配對守護讓我們能夠有能力表達此邏輯。這種額外的表達能力的缺點是，編譯器對有配對守護的分支就不會窮舉檢查。</p>
<p>在範例 18-11 中，我們提到我們可以使用模式配對來解決我們的模式遮蔽問題。回想一下 <code>match</code> 表達式中使用的是模式內建立的新變數，而不是使用 <code>match</code> 外部的變數。該新變數會讓我們無法測試外部變數的數值。範例 18-27 展示我們如何使用配對守護來修正此問題。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;取得 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;配對成功，n = {n}&quot;),
        _ =&gt; println!(&quot;預設情形，x = {:?}&quot;, x),
    }

    println!(&quot;最後結果：x = {:?}, y = {y}&quot;, x);
}
</code></pre></pre>
<p><span class="caption">範例 18-27：使用配對守護來測試與外部變數是否相等</span></p>
<p>此程式碼現在會印出 <code>預設情形，x = Some(5)</code>。第二個模式中沒有宣告新的變數 <code>y</code> 來遮蔽外部的 <code>y</code>，意味著我們可以在配對守護中使用外部的 <code>y</code>。我們不再指定模式為 <code>Some(y)</code>，因為這樣會遮蔽外部的 <code>y</code>，我們改指定成 <code>Some(n)</code>。這樣建立了一個新的變數 <code>n</code> 且不會遮蔽任何事物，因為 <code>match</code> 外部沒有任何變數 <code>n</code>。</p>
<p>配對守護 <code>if n == y</code> 不屬於模式，因此不會宣告任何新變數。此 <code>y</code> <strong>就是</strong>外部的 <code>y</code> 而非新遮蔽的 <code>y</code>，而且我們可以透過將 <code>n</code> 與 <code>y</code> 做比較來檢查數值是否與外部 <code>y</code> 的數值相等。</p>
<p>你也可以在配對守護中使用 <em>OR</em> 運算子 <code>|</code> 來指定多重模式，配對守護的條件會套用在所有的模式中。範例 18-28 顯示了結合配對守護與使用 <code>|</code> 模式之間的優先層級（precedence）。此例中的重點部分在於 <code>if y</code> 配對守護能套用在 <code>4</code>、<code>5</code> <strong>與</strong> <code>6</code>，而不是只有 <code>6</code> 會用到 <code>if y</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;是&quot;),
        _ =&gt; println!(&quot;否&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-28：結合數個模式與配對守護</span></p>
<p>此配對條件表示該分支只有在數值 <code>x</code> 等於 <code>4</code>、<code>5</code> 或 <code>6</code>，<strong>以及</strong>如果 <code>y</code> 為 <code>true</code> 時才算配對到。當此程式碼執行時，第一個分支的模式有配對到，因為 <code>x</code> 為 <code>4</code>，但是配對守護 <code>if y</code> 為否，所以不會選擇第一個分支。程式碼會移動到第二個分支，然後程式會配對到並印出 <code>no</code>。原因在於 <code>if</code> 條件會套用到整個模式 <code>4 | 5 | 6</code>，而不是只有最後一個數值 <code>6</code>。換句話說，配對守護與模式之間的優先層級會像是這樣：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是這樣：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>在執行此程式碼之後，優先層級的行為就很明顯了，如果配對守護只會用在由 <code>|</code> 運算子指定數值列表中最後一個數值的話，該分支應該要能配對到並讓程式印出 <code>是</code>。</p>
<h3 id="-綁定"><a class="header" href="#-綁定"><code>@</code> 綁定</a></h3>
<p><em>At</em> 運算子（<code>@</code>）能讓我們在測試某個數值是否配對的到一個模式的同時，建立出一個變數來持有該數值。在範例 18-29 我們想要測試 <code>Message::Hello</code> 的 <code>id</code> 欄位是否位於 <code>3..=7</code> 的範圍中。我們也想要將該數值綁定到變數 <code>id_variable</code> 之中，讓我們可以在該分支對應的程式碼中使用它。我們可以將此變數命名為與欄位同名的 <code>id</code>，但在此例中我們會使用不同名稱。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;id 在此範圍中：{}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;id 在其他範圍中&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;找到其他 id：{}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-29：使用 <code>@</code> 來在測試時綁定模式中的數值</span></p>
<p>此範例會印出 <code>id 在此範圍中：5</code>。透過在範圍 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我們能獲取要配對到範圍的數值，並同時測試該數值是否有配對到範圍模式。</p>
<p>在第二個分支中，我們只有在模式中指定範圍，該分支對應的程式碼就沒有變數能包含 <code>id</code> 欄位的實際數值。<code>id</code> 欄位數值可能是 10、11 或 12，但此模式的程式碼不會知道其值為何。該模式程式碼無法使用 <code>id</code> 欄位的數值，因為我們沒有將 <code>id</code> 數值存為變數。</p>
<p>在最後一個分支中，我們指定沒有限制範圍的變數，我們有能在分支程式碼中使用的有效變數 <code>id</code>。原因是因為我們使用了結構體欄位簡寫語法。不過我們在此分支沒有向前兩個條分支進行任何對 <code>id</code> 欄位的測試，任何數值都會配對到此模式。</p>
<p>使用 <code>@</code> 讓我們能在一個模式中測試數值並將其儲存至變數。</p>
<h2 id="總結-17"><a class="header" href="#總結-17">總結</a></h2>
<p>Rust 的模式對於分辨不同種資料來說非常實用。當在 <code>match</code> 表達式中使用時，Rust 確保你的模式有涵蓋所有可能數值，不然你的程式就不會編譯通過。在 <code>let</code> 陳述式與函式參數中的模式使它們的結構更實用，在能夠解構數值成更小部分的同時賦值給變數。我們能夠建立簡單或複雜的模式來滿足我們的需求。</p>
<p>接下來，在本書的倒數第二章中，我們要來看 Rust 眾多特色中的一些進階部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="進階特色"><a class="header" href="#進階特色">進階特色</a></h1>
<p>現在，你已經了解 Rust 程式語言最常用的部分。在開始做第二十章的另一個專案之前，先來了解你可能偶爾會遇到，但不一定天天用到的語言種種面向。當你碰到一些未知情況時，可以將本章作為技術文件查閱。本章涵蓋之特色僅在特定情況下有實用性。雖然可能不會經常碰到這些，但我們希望確保你能掌握 Rust 提供的所有特色。</p>
<p>本章涵蓋：</p>
<ul>
<li>不安全的 Rust：如何選擇捨棄部分 Rust 提供的保證，並自行負責遵守這些保證</li>
<li>進階特徵：關聯型別（associated type）、預設型別參數（default type parameter），完全限定語法（fully qualified syntax），超特徵（supertrait），以及跟特徵相關的新型別模式（newtype pattern）</li>
<li>進階型別：更多有關新型別模式、型別別名（type alias），永不型別（never type），以及動態大小型別（dynamically sized type）</li>
<li>進階函式與閉包：函式指標與回傳閉包</li>
<li>巨集（macro）：一種定義「在編譯期定義程式碼的程式碼」之方法</li>
</ul>
<p>這些 Rust 全功能特色適合所有人。一起來深究吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="不安全的-rust"><a class="header" href="#不安全的-rust">不安全的 Rust</a></h2>
<p>到目前為止，我們討論的所有程式碼都在編譯期強制加上 Rust 記憶體安全保證。然而，Rust 內部其實隱藏了第二種語言，並不強制加上這些記憶體安全保證：這語言叫做<strong>不安全（unsafe）的 Rust</strong>，可和常規 Rust 一樣正常執行，同時賦予我們極強的能力。</p>
<p>不安全的 Rust 之所以存在，是由於靜態分析本質上過於保守。當編譯器嘗試確認程式碼是否遵守這些安全保證時，比起接受一些非法的程式，更寧願拒絕部分合法程式。儘管有些程式碼<strong>看起來</strong>正確，但 Rust 無法獲取足夠資訊保證的話，它就是會擋下來。在這些案例中，你可以寫不安全程式碼並告訴編譯器：「相信我，我知道我在幹麻。」從反面來看這也有缺點，你必須自行承擔風險：若誤用不安全程式碼，可能會造成記憶體不安全，例如發生對空指標（null pointer）解參考。</p>
<p>Rust 擁有另一個不安全的自我的另一理由是電腦硬體本質上就不安全。如果 Rust 不允許這些不安全操作，就無法完成特定任務。Rust 必須允許你做這些底層系統程式設計，例如直接與作業系統互動，甚至撰寫自己的作業系統。系統程式設計是這個語言的目標之一，一起探索我們可以用不安全的 Rust 做什麼和如何使用吧。</p>
<h3 id="不安全的超能力"><a class="header" href="#不安全的超能力">不安全的超能力</a></h3>
<p>欲切換成不安全的 Rust，可使用 <code>unsafe</code> 關鍵字開啟一個新程式碼區塊，並封裝這些不安全程式碼。在不安全的 Rust，你可使用在安全的 Rust 之下無法使用的五種功能，我們稱之為<strong>不安全的超能力</strong>。這些超能力包含：</p>
<ul>
<li>對裸指標（raw pointer）解參考</li>
<li>呼叫不安全函式或方法</li>
<li>存取或修改可變的靜態變數（static variable）</li>
<li>實作不安全特徵（trait）</li>
<li>存取聯合體（union）的欄位</li>
</ul>
<p>需要謹記在心的是，<code>unsafe</code> 並不會關閉借用檢查器（borrow checker）或是停用其他 Rust 的安全檢查：在不安全程式碼中操作一個參考仍然會經過檢查。<code>unsafe</code> 關鍵字只提供上述不經由編譯器檢查記憶體安全的五項功能，在不安全區塊內你依然保有一定程度的安全性。</p>
<p>此外，<code>unsafe</code> 並不意味在此區塊內的程式碼一定有風險或有記憶體安全問題：其目的是作為一個程式設計師，你必須確保在 <code>unsafe</code> 區塊內的程式碼透過合法途徑存取記憶體。</p>
<p>錯誤因人類不可靠而發生。不過，將五種不安全操作標記在 <code>unsafe</code> 區塊內，讓你得知任何記憶體安全相關的錯誤一定在某個 <code>unsafe</code> 內。請將 <code>unsafe</code> 區塊保持夠小，當你在調查一個記憶體錯誤時，會慶幸當初有這麼做。</p>
<p>為了盡可能隔離不安全程式碼，最佳作法是將之封裝在安全的抽象並提供安全的 API，本章在後面的探討不安全函式和方法一併討論之。部分的標準函式庫同樣是在審核過的不安全程式碼上提供安全抽象。透過安全抽象封裝不安全程式碼，可防止你或你的使用者使用以 <code>unsafe</code> 實作的功能，不會將實際的 <code>unsafe</code> 使用洩漏到四散各地，因為安全抽象就是安全的 Rust。</p>
<p>接下來將依序探討這五個不安全的超能力。也會看看一些替不安全程式碼提供安全介面的抽象。</p>
<h3 id="對裸指標解參考"><a class="header" href="#對裸指標解參考">對裸指標解參考</a></h3>
<p>在第四章<a href="ch04-02-references-and-borrowing.html#%E8%BF%B7%E9%80%94%E5%8F%83%E8%80%83">「迷途參考」</a>一節，我們提及編譯器確保參考一定是合法的。不安全的 Rust 有兩種新型別叫<strong>裸指標</strong>，和參考非常相似。和參考一樣，裸指標能是不可變或可變，分別寫做 <code>*const T</code> 和 <code>*mut T</code>。星號不是參考運算子，它就是型別名稱的一部分。在裸指標的脈絡下，<strong>不可變</strong>代表指標不能在被解參考之後直接賦值。</p>
<p>和參考與智慧指標（smart pointer）不同，裸指標是：</p>
<ul>
<li>允許忽略借用規則，同時可存在指向相同位置的可變和不可變的指標，或是多個可變指標</li>
<li>不能保證一定指向合法記憶體</li>
<li>可以為空（null）</li>
<li>並無實作任何自動清理機制</li>
</ul>
<p>在停用 Rust 的保證之後，你能透過放棄這些安全性保證換得更高的效能，或是介接其他語言與硬體等無法套用 Rust 安全保證的場景。</p>
<p>範例 19-1 展示了如何從參考分別建立不可變和可變的裸指標。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-1：從參考建立裸指標</span></p>
<p>注意，這段程式碼並無使用 <code>unsafe</code> 關鍵字。我們可以在安全程式碼中建立裸指標，我們只是不能在不安全區塊外對其解參考，你很快就會看到。</p>
<p>我們透過 <code>as</code> 將不可變與可變參考轉型成個別對應的裸指標。由於這些裸指標是從保證合法的參考而來，就能得知這些裸指標同樣合法，但我們無法推導所有裸指標都合法。</p>
<p>為了展示上述情形，接下來，我們將建立無法確認合法性的裸指標，範例 19-2 展示了如何從任意記憶體的位置建立裸指標。嘗試使用任意的記憶體行為並未定義，該位址上可能有也可能沒資料，且編譯器可能會最佳化該程式，所以該處可能不會存取記憶體，或是程式因區段錯誤導致崩潰。一般情況下，雖然這種程式碼能寫得出來，但不會有任何好理由寫出它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-2：從任意記憶體位址建立裸指標</span></p>
<p>回想一下，我們可以在安全的程式碼下建立裸指標，但我們不能對裸指標<strong>解參考</strong>並讀取它指向的資料。範例 19-3 我們對裸指標使用參考運算子 <code>*</code> 需要封裝在 <code>unsafe</code> 區塊內。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 為：{}&quot;, *r1);
        println!(&quot;r2 為：{}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-3：在 <code>unsafe</code> 區塊對裸指標解參考</span></p>
<p>建立一個指標沒有危險性，只有當我們嘗試存取它指向的值時，才可能需要處理非法的值。</p>
<p>請注意，範例 19-1 與 19-3，我們建立了 <code>*const i32</code> 與 <code>*mut i32</code> 兩個裸指標，皆指向相同儲存 <code>num</code> 的記憶體位置。若我們走正常程序建立指向 <code>num</code>  的不可變與可變參考，程式碼將因為 Rust 所有權規則不允許同時存在一個可變參考與多個不可變參考，進而無法編譯。有了裸指標，即可建立指向同個位置的可變指標和不可變指標，並透過可變指標改變其資料，但可能帶來資料競爭（data races），請小心！</p>
<p>既然有這些危險，為什麼你還要用裸指標呢？一個主要用例是與 C 程式碼介接，你將會在下一節<a href="ch19-01-unsafe-rust.html#%E5%91%BC%E5%8F%AB%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E5%BC%8F%E6%88%96%E6%96%B9%E6%B3%95">「呼叫不安全函式或方法」</a>讀到。另一個用例是在借用檢查器不理解之處建立一層安全抽象。我們將會介紹不安全函式，再探討一個使用到不安全程式碼的安全抽象範例。</p>
<h3 id="呼叫不安全函式或方法"><a class="header" href="#呼叫不安全函式或方法">呼叫不安全函式或方法</a></h3>
<p>第二種需要不安全區塊的操作是呼叫不安全函式。不安全函式與方法外觀看起來與正常函式及方法並無二致，僅在整個函式定義前多了額外的 <code>unsafe</code> 。<code>unsafe</code> 關鍵字在此脈絡下是指此函式在呼叫時必須遵守某些要求，因為 Rust 無法保證我們能達成這項要求。當我們在一個 <code>unsafe</code> 區塊內呼叫一個 <code>unsafe</code> 函式，意味著我們已閱讀此函式的文件，而且有責任遵守此函式的使用條款。</p>
<p>這裡有個不安全函式叫做 <code>dangerous</code>，函式本體內無任何東西：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<p>我們必須在單獨的 <code>unsafe</code> 區塊中呼叫 <code>dangerous</code> 函式，若不在 <code>unsafe</code> 區塊中呼叫，會得到一個錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>藉由一個 <code>unsafe</code> 區塊，我們可以對 Rust 聲明我們閱讀過該函式的文件，理解如何合理使用它，並且驗證過我們已履行該函式的使用條款。</p>
<p>不安全函式本體與 <code>unsafe</code> 區塊等效，所以可以在該不安全函式執行其他不安全操作，不需再加 <code>unsafe</code> 區塊。</p>
<h4 id="在不安全程式碼上建立安全的抽象"><a class="header" href="#在不安全程式碼上建立安全的抽象">在不安全程式碼上建立安全的抽象</a></h4>
<p>一個函式有不安全程式碼並不代表我們必須將整個函式標註為不安全。事實上，將不安全程式碼封裝在安全函式中一直是常見的抽象。我們來研讀標準函式庫的 <code>split_at_mut</code> 函式作為範例，它需要一些不安全程式碼。我們將探索如何實作之。這個安全方法定義在可變的切片上：它將一個切片在給定的索引引數（argument）上一分為二。範例 19-4 展示了如何使用 <code>split_at_mut</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-4：使用一個安全的 <code>split_at_mut</code> 函式</span></p>
<p>我們不可能在 safe Rust 下實作這個函式。一個嘗試可能會像範例 19-5 無法編譯。為了簡化，我們將 <code>split_at_mut</code> 實作為一個函式而非方法，並且以 <code>i32</code> 取代泛型型別 <code>T</code>。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
</span><span class="boring">    let len = values.len();
</span><span class="boring">
</span><span class="boring">    assert!(mid &lt;= len);
</span><span class="boring">
</span><span class="boring">    (&amp;mut values[..mid], &amp;mut values[mid..])
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 19-5：嘗試僅用安全的 Rust 實作 <code>split_at_mut</code></span></p>
<p>這個函式先取得該切片的總長度，再來檢查從參數而來的索引小於等於該長度。這項檢查代表若我們傳入欲分割的索引位置大於該長度，這個函式會在嘗試使用該索引前就恐慌（panic）。</p>
<p>之後，我們回傳一個元組，其內包含兩個可變切片：一個從原始切片的起頭到 <code>mid</code> 索引位置，另一個則從 <code>mid</code> 到尾端。</p>
<p>當我們嘗試編譯範例 19-5 的程式碼，會得到一個錯誤。</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --&gt; src/main.rs:6:31
  |
1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                         - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut values[..mid], &amp;mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error 
</code></pre>
<p>Rust 的借用檢查器（borrow checker）不能理解我們同時借用一個切片的不同部分，它只認知到我們借用同一個切片兩次。借用同一個切片的不同部分基本上沒什麼問題，因為兩個切片不會重疊，但 Rust 不夠聰明以致無法理解這件事。當我們知道程式碼沒問題，但 Rust 並不知道，就是時候搞一點 不安全程式碼了。</p>
<p>範例 19-6 展示了如何使用一個 <code>unsafe</code> 區塊、一個裸指標，以及呼叫一些不安全函式來實作可成功執行的 <code>split_at_mut</code></p>
<pre><pre class="playground"><code class="language-rust">use std::slice;

fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-6：在 <code>split_at_mut</code> 函式實作中使用不安全程式碼</span></p>
<p>回憶一下第四章<a href="ch04-03-slices.html#%E5%88%87%E7%89%87%E5%9E%8B%E5%88%A5">「切片型別」</a> 一節中，提及切片會儲存指向某些資料的指標以及該切片長度。我們可使用 <code>len</code> 方法取得切片的長度，並用 <code>as_mut_ptr</code> 取得指向切片的裸指標。在此範例中，由於我們擁有指向某些 <code>i32</code> 值的可變切片，<code>as_mut_ptr</code> 會回傳一個型別為 <code>*mut i32</code> 的裸指標，即是儲存在 <code>ptr</code> 變數中的值。</p>
<p>我們判定 <code>mid</code> 索引在該切片內。此後我們進入不安全程式碼：<code>slice::from_raw_parts_mut</code> 函式需要一個裸指標與一個長度，並建立一個切片。我們使用這個函式來建立一個從 <code>ptr</code> 開始長度為 <code>mid</code> 的切片。而後，我們以 <code>mid</code> 作為引數，對 <code>ptr</code> 呼叫 <code>add</code> 方法，以取得從 <code>mid</code> 開始的裸指標，再來用此指標與從 <code>mid</code> 開始剩下的元素個數作為長度，建立另一個切片。</p>
<p><code>slice::from_raw_parts_mut</code> 之所以為不安全函式，是因為它需要裸指標，且必須相信這個指標合法。<code>add</code> 是不安全方法是由於它必須相信偏移後的位址是合法指標。因此，我們需要在呼叫 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 外包一層 <code>unsafe</code> 函式。透過閱讀程式碼與加上對 <code>mid</code> 一定等於或比 <code>len</code> 小的斷言，我們可以宣稱所有在 <code>unsafe</code> 區塊的裸指標都是指向原始切片內的合法指標。這是一個可接受且合理的 <code>unsafe</code> 使用情境。</p>
<p>注意，我們不需替 <code>split_at_mut</code> 函式輸出結果做上 <code>unsafe</code> 的記號，而且我們可以在安全的 Rust 呼叫它。我們藉由安全的方式使用 <code>unsafe</code> 函式，完成了對不安全程式碼建立一層安全抽象，這個抽象只會從該函式能夠存取的資料內建立合法指標。</p>
<p>對比之下，範例 19-7 中使用 <code>slice::from_raw_parts_mut</code> 則極有可能會在該切片被使用時崩潰。這段程式碼從任意的記憶體位置建立了一個 10,000 元素長的切片。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-7：從任意記憶體位址建立切片</span></p>
<p>我們不擁有此位址之下的記憶體，且並不保證這段程式碼建立的切片一定包含合法的 <code>i32</code> 值。嘗試將 <code>values</code> 當作合法的切片來使用，會導致為未定義行為（undefined behavior）。</p>
<h4 id="使用-extern-函式呼叫外部程式碼"><a class="header" href="#使用-extern-函式呼叫外部程式碼">使用 <code>extern</code> 函式呼叫外部程式碼</a></h4>
<p>有些時候，你的 Rust 程式碼可能需要與其他語言撰寫的程式碼互動。這種情況 Rust 提供 <code>extern</code> 關鍵字，予以協助建立與使用<strong>外部函式介面（Foreign Function Interface，FFI）</strong> 。FFI 的功能是給在一門程式語言定義函式，使得另一門（外部）程式語言可以呼叫這些函式。</p>
<p>範例 19-8 展示了如何建立整合一個 C 標準函式庫的 <code>abc</code> 函式。由於其他語言並無強制遵守 Rust 的規則和保證，而且 Rust 也無法檢查之，因此在 Rust 程式碼中呼叫在 <code>extern</code> 區塊內宣告的函式一定是不安全的操作，所以確保安全的重責大任就會落在程式設計師身上。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;依據 C 所判斷 -3 的絕對值為：{}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-8：宣告並呼叫一個用其他語言定義的 <code>extern</code> 函式</span></p>
<p>在 <code>extern &quot;C&quot;</code> 區塊內，我們列出我們想要呼叫的，從其他語言而來的外部函式名稱與簽名。<code>&quot;C&quot;</code> 的部分定義了外部函式使用了哪個應用程式二進位制介面（ABI）：ABI 定義了在組合語言層級該如何呼叫此函式。<code>&quot;C&quot;</code> ABI 最為通用且遵循 C 程式語言的 ABI 規範。</p>
<blockquote>
<h4 id="從其他語言呼叫-rust-函式"><a class="header" href="#從其他語言呼叫-rust-函式">從其他語言呼叫 Rust 函式</a></h4>
<p>我們也可透過 <code>extern</code> 定義一個介面，允許其他語言呼叫 Rust 的函式。有別於建立整個 <code>extern</code> 區塊，我們會在 <code>fn</code> 關鍵字前加上 <code>extern</code> 關鍵字並指明應用程式二進位制介面（ABI）。我們甚至可加上 <code>#[no_mangle]</code> 註記來告訴編譯器不要重整（mangle）該函式名稱。<strong>重整</strong>是一個編譯器透過改變我們賦予函式的名稱，成為帶有更多資訊的名稱進而提供給編譯過程使用，但人類就相對難以閱讀。每個程式語言編譯器重整名稱的作法有些許不同，因此必須關閉 Rust 編譯器的名稱重整功能。</p>
<p>接下來的範例，我們寫了 <code>call_from_c</code> 函式，可以在編譯成共享函式庫（shared library）且連結至 C 後，由 C 程式碼存取：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;從 C 呼叫了一個 Rust 函式！&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>這類的 <code>extern</code> 用途不需要 <code>unsafe</code>。</p>
</blockquote>
<h3 id="存取或修改可變的靜態變數"><a class="header" href="#存取或修改可變的靜態變數">存取或修改可變的靜態變數</a></h3>
<p>在本書中，我們還沒聊到<strong>全域變數</strong>（global variable），這個 Rust 支援但會被 Rust 的所有權規則搞得七葷八素的功能。試想有兩個執行緒同時存取同一個可變全域變數，豈不導致資料競爭。</p>
<p>Rust 的全域變數稱做<strong>靜態</strong>變數。範例 19-9 展示了宣告並使用一個儲存字串切片的靜態變數。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name 為：{}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">範例 19-9：定義並使用一個不可變的靜態變數</span></p>
<p>靜態變數（static variable）與我們在第三章「<a href="ch03-01-variables-and-mutability.html#%E5%B8%B8%E6%95%B8">變數與常數的差異</a><!-- ignore -->」一節討論的常數相似。慣例上靜態變數會用尖叫蛇式命名（<code>SCREAMING_SNAKE_CASE</code>）。由於靜態變數只能儲存 <code>static</code> 生命週期的參考，代表 Rust 編譯器可推導出它的生命週期，不需要我們顯式標註。存取一個不可變的靜態變數是安全的。</p>
<p>常數和不可變靜態變數看似相同，實則有些許隱晦差異：靜態變數之值有固定的記憶體位址，使用該值永遠會存取相同的資料。反之，常數在使用上則可複製它們儲存的資料。</p>
<p>另一個常數與靜態變數的差異是，靜態變數可能是可變的。存取並修改可變的靜態變數並「<strong>不安全</strong>」。範例 19-10 展示了如何宣告、存取、修改一個可變的靜態變數 <code>COUNTER</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-10：讀取與寫入可變的靜態變數為不安全的操作</span></p>
<p>與普通變數一樣，我們透過 <code>mut</code> 關鍵字指明可變性。任何讀寫 <code>COURTER</code> 的程式碼皆必須在 <code>unsafe</code> 區塊中。這個程式碼會編譯並打印出我們預期中的 <code>COUNTER: 3</code> 是因為他在單執行緒執行，若在多執行緒存取 <code>COUTER</code> 則可能導致資料競爭。</p>
<p>當能從全域存取可變資料時，確保沒有資料競爭就不容易了，這就是為什麼 Rust 將可變的靜態變數視為不安全。若是可能的話，我們推薦使用第十六章討論的並行技術與執行緒安全（thread-safe）的智慧指標（smart pointer），如此一來編譯器就能檢查從不同執行緒存取資料是安全的。</p>
<h3 id="實作不安全特徵"><a class="header" href="#實作不安全特徵">實作不安全特徵</a></h3>
<p>我們可以用 <code>unsafe</code> 實作不安全特徵。當一個特徵是有至少一個方法包含編譯器無法驗證的不變條件（invariant），就稱該特徵不安全。我們透過在 <code>trait</code> 前加上 <code>unsafe</code> 關鍵字來宣告一個特徵為 <code>unsafe</code>，這也讓實作該特徵會變成 <code>unsafe</code>，如 19-11 所示。</p>
<pre><pre class="playground"><code class="language-rust">unsafe trait Foo {
    // 內部的方法
}

unsafe impl Foo for i32 {
    // 內部實作的方法
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 19-11：定義並實作一個不安全特徵</span></p>
<p>透過 <code>unsafe impl</code>，我們承諾我們將會遵守這些編譯器無法驗證的不變條件（invariant）。</p>
<p>回想第十六章<a href="ch16-04-extensible-concurrency-sync-and-send.html#%E5%8F%AF%E5%BB%B6%E5%B1%95%E7%9A%84%E4%B8%A6%E8%A1%8C%E8%88%87-sync-%E5%8F%8A-send-%E7%89%B9%E5%BE%B5">「可延展的並行與 <code>Sync</code> 及 <code>Send</code> 特徵」</a>一節的兩個記號特徵（marker trait）<code>Sync</code> 與 <code>Send</code>：若我們的型別是由 <code>Send</code> 與 <code>Sync</code> 組合而成，編譯器會自動實作這些特徵。若我們的型別包含一些非 <code>Send</code> 或 <code>Sync</code> 的型別，例如裸指標，但我們希望替型別做上 <code>Send</code> 或 <code>Sync</code> 的記號，就必須使用 <code>unsafe</code>。Rust 無法驗證我們的型別有遵守可以在多執行緒中傳遞或存取的保證。因而，我們需要自己手動檢查，並指明這是 <code>unsafe</code>。</p>
<h3 id="存取聯合體的欄位"><a class="header" href="#存取聯合體的欄位">存取聯合體的欄位</a></h3>
<p>最後一個可以使用 <code>unsafe</code> 的地方是存取 <code>union</code> 的欄位。<code>union</code> 與 <code>struct</code> 十分相似，差異是在一個聯合體實例中僅儲存其中一個宣告的欄位。聯合體主要用在與 C 程式碼的聯合體介接。存取聯合體的欄位並不安全，由於 Rust 無法保證當前儲存在聯合體實例中的資料是什麼型別，因此存取聯合體的欄位並不安全。你可以從 <a href="https://doc.rust-lang.org/reference/items/unions.html">Rust 參考手冊</a>了解更多關於聯合體的資訊。</p>
<h3 id="何時該用不安全程式碼"><a class="header" href="#何時該用不安全程式碼">何時該用不安全程式碼</a></h3>
<p>透過 <code>unsafe</code> 使用上述五種功能（超能力）並沒有錯，更並非不能接受，但由於編譯期無法協助遵守記憶體安全，這讓 <code>unsafe</code> 程式碼要正確無誤略顯棘手。當你因故需要使用 <code>unsafe</code> 程式碼，就去用吧，並且記得替 <code>unsafe</code> 撰寫明確的註釋，讓有問題發生時更容易追蹤查找源頭。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="進階特徵"><a class="header" href="#進階特徵">進階特徵</a></h2>
<p>我們在第十章<a href="ch10-02-traits.html#%E7%89%B9%E5%BE%B5-%E5%AE%9A%E7%BE%A9%E5%85%B1%E4%BA%AB%E8%A1%8C%E7%82%BA">「特徵：定義共享行為」</a><!-- ignore -->一節首次提及特徵（trait），但對其進階細節並無著墨。現在你已熟稔 Rust ，了解箇中真諦的時機已至。</p>
<h3 id="利用關聯型別在特徵定義中指定佔位符型別"><a class="header" href="#利用關聯型別在特徵定義中指定佔位符型別">利用關聯型別在特徵定義中指定佔位符型別</a></h3>
<p><strong>關聯型別</strong>（associated types）連結了一個型別佔位符（placeholder）與一個特徵，可以將這些佔位符型別使用在這些特徵所定義的方法簽名上。對特定實作來說，特徵的實作者將指明一個具體型別來代替型別佔位符。如此一來，我們可以定義一個使用了某個型別的特徵，但直到特徵被實作之前，都不需知道實際上的型別。</p>
<p>多數在本章提及的進階特色都較少使用，而關聯型別則是介於其中：他們比書中其他內容來得少用，但比本章介紹的其他特色來得更常見。</p>
<p>一個具有關聯型別的特徵之範例是標準函式庫提供的 <code>Iterator</code> 特徵。這例子中的關聯型別叫做 <code>Item</code>，表示一型別實作 <code>Iterator</code> 特徵時，會被疊代的那些值的型別。範例 19-12 展示了 <code>Iterator</code> 特徵的定義：</p>
<pre><code class="language-rust noplayground">pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p><span class="caption">範例 19-12：<code>Iterator</code> 特徵自帶一個關聯型別</span></p>
<p><code>Item</code> 型別是個佔位符，<code>next</code> 方法的定義顯示它會回傳型別為 <code>Option&lt;Self::Item&gt;</code> 之值。<code>Iterator</code> 特徵的實作者會指定 <code>Item</code> 的具體型別，而 <code>next</code> 方法則會回傳一個包含該具體型別的值的一個 <code>Option</code>。</p>
<p>關聯型別可能看起來和泛型的概念非常相似，而後者允許定義函式而不需指定該函式可以處理何種型別。為了檢視以下兩者概念上的差異，我們來看這個替型別 <code>Counter</code> 上實作 <code>Iterator</code> 特徵，且 <code>Counter</code> 指定的 <code>Item</code> 的型別為 <code>u32</code>：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>語法似乎和泛型很像，所以為什麼我們不使用泛型定義 <code>Iterator</code> 特徵，如範例 19-13 所示？</p>
<pre><code class="language-rust noplayground">pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
</code></pre>
<p><span class="caption">範例 19-13: 假設使用泛型來定義 <code>Iterator</code> 特徵</span></p>
<p>差別在於使用泛型時，如範例 19-13 所示，由於我們可以實作出 <code>Iterator&lt;String&gt; for Counter</code> 或以任意多個其他泛型型別來替 <code>Counter</code> 實作 <code>Iterator</code>，因此，必須在每個實作都標註該型別。換言之，當一特徵擁有泛型參數，一型別即可透過改變泛型型別參數（generic type parameter）的具體型別，進而實作該特徵多次。於是，當我們使用 <code>next</code> 方法時，必須提供型別標註，指名要用哪個 <code>Iterator</code> 的實作。</p>
<p>有了關聯型別，同個型別就不能實作同個特徵多次，所以我們不需要標註型別。範例 19-12 中的定義用上了關聯型別，因為只能擁有一個 <code>impl Iterator for Counter</code>，於是只能替 <code>Item</code> 選擇唯一一個型別。在任何地方呼叫 <code>Counter</code> 的 <code>next</code> 方法就不必再明確指定我們想要 <code>u32</code> 疊代器了。</p>
<p>關聯型別也會成為該特徵的條款：該特徵的實作者必須替關聯型別佔位符提供一個型別。關聯型別通常該有個能解釋自己如何被用的名字，而且替關聯型別加上 API 技術文件會是個不錯的實踐。</p>
<h3 id="預設泛型型別參數與運算子重載"><a class="header" href="#預設泛型型別參數與運算子重載">預設泛型型別參數與運算子重載</a></h3>
<p>我們可以透過泛型型別參數（generic type parameter）指定該泛型型別預設的具體型別。在預設型別可運作的情形下，這可省去實作者需要指定具體型別的勞動。替泛型型別指定預設型別的語法是在宣告泛型型別時寫成 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p>
<p><strong>運算子重載</strong>（operator overloading）就是一個使用這個技術的好例子。你可以在特定情況下自訂運算子（如 <code>+</code>）的行為。</p>
<p>Rust 不允許建立你自己的運算子或重載任意的運算子，但你可以透過實作 <code>std::ops</code> 表列出的特徵與相關的運算子，來重載特定運算與相應特徵。在範例 19-14 我們重載了 <code>+</code> 運算子，讓兩個 <code>Point</code> 實例可相加。這個功能是透過對 <code>Point</code> 結構體實作 <code>Add</code> 特徵來達成：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<p><span class="caption">範例 19-14：藉由實作 <code>Add</code> 特徵，重載 <code>Point</code> 實例的 <code>+</code> 運算子</span></p>
<p><code>add</code> 方法將兩個 <code>Point</code> 實例的 <code>x</code> 值相加，兩個 <code>y</code> 值相加，並建立新的 <code>Point</code> 實例。<code>Add</code> 特徵有個關聯型別 <code>Outpout</code> 可以決定 <code>add</code> 方法回傳的型別。</p>
<p>這段程式碼的預設泛型型別寫在 <code>Add</code> 特徵中，定義如下：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>這段程式碼大體上看起來很眼熟：具有一個方法與一個關聯型別的特徵。新朋友是 <code>Rhs=Self</code>，這部分叫做<strong>預設型別參數（default type parameter）</strong>。<code>Rhs</code> 泛型參數（「右運算元 right hand side」的縮寫）定義了 <code>add</code> 方法中 <code>rhs</code> 參數的型別。若我們未在實作 <code>Add</code> 特徵時指定 <code>Rhs</code> 的具體型別，這個 <code>Rhs</code> 的型別預設會是 <code>Self</code>，也就是我們正在實作 <code>Add</code> 的型別。</p>
<p>當我們對 <code>Point</code> 實作 <code>Add</code>，因為我們想要將兩個 <code>Point</code> 實例相加，所以用到預設的 <code>Rhs</code>。讓我們看一個實作 <code>Add</code> 的範例，如何不用預設值，轉而自訂 <code>Rhs</code>。</p>
<p>我們有兩個結構體，<code>Millimeters</code> 與 <code>Meters</code>，分別儲存不同單位的值。這樣在現有的型別簡單地封裝進另一個結構體的模式叫做<strong>新型別模式（newtype pattern）</strong>，我們會在<a href="ch19-02-advanced-traits.html#%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9E%8B%E5%88%A5%E6%A8%A1%E5%BC%8F%E6%9B%BF%E5%A4%96%E9%83%A8%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%B5">「使用新型別模式替外部型別實作外部特徵」</a><!-- ignore -->段落做詳細介紹。我們想將公釐透過 <code>Add</code> 做好正確單位轉換來加至公尺，這可透過對 <code>Millimeters</code> 實作 <code>Add</code> 並將 <code>Rhs</code> 設為 <code>Meters</code> 達成，如範例 19-15。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
</code></pre>
<p><span class="caption">範例 19-15：藉由替 <code>Millimeters</code> 實作 <code>Add</code> 特徵，使 <code>Millimeters</code> 可與 <code>Meters</code> 相加 Point</span></p>
<p>欲相加 <code>Millimeters</code> 與 <code>Meters</code>，先將 <code>Rhs</code> 型別參數指定為 <code>impl Add&lt;Meters&gt;</code>，替代預設的 <code>Self</code>。</p>
<p>你會在下列兩種情況下使用預設型別參數：</p>
<ul>
<li>擴充一個型別但不破壞既有程式碼</li>
<li>提供大多數使用者不會需要的特殊狀況之自訂空間</li>
</ul>
<p>標準函式庫是第二種情況的範例：通常你會將兩個相同的型別相加，但 <code>Add</code> 特徵提供超乎預設的自訂能力。<code>Add</code> 特徵定義中的預設型別參數讓我們大多數時候不需要指定額外的參數。換句話說，不用再寫部分重複的樣板，讓該特徵更易用。</p>
<p>第一種情況和第二種類似，但概念相反：若你想替既有特徵加上新的型別參數，可以給它一個預設值，允許擴充該特徵的功能，而不破壞既有的程式實作。</p>
<h3 id="消除歧義的完全限定語法呼叫同名的方法"><a class="header" href="#消除歧義的完全限定語法呼叫同名的方法">消除歧義的完全限定語法：呼叫同名的方法</a></h3>
<p>Rust 並沒有限制不同特徵之間不能有同名的方法，也沒有阻止你對同一個型別實作這兩個特徵。有可能實作一個型別，其擁有多個從多個特徵而來的同名方法的型別。</p>
<p>當呼叫這些同名方法，你必須告訴 Rust 你想呼叫誰。試想範例 19-16 的程式碼，我們定義了兩個特徵 <code>Pilot</code> 與 <code>Wizard</code>，兩者都有 <code>fly</code> 方法。當我們對一個已經擁有 <code>fly</code> 方法的 <code>Human</code> 型別分別實作這兩個特徵時，每個 <code>fly</code> 方法的行為皆不同。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;這裡是艦長發言。&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;起！&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*狂揮雙臂*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 19-16：Human 分別實作了兩個特徵的 <code>fly</code> 方法，且 <code>Human</code> 自己實作了一個 <code>fly</code> 方法</span></p>
<p>當我們對一個 <code>Human</code> 實例呼叫 <code>fly</code>，編譯器預設會呼叫直接在該型別上實作的方法，如範例 19-17 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;這裡是艦長發言。&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;起！&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*狂揮雙臂*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">範例 19-17：對 <code>Human</code> 實例呼叫 <code>fly</code></span></p>
<p>執行這段程式碼會印出 <code>*狂揮雙臂*</code>，表示 Rust 呼叫直接在 <code>Human</code> 上實作的 <code>fly</code> 方法。</p>
<p>欲呼叫在 <code>Pilot</code> 或 <code>Wizard</code> 特徵上的 <code>fly</code> 方法，我們要用更明確的語法指定我們想要的 <code>fly</code> 方法。範例 19-18 展示了這個語法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">範例 19-18：指定想要呼叫哪個特徵的 <code>fly</code> 方法</span></p>
<p>在你要呼叫的方法名前指定特徵名稱，可以讓 Rust 清楚得知我們要呼叫哪個實作 <code>fly</code>。我們也可以寫成 <code>Human::fly(&amp;person)</code>，同義於在範例 19-18 的 <code>person.fly()</code>，只是為了消歧義而寫得長一點罷了。</p>
<p>執行這段程式碼會印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
這裡是艦長發言。
起！
*狂揮雙臂*
</code></pre>
<p>因為 <code>fly</code> 方法有個 <code>self</code> 參數，所以我們若有兩個<strong>型別</strong>都實作了同個特徵，Rust 可以透過 <code>self</code> 的型別理出該用哪個特徵的實作。</p>
<p>然而不屬於方法的關聯函式（associated function）則沒有 <code>self</code> 參數。當同個作用域下的多個型別或特徵皆定義了非方法且同名的函式時，除非使用<strong>完全限定語法</strong>（fully qualified syntax），否則 Rust 無法推斷你指涉哪個型別。舉例來說，範例 19-19 中，我們替動物庇護所建立了一個特徵，會將所有小狗狗命名為<strong>小不點</strong>。我們建立 <code>Animal</code> 特徵並帶有一個關聯非方法的函式 <code>baby_name</code>。<code>Animal</code> 特徵有個在 <code>Dog</code> 上的實作，也提供了關聯非方法的函式 <code>baby_name</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;小不點&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;小狗狗&quot;)
    }
}

fn main() {
    println!(&quot;幼犬被稱作{}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">範例 19-19: 一個特徵和一個型別分別擁有同名關聯函式，並且該型別實作了該特徵</span></p>
<p>我們在 <code>Dog</code> 中的 <code>baby_name</code> 關聯函式實作了一段程式碼，將所有小狗狗命名為小不點。這個 <code>Dog</code> 型別同時實作了 <code>Animal</code> 特徵，<code>Animal</code> 特徵則描述了所有動物都有的習性。。在實作了 <code>Animal</code> 特徵的 <code>Dog</code> 上，透過與 <code>Animal</code> 特徵關聯的 <code>baby_name</code> 函式中，表達了幼犬被稱作小狗狗這一概念。</p>
<p>在 <code>main</code> 中我們呼叫 <code>Dog::baby_name</code> 函式，最終會直接呼叫 <code>Dog</code> 上的關聯函式。這段程式碼會印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
幼犬被稱作小不點
</code></pre>
<p>這個輸出結果不符合我們預期。我們想呼叫的 <code>baby_name</code> 函式應該是我們在 <code>Dog</code> 上實作的 <code>Animal</code> 特徵，所以程式碼應該印出 <code>幼犬被稱作小狗狗</code>。我們在範例 19-18 所使用的指明特徵的技巧不適用於此，如果我們更改 <code>main</code> 成範例 19-20，會得到一個編譯錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小不點&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小狗崽&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;幼犬被稱為{}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">範例 19-20：嘗試呼叫 <code>Animal</code> 特徵上的 <code>baby_name</code> 函式，但 Rust 不知道該用哪個實作</span></p>
<p>因為 <code>Animal::baby_name</code> 沒有 <code>self</code> 參數，且其他型別也可能有 <code>Animal</code> 的實作，所以 Rust 無法推斷出我們想要哪個 <code>Animal::baby_name</code> 實作。我們會得到這個編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- `Animal::baby_name` defined here
...
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot call associated function of trait
   |
help: use the fully-qualified path to the only available implementation
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, &lt;::Dog as Animal&gt;::baby_name());
   |                                           +++++++++       +

For more information about this error, try `rustc --explain E0790`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>欲消除歧義，告訴 Rust 我們想用 <code>Dog</code> 上的 <code>Animal</code> 實作，而不是其他型別的 <code>Animal</code> 實作，我們必須使用完全限定語法。範例 19-21 展示了如何使用完全限定語法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小不點&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小狗崽&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;幼犬被稱作{}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">範例 19-21：使用完全限定語法指定呼叫實作了 <code>Animal</code> 的 <code>Dog</code> 上的 <code>baby_name</code> 函式</span></p>
<p>我們提供一個用角括號包住的型別詮釋（type annotation），這個詮釋透過將此函式呼叫的 <code>Dog</code> 型別視為 <code>Animal</code>，來指明我們想要呼叫有實作 <code>Animal</code> 特徵的 <code>Dog</code> 上的 <code>baby_name</code> 方法。這段程式碼現在會印出我們所要的：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
幼犬被稱作小狗崽
</code></pre>
<p>普遍來說，完全限定語法定義如下：</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>對於不是方法的關聯函式來說，不會有 <code>receiver</code>，只會有其他引數的列表。你可以在任何呼叫函式或方法之處使用完全限定語法。然而，你亦可在 Rust 能透過程式其他資訊推斷出的地方省略這個語法。只需要在有多個同名實作且需要協助 Rust 指定呼叫哪個實作時，才需要使用這囉嗦冗長的語法。</p>
<h3 id="使用超特徵要求在一個特徵內有另一特徵的功能"><a class="header" href="#使用超特徵要求在一個特徵內有另一特徵的功能">使用超特徵要求在一個特徵內有另一特徵的功能</a></h3>
<p>有些時候，你會定義一個依賴到其他特徵的特徵：對於已實作第一個特徵的型別，你想要求它同時實作第二個特徵。當你做了這件事，你的特徵定義就可以利用第二個特徵的關聯項目。你定義的特徵依賴的特徵就稱為<strong>超特徵</strong>（supertrait）。</p>
<p>假設我們想要建立一個 <code>OutlinePrint</code> 特徵，它有一個 <code>outline_print</code> 方法會印出一個被星號包圍的值。換句話說，給定一個實作 <code>Display</code> 而會產生 <code>(x, y)</code> 的 <code>Point</code> 結構體，當我們對 <code>x</code> 為 <code>1</code>，<code>y</code> 為 <code>3</code> 的 <code>Point</code> 實例呼叫 <code>outline_print</code>，它印出如下：</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>在這個 <code>outline_print</code> 實作中，我們想要使用到 <code>Display</code> 特徵的功能。因此，我們需要指明 <code>OutlinePrint</code> 特徵只會在型別同時實作 <code>Display</code> 且提供 <code>OutlinePrint</code> 所需功能時才會成功。這件事可以在特徵定義中做到，透過指明 <code>OutlinePrint: Display</code>。這項技巧很類似特徵上的特徵約束（trait bound）。範例 19-22 展示了 <code>OutlinePrint</code> 特徵的實作。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 19-22: 實作要求 <code>Display</code> 功能的 <code>OutlinePrint</code> 特徵</span></p>
<p>因為我們已指明 <code>OutlinePrint</code> 需要 <code>Display</code> 特徵，且只要有實作 <code>Display</code> 的型別都會自動實作 <code>to_string</code> 這個函式，所以我們可以使用 <code>to_string</code>。若我們嘗試使用 <code>to_string</code> 但並沒有在該特徵後加上冒號並指明 <code>Display</code>，會得到一個錯誤，告訴我們在當前作用域下的 <code>&amp;Self</code> 型別找不到名為 <code>to_string</code> 函數。</p>
<p>我們嘗試看看在一個沒有實作 <code>Display</code> 的型別上實作 <code>OutlinePrint</code>（如 <code>Point</code> 結構體）會發生什麼事：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<p>於是得到 <code>Display</code> 為必須但沒實作的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `OutlinePrint`
  --&gt; src/main.rs:3:21
   |
3  | trait OutlinePrint: fmt::Display {
   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example` due to previous error
</code></pre>
<p>我們可以透過對 <code>Point</code> 實作 <code>Display</code> 並滿足 <code>OutlinePrint</code> 要求的約束（constraint），如下：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>於是對 <code>Point</code> 實作 <code>OutlinePrint</code> 特徵就成功編譯，我們即可以對 <code>Point</code> 實例呼叫 <code>outline_print</code> 來顯示一個星號外框框住它。</p>
<h3 id="使用新型別模式替外部型別實作外部特徵"><a class="header" href="#使用新型別模式替外部型別實作外部特徵">使用新型別模式替外部型別實作外部特徵</a></h3>
<p>在第十章<a href="ch10-02-traits.html#%E7%82%BA%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E7%89%B9%E5%BE%B5">「為型別實作特徵」</a>一節中，我們提及孤兒規則（orphah rule），這個規則指出只要型別或特徵其一是在本地的 crate 中定義，就允許我們對該型別實作該特徵。使用<strong>新型別模式（newtype pattern）</strong>，即可繞過這項規則，此模式涉及建立一個元組結構體（tuple struct）型別（我們在<a href="ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%84%A1%E5%90%8D%E7%A8%B1%E6%AC%84%E4%BD%8D%E7%9A%84%E5%85%83%E7%B5%84%E7%B5%90%E6%A7%8B%E9%AB%94%E4%BE%86%E5%BB%BA%E7%AB%8B%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5">「使用無名稱欄位的元組結構體來建立不同型別」</a>說明了元組結構體）。元組結構體包含一個欄位，在我們想要實作該特徵的型別外作一層薄薄的封裝。這封裝型別對 crate 來說算作在本地定義，因此可以對該封裝實作該特徵。<strong>新型別</strong>是一個源自 Haskell 程式語言的術語。使用此模式不會有任何執行時效能的耗損，這個封裝型別會在編譯期刪略。</p>
<p>舉個例子，我們想要對 <code>Vec&lt;T&gt;</code> 實作 <code>Display</code>，但孤兒規則限制我們不能這樣做，因為 <code>Display</code> 特徵與 <code>Vec&lt;T&gt;</code> 都是在我們的 crate 之外定義。我們可以建立一個 <code>Wrapper</code> 結構體，帶有一個 <code>Vec&lt;T&gt;</code> 實例，接下來再對 <code>Wrapper</code> 實作 <code>Display</code> 並使用 <code>Vec&lt;T&gt;</code> 之值，如範例 19-23 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">範例 19-23：建立一個 <code>Wrapper</code> 型別封裝 <code>Vec&lt;STring&gt;</code> 以實作 <code>Display</code></span></p>
<p>因為 <code>Wrapper</code> 是一個元組結構體而 <code>Vec&lt;T&gt;</code> 是該元組在索引 0 上的項目，所以該 <code>Display</code> 的實作使用 <code>self.0</code> 存取內部的 <code>Vec&lt;T&gt;</code>。我們就可以在 <code>Wrapper</code> 上使用 <code>Display</code> 的功能了。</p>
<p>使用這個技術的缺點是 <code>Wrapper</code> 是個新型別，並無它封裝的值所擁有的方法。我們不得不在 <code>Wapper</code> 上實作所有 <code>Vec&lt;T&gt;</code> 的方法，委派這些方法給 <code>self.0</code>，讓我們可以將 <code>Wrapper</code> 作為 <code>Vec&lt;T&gt;</code> 一樣對待。如果我們想要新型別得到所有內部型別擁有的所有方法，一個解法是透過對 <code>Wrapper</code> 實作 <code>Deref</code> 特徵（在第十五章<a href="ch15-02-deref.html#%E9%80%8F%E9%81%8E-deref-%E7%89%B9%E5%BE%B5%E5%B0%87%E6%99%BA%E6%85%A7%E6%8C%87%E6%A8%99%E8%A6%96%E7%82%BA%E4%B8%80%E8%88%AC%E5%8F%83%E8%80%83">「透過 <code>Deref</code> 特徵將智慧指標視為一般參考」</a>一節有相應討論）並回傳內部型別。如果我們不想要 <code>Wrapper</code> 擁有所有內部型別的方法，例如限制 <code>Wrapper</code> 型別之行為，就僅須實作那些我們想要的方法。</p>
<p>現在，你知道如何將新型別模式與特徵相關聯，縱使不涉及特徵，新型別模式仍非常實用。接下來我們將目光轉移到其他與 Rust 型別系統互動的方法吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="進階型別"><a class="header" href="#進階型別">進階型別</a></h2>
<p>至此，我們提及 Rust 型別系統的諸多特色，不過尚未深入討論。本章將從一般角度切入討論新型別（newtype）並檢驗為何作為型別來說，新型別非常好用。再來，接續看看型別別名（type alias）這個類似新型別但語意上不盡相同的特色。我們也會探討 <code>!</code> 型別與動態大小型別（dynamically sized type）。</p>
<h3 id="透過新型別模式達成型別安全與抽象"><a class="header" href="#透過新型別模式達成型別安全與抽象">透過新型別模式達成型別安全與抽象</a></h3>
<blockquote>
<p>注意：接下來一節假定你已閱讀前面的章節 <a href="ch19-02-advanced-traits.html#%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9E%8B%E5%88%A5%E6%A8%A1%E5%BC%8F%E6%9B%BF%E5%A4%96%E9%83%A8%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%B5">「使用新型別模式替外部型別實作外部特徵」</a>。</p>
</blockquote>
<p>目前為止，我們討論過的任務中，新型別模式皆游刃有餘，包括靜態強制不讓值被混淆，同時能表示該值的單位。在範例 19-15 可以見到如何善用新型別表示該值的單位：回憶一下，<code>Millimeters</code> 與 <code>Meters</code> 將 <code>u32</code> 的值封裝在新型別內，若我們寫了一個函式需要型別為 <code>Millimeters</code> 的參數，我們不可能編譯出一支可以誤傳 <code>Meters</code> 型別或 <code>u32</code> 來呼叫這個函式的程式。</p>
<p>我們也可以善用新型別是替一個型別的實作細節建立抽象層：如果我們直接將新型別作為限制可用功能的手段，新型別就可以公開有別於私有內部型別的 API。</p>
<p>新型別也可以隱藏內部實作。例如，我們可以提供 <code>People</code> 型別，封裝用來儲存人們的 ID 與姓名之間的關聯的 <code>HashMap&lt;i32, String&gt;</code>。使用 <code>People</code> 的程式碼僅能與我們提供的公開 API 互動，例如透過一個方法替 <code>People</code> 集合添加名字字串，這段程式碼就不需知道內部會將 <code>i32</code> 作為 ID 並映射到姓名上。我們在第十七章的<a href="ch17-01-what-is-oo.html#%E9%9A%B1%E8%97%8F%E5%AF%A6%E4%BD%9C%E7%B4%B0%E7%AF%80%E7%9A%84%E5%B0%81%E8%A3%9D">「隱藏實作細節的封裝」</a>一節也曾提及，利用新型別模式來達到封裝與隱藏實作細節，不失為一種輕量的方法。</p>
<h3 id="透過型別別名建立型別同義詞"><a class="header" href="#透過型別別名建立型別同義詞">透過型別別名建立型別同義詞</a></h3>
<p>Rust 提供了替一個既有型別宣告型別別名的方式。對此我們會使用 <code>type</code> 關鍵字，例如我們可以建立 <code>i32</code> 的別名 <code>Kilometers</code>，如範例所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<p>現在，<code>Kilometers</code>  別名就是 <code>i32</code> 的<strong>同義詞</strong>。不像我們在範例 19-15 建立的 <code>Millimeters</code> 與 <code>Meters</code> 型別，<code>Kilometers</code> 並非獨立的新型別。型別為 <code>Kilometers</code> 的值會被當作型別是 <code>i32</code> 的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>由於 <code>Kilometers</code> 與 <code>i32</code> 實際上是同個型別，所以兩者可以相加，我們也可以將 <code>Kilometers</code> 值傳入需要 <code>i32</code> 參數的函式。然而，這種作法並不像前面討論的新型別模式一樣有益於型別檢查。也就是說，如果我們在某處混用 <code>Kilometers</code> 和 <code>i32</code>，編譯器不會給予任何錯誤。</p>
<p>型別同義詞的主要使用情境在於減少重複。例如我們有一個又臭又長的型別：</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>到處在函式簽名與型別註解寫這個型別既累人又容易失誤。想像你有一個專案的程式碼都長得像範例 19-24。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;嗨&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --省略--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --省略--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-24：在多處使用很長的型別</span></p>
<p>使用型別別名減少重複，讓程式碼更可控。範例 19-25，我們替落落長的型別導入一個 <code>Thunk</code> 別名，所有用到該型別之處都能用短小的 <code>Thunk</code> 替代。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;嗨&quot;));

    fn takes_long_type(f: Thunk) {
        // --省略--
    }

    fn returns_long_type() -&gt; Thunk {
        // --省略--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-25：導入型別別名 <code>Thunk</code> 來減少重複</span></p>
<p>這段程式碼更容易讀寫了！選擇有意義的型別別名也有助於溝通傳達你的意圖（<em>thunk</em> 是一個表示會在未來對此程式碼求值，所以很適用表達儲存起來的閉包）。</p>
<p>型別別名同樣十分常用在 <code>Result&lt;T, E&gt;</code> 來減少重複。試想標準函式庫的 <code>std::io</code> 模組，輸入輸出（I/O）操作通常會藉由回傳 <code>Result&lt;T, E&gt;</code> 來處理失敗的操作。標準函式庫有個 <code>std::io::Error</code> 結構體來表示所有可能的 I/O 錯誤。許多在 <code>std::io</code> 內的函式會回傳 <code>E</code> 為 <code>std::io::Error</code> 的 <code>Result&lt;T, E&gt;</code> ，例如這些 <code>Write</code> 特徵下的函式：</p>
<pre><code class="language-rust noplayground">use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
</code></pre>
<p>這些 <code>Result&lt;..., Error</code>&gt; 不斷重複，有鑑於此，<code>std::io</code> 宣告了這個型別的別名：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span></code></pre>
<p>由於這個宣告是在 <code>std::io</code> 模組內，因此我們可直接使用完全限定的別名 <code>std::io::Result&lt;T&gt;</code>，實際上就是 <code>E</code> 預先填入 <code>std::io::Error</code> 的 <code>Result&lt;T, E&gt;</code>。最終，<code>Write</code> 特徵的函式簽名就會長得這樣：</p>
<pre><code class="language-rust noplayground"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>型別別名有助於兩個面向：讓程式碼更容易撰寫，<strong>且</strong>對所有 <code>std::io</code> 提供一致的介面。因為它僅僅是別名，所以就是一個 <code>Result&lt;T, E&gt;</code> 而已，這意味著我們能使用任何可與 <code>Result&lt;T, E&gt;</code> 互動的方法，以及使用類似 <code>?</code> 運算子這種特殊語法。</p>
<h3 id="永不回傳的永不型別"><a class="header" href="#永不回傳的永不型別">永不回傳的永不型別</a></h3>
<p>Rust 有一個特殊的型別叫做 <code>!</code>，由於它沒有任何值，在型別理論的行話中又稱為<strong>空型別</strong>（empty type）。不過我們更喜歡稱之為<strong>永不型別</strong>（never type），因為當一個函式永遠不會回傳，永不型別將會替代原本的回傳型別。這裡來個範例：</p>
<pre><code class="language-rust noplayground">fn bar() -&gt; ! {
    // --省略--
<span class="boring">    panic!();
</span>}
</code></pre>
<p>這段程式碼可讀作「函式 <code>bar</code> 永不回傳」。永不回傳的函數稱為<strong>發散函式</strong>（diverging function），我們無法建立 <code>!</code> 型別，所以 <code>bar</code> 永遠無法回傳。</p>
<p>不過，若永遠無法替這個型別建立值，那要這個型別幹嘛呢？回想一下，範例 2-5 的猜數字程式碼，在我們的範例 19-26 又重現了。</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;請猜測一個數字！&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..=100);
</span><span class="boring">
</span><span class="boring">    println!(&quot;祕密數字為：{secret_number}&quot;);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;請輸入你的猜測數字。&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --省略--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;讀取該行失敗&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;你的猜測數字：{guess}&quot;);
</span><span class="boring">
</span><span class="boring">        // --省略--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;太小了！&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;太大了！&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;獲勝！&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 19-26：<code>match</code> 其中一個分支結束在 <code>continue</code></span></p>
<p>當時我們跳過了這段程式碼的一些細節。在第六章<a href="ch06-02-match.html#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E9%81%8B%E7%AE%97%E5%AD%90">「<code>match</code> 控制流運算子」</a><!-- ignore -->一節，我們探討了每個 <code>match</code> 分支必須回傳相同的型別，所以，例如以下程式碼就不能執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}
</span></code></pre>
<p>這段程式碼中 <code>guess</code> 的型別必須是<strong>同時是</strong>整數與字串，並且 Rust 要求 <code>guess</code> 只能是一種型別。那 <code>contiunue</code> 回傳了什麼？範例 19-26 中，為什麼允許一個分支回傳 <code>u32</code> 但同時有另一分支結束在 <code>continue</code>？</p>
<p>如你所猜，<code>continue</code> 具有 <code>!</code> 值。意即當 Rust 根據兩個分支來推算 <code>guess</code> 型別時，會觀察到前者會是 <code>u32</code>，而後者是 <code>!</code>。因為 <code>!</code> 永遠不會有值，Rust 於是決定 <code>guess</code> 的型別為 <code>u32</code>。</p>
<p>描述這種行為的正確方式是：<code>!</code> 型別的表達式能夠轉型為任意其他型別。我們允許 <code>match</code> 分支結束在 <code>continue</code> 就是因為 <code>continue</code> 不會回傳任何值，相反地，它將控制流移至迴圈的最上面，所以在 <code>Err</code> 的情況，我們不會對 <code>guess</code> 賦值。</p>
<p>永不型別在使用 <code>panic!</code> 巨集很實用。回想一下我們對 <code>Option&lt;T&gt;</code> 呼叫 <code>unwrap</code> 函式，會產生一個值或是恐慌，這是它的定義：</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>和範例 19-26 <code>match</code> 相同的情況，在這段程式碼再度上演：Rust 看到 <code>val</code> 的型別是 <code>T</code> 且 <code>panic</code> 是 <code>!</code> 型別，所以 <code>match</code> 表達式的總體結果是 <code>T</code>。這段程式碼可執行是因為 <code>panic!</code> 會結束程式而不會產生值。當遇上 <code>None</code> 的情形，我們不會從 <code>unwrap</code> 回傳任何值，所以這段程式碼合法有效。</p>
<p>最後一個具有 <code>!</code> 型別的表達式是 <code>loop</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;永永&quot;);

    loop {
        print!(&quot;遠遠&quot;);
    }
<span class="boring">}
</span></code></pre>
<p>這裡迴圈永不結束，所以 <code>!</code> 就是迴圈表達式的值。但當我們有一個 <code>break</code> 時，這就不成立了，因為迴圈會在抵達 <code>break</code> 時終止。</p>
<h3 id="動態大小型別與-sized-特徵"><a class="header" href="#動態大小型別與-sized-特徵">動態大小型別與 <code>Sized</code> 特徵</a></h3>
<p>Rust 需要了解其型別的特定細節，例如需替特定型別之值分配多少空間。這導致型別系統有令人困惑的小地方：即是<strong>動態大小型別</strong>（dynamically sized type）的概念。有時稱為 <em>DST</em> 或<strong>不定大小（unsize）型別</strong>，這些型別賦予我們寫出僅能在執行期（runtime）得知值的大小之程式碼。</p>
<p>讓我們深入研究一個貫穿全書到處使用的動態大小型別 <code>str</code> 的細節。你沒看錯，不是 <code>&amp;str</code> 而是 <code>str</code> 本身就是 DST。在執行期前我們無從得知字串多長，也就表示無法建立一個型別為 <code>str</code> 的變數，更不能將 <code>str</code> 型別作為引數。試想以下不能執行的程式碼：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}
</span></code></pre>
<p>Rust 必須知道該配置多少記憶體給特定型別之值，且所有該型別之值都會使用相同的記憶體量。若 Rust 允許我們寫出這種程式碼，代表這兩個 <code>str</code> 值會用相同的空間大小，但它們長度不同：<code>s1</code> 需要 12 位元組來儲存，而 <code>s2</code> 需要 15 位元組。這就是為什麼不可能建立一個持有動態大小型別的變數。</p>
<p>那我們該如何是好？這種情況下，你其實已經知道答案：將 <code>s1</code> 與 <code>s2</code> 的型別從 <code>str</code> 改成 <code>&amp;str</code>。回憶一下，第四章<a href="ch04-03-slices.html#%E5%AD%97%E4%B8%B2%E5%88%87%E7%89%87">「字串切片」</a><!-- ignore -->一節我們說了，切片資料結構會儲存該切片的開始位置與長度。所以雖然 <code>&amp;T</code> 是單一的值，儲存了 <code>T</code> 所在的記憶體位址，<code>&amp;str</code> 卻儲存<strong>兩個</strong>值：<code>str</code> 的位址與它的長度。如此一來，無論 <code>&amp;str</code> 指向的字串有多長，我們都可以在編譯期得知 <code>&amp;str</code> 的大小。一般來說，這就是動態大小型別在 Rust 中的使用方式，通常具有額外的資料紀錄動態資訊的大小。動態大小型別的黃金法則即是我們必將動態大小型別的值放在指向某種指標之後。</p>
<p>我們將各種指標與 <code>str</code> 結合，例如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事實上，你早已看過此類作法，不過是在其他動態大小型別上看過，那個型別就是特徵（trait）。每個特徵都是一個動態大小型別，我們可以透過使用特徵的名字來指涉它。在第十七章的<a href="ch17-02-trait-objects.html#%E5%85%81%E8%A8%B1%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5%E6%95%B8%E5%80%BC%E7%9A%84%E7%89%B9%E5%BE%B5%E7%89%A9%E4%BB%B6">「允許不同型別數值的特徵物件」</a>部分，我們提及欲將特徵做為特徵物件來使用，必須將特徵放在指標之後，例如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code>（<code>Rc&lt;dyn Trait&gt;</code> 也行）。</p>
<p>為了使用 DST，Rust 提供一個 <code>Sized</code> 特徵，來決定一個型別的大小可否在編譯期就確定下來。對於能在編譯期得知大小的所有東西，都會自動實作這個特徵。此外 Rust 自動替所有泛型函式隱含加上 <code>Sized</code> 的約束。也就是說若一泛型函數定義如下：</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --省略--
}
</code></pre>
<p>實際上就如同寫成這樣：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --省略--
}
</code></pre>
<p>預設情形下，泛型函式只能在編譯器得知大小的型別上使用。然而，你可以加上以下這個特殊語言來放寬這個限制：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --省略--
}
</code></pre>
<p><code>?Sized</code> 特徵界限代表「<code>T</code> 可能是或不是 <code>Sized</code>」，而此詮釋會覆蓋原本預設泛型型別必須在編譯期就已知大小。<code>?Trait</code> 的語法與語義只能用在 <code>Sized</code>，不適用於其他特徵。</p>
<p>也請注意，我們將參數 <code>t</code> 的型別由 <code>T</code> 轉為 <code>&amp;T</code>，是因為這個型別可能不是 <code>Sized</code>，所以我們需要將它放在指標之後才能使用之，而在這例子中，我們選擇將它放在參考之後。
接下來，我們會聊聊函式和閉包！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="進階函式與閉包"><a class="header" href="#進階函式與閉包">進階函式與閉包</a></h2>
<p>本節探索函式與閉包相關的進階特色，包括函式指標和回傳閉包。</p>
<h3 id="函式指標"><a class="header" href="#函式指標">函式指標</a></h3>
<p>我們已探討過如何將閉包傳遞給函式，其實你還可以將一般的函式傳給函式！當你想要傳遞已經定義好的函式，而不是新的閉包時，就會凸顯這個技巧好用之處。函式將會轉型為 <code>fn</code> 型別（小寫的 f），別和閉包特徵的 <code>Fn</code> 搞混了。這個 <code>fn</code> 型別就稱為<strong>函式指標</strong>（function pointer）。你可以將函數作為函式指標傳遞，當作其他函式的引數。</p>
<p>將函式指標當作參數傳遞的語法，和閉包相當相似，如範例 19-27 所示。我們定義了函式 <code>add_one</code>，替其參數加一。函數 <code>do_twice</code> 接受兩個參數：一個函式指標，指向任何輸入 <code>i32</code> 且回傳 <code>i32</code> 和 <code>i32 value</code> 的函式。<code>do_twice</code> 函式呼叫函式 <code>f</code> 兩次，並傳遞 <code>arg</code> 的數值，再將兩個函式呼叫的回傳值加總。<code>main</code> 函式以引數 <code>add_one</code> 和 <code>5</code> 呼叫 <code>do_twice</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;答案是：{}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">範例 19-27：藉由 <code>fn</code> 型別接收函式指標引數</span></p>
<p>這段程式碼會印出 <code>答案是：12</code>。我們可以指定 <code>do_twice</code> 的參數 <code>f</code> 是一個需要一個 <code>i32</code> 當參數的 <code>fn</code>，並會回傳 <code>i32</code>。接下來我們在 <code>do_twice</code> 內呼叫 <code>f</code>。在 <code>main</code> 中，我們就可將 <code>add_one</code> 函式作為 <code>do_twice</code> 第一個引數。</p>
<p>和閉包不同的是，<code>fn</code> 不是特徵而是一個型別，所以我們可以直接將 <code>fn</code> 作為參數型別，而不需要宣告一個以 <code>Fn</code> 特徵作為特徵限制的泛型型別參數。</p>
<p>函式指標將 三個閉包特徵（<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>）通通實作了，意思是在預期要傳入閉包之處，你一定可以將函式指標作為引數傳進去。最佳的做法是寫一個同時使用泛型型別和其中一個閉包特徵的函式，這樣無論是函式還是閉包，你的函式全都可以接收。</p>
<p>也就是說，有個你只會想接收 <code>fn</code> 但不要閉包的例子，就是當你在與外部那些沒有閉包的程式碼打交道的時候，比如 C 可以接收函式作為引數，但 C 並沒有閉包。</p>
<p>讓我們來看一下標準函式庫中 <code>Iterator</code> 特徵提供的 <code>map</code> 的用法，<code>map</code> 就是可以用行內閉包（closure defined inline）或一個命名函式（named function）的例子。欲將數字的向量轉換成字串的向量，我們可以使用閉包，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<p>或者，我們也可以將一個函式作為引數，代替閉包傳入 <code>map</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<p>請注意，因為有多個可用的函式都叫做 <code>to_string</code>，所以我們必須使用先前在<a href="ch19-02-advanced-traits.html#%E9%80%B2%E9%9A%8E%E7%89%B9%E5%BE%B5">「進階特徵」</a>一節提及的完全限定語法。這裡，我們使用了在 <code>ToString</code> 特徵中定義的 <code>to_string</code> 函式，只要有實作 <code>Display</code> 的型別，標準函式庫都會提供 <code>ToString</code> 的實作。</p>
<p>回想一下第六章<a href="ch06-01-defining-an-enum.html#%E6%9E%9A%E8%88%89%E6%95%B8%E5%80%BC">「枚舉數值」</a><!-- ignore -->一節提及，我們定義的每個枚舉變體的名字，也是一個初始化函式，我們可以將這些初始化函式當作實作了閉包特徵的函式指標，這就代表我們可以指定初始化函式作為引數，傳給需要閉包的方法，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}
</span></code></pre></pre>
<p>這裡，我們對一個範圍呼叫 <code>map</code>，並用每個 <code>u32</code> 值，透過 <code>Status::Value</code> 的初始化函式來建立 <code>Status::Value</code> 的實例。有些人更喜歡上述的作法，但有人偏好閉包。這兩者的編譯結果相同，所以選一個你覺得清晰的風格吧。</p>
<h3 id="回傳閉包"><a class="header" href="#回傳閉包">回傳閉包</a></h3>
<p>閉包是用特徵來表示，言下之意是你不能直接回傳一個閉包。大多數的情況，當你想回傳一個特徵時，可以改回傳有實作該特徵的具體型別。但你並無法對閉包這樣做，因為它們根本沒有可供回傳的具體型別，比方說不允許你使用 <code>Fn</code> 特徵作為回傳型別。</p>
<p>接下來的程式碼嘗試直接回傳一個閉包，但它無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>編譯錯誤如下：</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:8]`, which implements `Fn(i32) -&gt; i32`
  |
1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
  |                         ~~~~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0746`.
error: could not compile `functions-example` due to previous error
</code></pre>
<p>這個錯誤再度指出 <code>Sized</code> 特徵！Rust 不知道我們需要多少空間儲存這個閉包，我們之前看過這類問題的解法。可以使用特徵物件：</p>
<pre><code class="language-rust noplayground">fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre>
<p>這段程式碼恰巧能通過編譯。欲知更多特徵物件相關資訊，請查閱第十七章<a href="ch17-02-trait-objects.html#%E5%85%81%E8%A8%B1%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5%E6%95%B8%E5%80%BC%E7%9A%84%E7%89%B9%E5%BE%B5%E7%89%A9%E4%BB%B6">「允許不同型別數值的特徵物件」</a>部分。</p>
<p>接下來，讓我們來探討巨集吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="巨集"><a class="header" href="#巨集">巨集</a></h2>
<p>在本書中，我們到處使用像 <code>println!</code> 這類的巨集（macro），但尚未完全探索巨集究竟是何物，以及該如何駕馭。<strong>巨集</strong>指的是一整家族的 Rust 功能集合：使用 <code>macro_rules!</code> 的<strong>宣告式（declarative）巨集</strong>，以及另外三種<strong>程序式（procedural）巨集</strong>：</p>
<ul>
<li>自訂 <code>#[derive]</code> 巨集，可以將指定的程式碼加在使用 <code>derive</code> 屬性的結構體和枚舉</li>
<li>類屬性巨集，定義可以用在任何項目的自訂屬性</li>
<li>類函式巨集，看起來像是函式的呼叫但實際上將標記（token）當作引數來處理</li>
</ul>
<p>我們將會按照順序聊聊每種巨集，但首先，來看看為什麼我們已經有了函式，仍需要巨集呢？</p>
<h3 id="巨集與函式的差異"><a class="header" href="#巨集與函式的差異">巨集與函式的差異</a></h3>
<p>基本上，巨集是一種透過寫程式碼來產生其他程式碼的手段，又稱作<strong>超程式設計</strong>（metaprogramming）。像是在附錄 C，我們探討的 <code>derive</code> 屬性，這個屬性會替你產生多種特徵的實作。還有在整本書中到處使用 <code>println!</code> 和 <code>vec!</code> 兩巨集。以上這些巨集都會<strong>展開</strong>來，產生比你自己手寫的還要多的程式碼。</p>
<p>超程式設計對減少撰寫和維護的程式碼量非常有幫助，這和函式扮演的角色相同，然而，巨集具有函式沒有的特殊本事。</p>
<p>一個函式簽名必須宣告該函式需要的參數型別與數量。反觀巨集可以接收變動數量的參數：我們可以用一個參數呼叫 <code>println!(&quot;hello&quot;)</code> ，也可以是兩個參數的 <code>println!(&quot;hello {}&quot;, name)</code>。另外，巨集會在編譯器開始翻譯程式碼的意義之前展開。例如可以使用巨集實作一個特徵。這種事函式便無法做到，因為函式會在執行期呼叫，而特徵需要在編譯期就實作。</p>
<p>選擇實作巨集而不用函式也有缺點，巨集的定義比函式更加複雜，因為你是在寫寫 Rust 程式碼的 Rust 程式碼。就是因為這種間接迂迴的關係，一般情況下，相較於函式來說巨集的定義都更加難以閱讀、理解與維護。</p>
<p>另一個巨集和函式之間的重要的的差異，在一個檔案中想呼叫巨集，必須在作用域（scope）內定義或是將巨集帶到這個作用域，而反過來函式可以在任何地方定義與呼叫。</p>
<h3 id="使用-macro_rules-宣告式巨集做普通的超程式設計"><a class="header" href="#使用-macro_rules-宣告式巨集做普通的超程式設計">使用 <code>macro_rules!</code> 宣告式巨集做普通的超程式設計</a></h3>
<p>Rust 中最廣泛使用的巨集形式非<strong>宣告式巨集</strong>莫屬。這種巨集有時也稱為「巨集為例（macros by example）」、「<code>macro_rules!</code>」，或是直白的「巨集」。宣告式巨集的核心就是賦予你寫些類似 Rust <code>match</code> 表達式的東西。在第六章我們聊了 <code>match</code> 表達式是一種流程控制結構，會拿一個表達式，將其結果值與其他模式作比較，並執行匹配模式對應的程式碼。巨集同樣會拿一個值，與模式相比較，而這個模式又與特定程式碼相關聯：這種情況會是，傳入巨集的值就是一字一字刻出來 Rust 原始碼，而所謂模式則是比較原始碼的結構，當原始碼與模式相匹配，就會帶入與模式關聯的這段特定程式碼，取代原先傳入巨集的原始碼。這些都發生在編譯的期間。</p>
<p>你可以透過 <code>macro_rules!</code> 定義一個巨集。讓我們藉著閱讀 <code>vec!</code> 的定義來探索如何使用 <code>macro_rules!</code>。第八章我們介紹了如何使用 <code>vec!</code> 巨集來建立含有特定值的向量。例如，下面的巨集會建立帶著三個整數的新向量：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>我們也可利用 <code>vec!</code> 巨集產生兩個整數的向量或是五個字串的 切片。因為不能預先得知這些值的數量，所以我們無法透過函式做到這件事。</p>
<p>範例 19-28 展示了稍微簡化過的 <code>vec!</code> 巨集定義。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>
<p><span class="caption">範例 19-28：<code>vec!</code> 巨集定義簡化版</span></p>
<blockquote>
<p>注意：在標準函式庫中真實的 <code>vec!</code> 巨集定義有預先配置正確記憶體用量的程式碼，因為這段程式碼是一種最佳化手段，為了簡化範例，並無將之包含其中。</p>
</blockquote>
<p>這個 <code>#[macro_export]</code> 標註（annotation）用來指明只要這個 crate 有在程式碼可見作用域中，就可以使用該巨集。若沒有這個標註，巨集就不能帶入該作用域內。</p>
<p>我們的巨集定義從 <code>macro_rules!</code> 和我們欲定義的巨集名稱<strong>去除</strong>驚嘆號開始。這個名稱，在我們例子裡是 <code>vec</code>，的後面接著花括號表示巨集定義的本體。</p>
<p>這個 <code>vec!</code> 本體的結構和 <code>match</code> 表達式的結構相似。這裡我們有一個 match 分支，帶著模式 <code>( $( $x:expr ),* )</code>，並接著 <code>=&gt;</code> 後面與該模式相關聯的程式碼區塊。這個分支是此巨集唯一一個模式，所以只有一個合法匹配方式；任何其他模式都會產生錯誤。更複雜的巨集會有多於一個分支。</p>
<p>合法的巨集定義模式語法和在第十八章的模式語法並不相同，巨集的模式並不跟值比較，而是與 Rust 程式碼的結構相互匹配。在範例 19-28 我們會走過一次這些模式的意義，至於完整的巨集模式語法，請閱讀 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust 參考手冊</a>。</p>
<p>首先，我們用一對括號包圍整個模式。我們使用錢字號（<code>$</code>）在巨集系統定義一個變數，該變數將包含與模式匹配的 Rust 程式碼。採用錢字號清楚展現它並非尋常的 Rust 變數，而是巨集變數。再來就是一對括號，用以捕獲與括號內的模式匹配之值，以替換為程式碼。在 <code>$()</code> 內的 <code>$x:expr</code> 會匹配任意 Rust 表達式，並賦予表達式一個 <code>$x</code> 名稱。</p>
<p>在 <code>$()</code> 後的逗號代表字面上的逗號分隔，可以選擇性地在匹配 <code>$()</code> 內的程式碼後出現。而 <code>*</code> 這指明，這個模式可以匹配零至多個在 <code>*</code> 之前的東西。</p>
<p>當我們的以 <code>vec![1, 2, 3]</code> 呼叫這個巨集，<code>$x</code> 模式會匹配到三次，分別為 <code>1</code>、<code>2</code> 和 <code>3</code> 三個表達式。</p>
<p>現在來看看這個模式分支的本體程式碼：在 <code>$()*</code> 內的 <code>temp_vec.push()</code> 會根據 <code>$()</code> 模式匹配了幾次而產生幾次。這個 <code>$x</code> 會被每個匹配的表達式取代。當我們使用 <code>vec![1, 2, 3]</code> 呼叫巨集時，這個取代巨集呼叫而產生出來的程式碼會是：</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>我們定義了一個巨集，接收任意數量任意型別的引數，並產生建立一個包含指定元素的向量的程式碼。</p>
<p>想理解更多有關撰寫巨集之事，可查閱線上文件或其他資源，例如原作者 Daniel Keep 與後繼維護者 Lukas Wirth 所寫的<a href="https://veykril.github.io/tlborm/">「The Little Book of Rust Macros」</a>。</p>
<h3 id="使用程序式巨集從屬性產生程式碼"><a class="header" href="#使用程序式巨集從屬性產生程式碼">使用程序式巨集從屬性產生程式碼</a></h3>
<p>第二種巨集形式是<strong>程序式巨集</strong>，其行為更像是函式（也是一種程序）。程序式巨集接受一些程式碼作為輸入，操作這些程式碼，然後輸出一些程式碼。和宣告式巨集去匹配模式和取代程式碼的方式不同。三種程序式巨集（自訂 derive，類屬性、類函式）都有著相近的工作方式。</p>
<p>當建立一個程序式巨集時，該巨集必須放置在自己特殊的一種 crate 中。會這種是因為一些複雜的技術問題，我們希望在未來消弭這個情況。範例 19-29 我們展示了如何定義程序式巨集，其中 <code>some_attribute</code> 是一個用來代表特定巨集的佔位符。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">範例 19-29：定義一個程序式巨集</span></p>
<p>這個函式定義一個程序式巨集，接受輸入 <code>TokenStream</code>，並輸出 <code>TokenStream</code>。<code>TokenStream</code> 型別定義在 <code>proc_macro</code> crate 中，這個 crate 包含在 Rust 中，可以表示一連串的標記，這就是巨集的核心：巨集替來自輸入的 <code>TokenStream</code> 搽脂抹粉，而巨集產生的程式碼就是輸出的 <code>TokenStream</code>。上面例子中這個函式附加了一個屬性，指定我們要產生哪個程序式巨集。在同一個 crate 中我們可以使用多個不同的程序式巨集。</p>
<p>我們來看不同的程序式巨集吧。就從自訂 derive 巨集開始，逐步介紹它與其他種類巨集的細部差異。</p>
<h3 id="如何撰寫自訂的-derive-巨集"><a class="header" href="#如何撰寫自訂的-derive-巨集">如何撰寫自訂的 <code>derive</code> 巨集</a></h3>
<p>我們建立一個 <code>hello_macro</code> crate，並定義 <code>HelloMacro</code> 特徵與它的 <code>hello_macro</code> 關聯函式。我們提供一個程序式巨集，讓 crate 的使用者透過 <code>#[derive(HelloMacro)]</code> 標註它們的型別，來獲得預設的 <code>hello_macro</code> 函式的實作，而不需要使用者替每個型別手動實作 <code>HelloMacro</code> 特徵。這個預設的函式實作會印出 <code>你好，巨集，我叫做型別名稱！</code>，其中 <code>型別名稱</code> 是實作特徵那個型別的名字。換句話說，就是我們會寫出一個 crate，讓其他程式設計師用我們的 crate，以範例 19-30 的方式來寫程式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">範例 19-30：使用者使用我們的程序式巨集時，能夠寫出的程式碼</span></p>
<p>當我們完成後，這段程式碼會印出 <code>你好，巨集！我叫做鬆餅！</code>。第一步，先建立一個新的函式庫 crate：</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>接下來，我們會定義 <code>HelloMacro</code> 特徵與它的關聯函式：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub trait HelloMacro {
    fn hello_macro();
}
</code></pre>
<p>我們有個特徵及其函式。至此，我們的 crate 使用者可以實作此特徵來達成他們想要的功能，例如：</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;你好，巨集！我叫做鬆餅！&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>然而，使用者必須自行替每個想使用 <code>hello_macro</code> 的型別分別撰寫實作區塊，我們想節約這些重複工作。</p>
<p>另外，我們尚未提供 <code>hello_macro</code> 函式的預設實作，這個預設實作將會印出實作該特徵的型別名稱，但 Rust 並沒有反射（reflection）這種功能，所以無法在執行期檢查型別，因此我們需要一個巨集在編譯期產生程式碼。</p>
<p>下一步是定義程序式巨集。在我們寫此章時，程序式巨集必須在自己的 crate 中定義，最終這個限制會解除。組織安排 crate 和巨集 crate 的慣例如下：有一個 crate <code>foo</code> 和一個自訂 derive 程序式巨集 crate <code>foo_derive</code>，讓我們在 <code>hello_macro</code> 專案中建立一個新的 crate <code>hello_macro_derive</code>：</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>由於我們的兩個 crate 高度關聯，所以會在 <code>hello_macro</code> crate 的目錄中建立一個程序式巨集 crate。若我們改變 <code>hello_macro</code> 中定義的特徵，就必須同時改變 <code>hello_macro_derive</code> 中的程序式巨集。這兩個 crate 必須各自發佈，且若程式設計師想要使用這些 crate，則必須將兩者都加入為依賴（dependency），並將之引入作用域。當然，我們也可以讓 <code>hello_macro</code> 將 <code>hello_macro_derive</code> 作為一個依賴並重新導出（re-export）該程序式巨集。然而，我們這樣組織專案的方式就是想提供當程式設計師不想要 <code>derive</code> 功能時，也可以直接使用 <code>hello_macro</code>。</p>
<p>我們必須宣告 <code>hello_macro_derive</code> 為一個程序式巨集 crate。我們同時需要等會兒就會遇到的 <code>syn</code> 和 <code>quote</code> 這些 crate 的功能，所以先將他們加至依賴。至此，<code>hello_macro_derive</code> 的 <em>Cargo.toml</em> 會加入以下的程式碼：</p>
<p><span class="filename">檔案名稱：hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>欲開始定義程序式巨集，請將範例 19-31 的程式碼放入你的 <code>hello_macro_derive</code> crate 的 <em>src.lib.rs</em> 檔案中。注意，在我們定義 <code>impl_hello_macro</code> 函式之前，這段程式碼都無法編譯。</p>
<p><span class="filename">檔案名稱：hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 建構 Rust 程式碼的語法樹呈現
    // 讓我們可以進行操作
    let ast = syn::parse(input).unwrap();

    // 建構特徵實作
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">範例 19-31：若要產生 Rust 程式碼，絕大部分程序式巨集 crate 都必須包含這段程式碼</span></p>
<p>留意到了嗎，我們將程式碼函式拆分，其中 <code>hello_macro_derive</code> 函式負責解析 <code>TokenStream</code>，而 <code>impl_hello_macro</code> 函式則用來轉換語法樹（syntax tree），這讓撰寫程序式巨集更為方便。外面這個函式的程式碼（在這例子是 <code>hello_macro_derive</code>）在每個你遇見或建立的程序式巨集裡看起來都幾乎一模一樣。而在裡面的函式（在這個例子是 <code>impl_hello_macro</code>）的本體則根據不同程序式巨集的目的而有所不同。</p>
<p>我們導入了三個新 crate：<code>proc_macro</code>，<a href="https://crates.io/crates/syn"><code>syn</code></a> 和 <a href="https://crates.io/crates/quote"><code>quote</code></a>。<code>proc_macro</code> 包含在 Rust 裡面，所以我們不需要將之加入 <em>Cargo.toml</em>。<code>proc_macro</code> crate 就是編譯器的 API，提供從我們的程式碼讀取和操作 Rust 程式碼。</p>
<p><code>syn</code> crate 負責從字串解析 Rust 程式碼，轉成我們可以操作的資料結構。而 <code>qoute</code> crate 則將 <code>syn</code> 的資料結構轉回 Rust 程式碼。撰寫完整的 Rust 程式碼解析器並不是容易的工作，而這些 crate 讓解析任何 Rust 程式碼更為簡便。</p>
<p>當使用者在一個型別上指定 <code>#[derive(HelloMacro)]</code>，<code>hello_macro_derive</code> 函式就會被呼叫，這是由於我們使用 <code>proc_macro_derive</code> 和指定的 <code>HelloMacro</code> 名稱來標註 <code>hello_macro_derive</code> 函式，而其中的 <code>HelloMacro</code> 是我們的特徵名稱。以上就是大多數程序式巨集遵守的慣例。</p>
<p><code>hello_macro_derive</code> 函式會先將輸入 <code>input</code> 的 <code>TokenStream</code> 轉換成一個我們可以翻譯並執行操作的資料結構，這就是 <code>syn</code> 參與的部分，<code>syn</code> 的 <code>parse</code> 函式需要一個 <code>TokenStream</code> 並回傳一個 <code>DeriveInput</code> 結構體，代表解析過後的 Rust 程式碼。範例 19-32 展示了解析完 <code>struct Pancakes</code> 字串後所得的 <code>DeriveInput</code> 的部分：</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --省略--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">範例 19-32：這是在範例 19-30 解析具有 macro 屬性的程式碼時所得的 <code>DeriveInput</code> 實例</span></p>
<p>這些結構體的欄位展示了解析過後的 Rust 程式碼是一個結構體，帶著 <code>ident</code>（識別字 identifier）。這裡其他結構體的欄位都在描述 Rust 程式碼，更多資訊請參考 <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code> 有關 <code>DeriveInput</code> 的文件</a>。</p>
<p>我們很快就進入定義 <code>impl_hello_macro</code> 函式的環節，這個函式協助打造我們想要的新 Rust 程式碼。再動手做之前，注意我們的 derive 巨集輸出也是一個 <code>TokenStream</code>。回傳的 <code>TokenStream</code> 會添加到我們的 crate 使用者撰寫的程式碼中，因此，當他們編譯他們的 crate 時，會從我們提供的修編過的 <code>TokenStream</code> 中取得額外功能。</p>
<p>也許你注意到我們對 <code>hello_macro_derive</code> 呼叫 <code>unwrap</code> 讓 <code>sync::parse</code> 函式失敗時恐慌。由於我們需要符合 <code>proc_macro_derive</code> 程序式巨集的 API 定義，回傳一個 <code>TokenStream</code> 而非 <code>Result</code>，所以我們的程序式巨集必須在錯誤時恐慌。這裡使用 <code>unwrap</code> 是為了簡化範例，在正式環境程式碼中，你應該透過 <code>panic!</code> 或 <code>expect</code> 提供更特定的錯誤訊息，告知什麼出錯了。</p>
<p>現在，被標註的 Rust 程式碼已經從一個 <code>TokenStream</code> 轉換成 <code>DeriveInput</code> 實例，現在來替被標註的型別產生實作 <code>HelloMacro</code> 特徵的程式碼，如範例 19-33。</p>
<p><span class="filename">檔案名稱：hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // 建構 Rust 程式碼的語法樹呈現
</span><span class="boring">    // 讓我們可以進行操作
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // 建構特徵實作
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;你好，巨集，我叫做{}！&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">範例 19-33：利用解析過的 Rust 程式碼來實作 <code>HelloMacro</code> 特徵</span></p>
<p>我們從 <code>ast.ident</code> 取得 <code>Ident</code> 結構體實例，這個實例中帶有被標註的型別之名稱（識別字）。當我們執行在範例 19-30 程式碼中的 <code>impl_hello_macro</code> 函式，會獲得一個 <code>ident</code>，帶有一個值為 <code>&quot;Pancakes&quot;</code> 的 <code>ident</code> 欄位，就如同範例 19-30 所示。因此，在範例 19-33 的 <code>name</code> 變數會包含一個 <code>Ident</code> 結構體實例，當我們印之，會出現字串 <code>&quot;Pancakes&quot;</code>，也就是該結構體在範例 19-30 所示的名字。</p>
<p><code>quote!</code> 巨集提供我們定義想要回傳的 Rust 程式碼。編譯器期望接收到不同於 <code>quote!</code> 巨集執行後直接輸出的結果，所以我們需要將結果轉換為一個 <code>TokenStream</code>。我們透過呼叫 <code>into</code> 方法達成，這個方法會消耗中介碼（intermediate representation）並回傳一個型別為 <code>TokenStream</code> 之值。</p>
<p><code>quote!</code> 巨集也提供非常炫的模板機制：我們可以輸入 <code>#name</code>，而 <code>quote!</code> 會以變數 <code>name</code> 值取而代之。我們甚至可以做一些類似普通巨集的重複工作。閱讀 <a href="https://docs.rs/quote"><code>quote</code> crate 的文件</a>以獲得完整的介紹。</p>
<p>我們想要我們的程序式巨集對使用者標註的型別產生 <code>HelloMacro</code> 特徵的實作，這個標註的型別名稱可以從 <code>#name</code> 取得。這個特徵的實作有一個函式 <code>hello_macro</code>，函式本體包含我們想要的功能：印出 <code>你好，巨集，我叫做</code> 再加上被標註的型別的名稱。</p>
<p><code>stringify!</code> 巨集是 Rust 內建的，會將一個 Rust 表達式，例如 <code>1 + 2</code>，在編譯期轉換成字串字面值（string literal），例如 <code>&quot;1 + 2&quot;</code>。這和 <code>format!</code> 或 <code>println!</code> 巨集會對表達式求值並將結果轉為 <code>String</code> 不同。因為輸入的 <code>#name</code> 可能是一個表達式，但要直接照字面印出來，所以我們選擇使用 <code>stringify!</code>。使用 <code>stringify!</code> 也可以節省在編譯器因為轉換 <code>#name</code> 成為字串字面量所需的空間配置。</p>
<p>至此，<code>cargo build</code> 應該可以成功在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 完成。我們在範例 19-30 來玩玩這些 crate 看看他們如何實際作用！先在你的<strong>專案</strong>目錄下，透過 <code>cargo new pancakes</code> 建立一個新的執行檔專案。我們必須將 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 加入 <code>pancakes</code> 的 <em>Cargo.toml</em> 作為依賴。若你已經發佈自己的 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本到 <a href="https://crates.io/">crates.io</a>，他們就是普通的依賴；若無，你可以指定他們為 <code>path</code> 的依賴，如下：</p>
<pre><code class="language-toml">hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>將這段程式碼放到範例 19-30 的 <em>src/main.rs</em> 並執行 <code>cargo run</code>，他應該會印出 <code>你好，巨集！我叫做鬆餅！</code>。這個由程序式巨集實作的 <code>HelloMacro</code> 特徵，不需要 <code>pancakes</code> 自行手動實作，而是透過 <code>#[derive(HelloMacro)]</code> 將特徵的實作加上去。</p>
<p>接著，一起來探索其他種類的程序式巨集和自訂 derive 巨集有何不同。</p>
<h3 id="類屬性巨集"><a class="header" href="#類屬性巨集">類屬性巨集</a></h3>
<p>類屬性巨集和自訂 derive 巨集相似，但並非只能透過 <code>derive</code> 屬性產生程式碼，類屬性巨集讓你可以建立新的屬性。它們更靈活：<code>derive</code> 只能用在結構體和枚舉，而屬性可以用在其他項目之上，例如函式。這裡有個類屬性巨集例子，是在使用一個網頁應用程式框架時，透過你的 <code>route</code> 屬性來標註一個函式：</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>這個 <code>#[route]</code> 屬性在該框架以程序式巨集定義之，其巨集定義函式的簽名如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>這裡，我們有兩個 <code>TokenStream</code> 型別的參數，第一個是屬性的內容，也就是 <code>Get, &quot;/&quot;</code> 這部分。第二部分則是該屬性附著的項目本體：在這個例子就是 <code>fn index() {}</code> 及其函式本體。</p>
<p>除此之外，類屬性巨集的工作方式和自訂 derive 巨集一樣：透過 <code>proc-macro</code> crate 建立一個 crate，並實作一個函式替你產生程式碼！</p>
<h3 id="類函式巨集"><a class="header" href="#類函式巨集">類函式巨集</a></h3>
<p>類函式巨集可以定義和函式呼叫很類似的巨集。和 <code>marco_rules!</code> 一樣，類函式巨集比函式更有靈活，例如可以接收未知長度的引數。然而，<code>macro_rules!</code> 巨集只能使用像 match 一樣的語法，如同早前在<a href="ch19-05-macros.html#%E4%BD%BF%E7%94%A8-macro_rules-%E5%AE%A3%E5%91%8A%E5%BC%8F%E5%B7%A8%E9%9B%86%E5%81%9A%E6%99%AE%E9%80%9A%E7%9A%84%E8%B6%85%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">「使用 <code>macro_rules!</code> 宣告式巨集做普通的超程式設計」</a>一節所述。而類函式巨集則可以拿 <code>TokenStream</code> 參數及其定義來操作 Rust 程式碼，和另外兩個程序式巨集所做的一模一樣。</p>
<p>舉個例子，一個 <code>sql!</code> 類函式巨集可能會被這樣呼叫：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>這個巨集會解析他內部的 SQL 陳述句（statement），並檢查語法是否正確，這個過程比 <code>macro_rules!</code> 能做到的複雜太多。這個 <code>sql!</code> 巨集定義如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>這個定義和自訂 derive 巨集簽名相似：我們接受在括號內的標記，並回傳想要產生的程式碼。</p>
<h2 id="總結-18"><a class="header" href="#總結-18">總結</a></h2>
<p>呼！現在你的工具箱多了一些 Rust 特色功能，雖然不常用，但在特定情況下你會知道它們存在。我們介紹了許多複雜的主題，所以當你在錯誤訊息或是其他人的程式碼與它們相遇，你會有辦法辨認這些概念和語法。你可以將這章作為能引導找到解法的參考書。</p>
<p>接下來，我們會動手做另一個專案，實際運用本書所講的一切。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="最終專案建立多執行緒網頁伺服器"><a class="header" href="#最終專案建立多執行緒網頁伺服器">最終專案：建立多執行緒網頁伺服器</a></h1>
<p>這真是趟漫長的旅途，但我們已經抵達本書的最終章了。在本章中，我們會在建構另一個專案來解釋最後幾章提到的概念，並複習一些之前更早的章節。</p>
<p>在我們的最終專案，我們將建立一個可以回覆「hello」的網頁伺服器，如圖示 20-1 的網頁瀏覽器所示。</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">圖示 20-1：我們的最終專案</span></p>
<p>以下是我們建構網頁伺服器的計劃：</p>
<ol>
<li>學習一些 TCP 與 HTTP。</li>
<li>在插座（socket）上監聽 TCP 連線。</li>
<li>解析一些的 HTTP 請求。</li>
<li>建立合適的回應。</li>
<li>透過執行緒池（thread pool）改善伺服器的吞吐量。</li>
</ol>
<p>不過在我們開始之前，我們需要提醒一件事，我們使用的方法不會是在 Rust 中建立網頁伺服器的最佳方案。<a href="https://crates.io/">crates.io</a> 上有不少已經能用在正式環境的 crate，它們都有提供比我們所建立的還更完善的網頁伺服器與執行緒池。然而我們在本章節的目的是要幫助你學習，而不是走捷徑。因為 Rust 是個系統程式設計語言，我們可以選擇我們想運用的抽象層級，而且可以比其他語言更可能且實際地抵達最底層。我們會親自寫出基本的 HTTP 伺服器與執行緒池，來幫助你瞭解往後你可能會用到的 crate 背後的基本概念與技術。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="建立單一執行緒的網頁伺服器"><a class="header" href="#建立單一執行緒的網頁伺服器">建立單一執行緒的網頁伺服器</a></h2>
<p>我們會先從建立一個可運作的單一執行緒網頁伺服器作為起始。在我們開始之前，讓我們快速瞭解一下建構網頁伺服器會涉及到的協定。這些協定的細節超出本書的範疇，不過以下簡短的概覽可以提供你所需要知道的訊息。</p>
<p>網頁伺服器會涉及到的兩大協定為<strong>超文本傳輸協定（Hypertext Transfer Protocol, HTTP）<strong>與</strong>傳輸控制協定（Transmission Control Protocol, TCP）</strong>。這兩種協定都是<strong>請求-回應（request-response）<strong>協定，這意味著</strong>客戶端</strong>會初始一個請求，然後<strong>伺服器</strong>接聽請求並提供回應給客戶端。協定會定義這些請求與回應的內容。</p>
<p>TCP 是個較底層的協定並描述資訊如何從一個伺服器傳送到另一個伺服器的細節，但是它並不指定資訊內容為何。HTTP 建立在 TCP 之上並定義請求與回應的內容。技術上來說，HTTP 是可以與其他協定組合的，但是對大多數場合中，HTTP 主要還是透過 TCP 來傳送資訊。我們會處理 TCP 與 HTTP 中請求與回應的原始位元組（raw bytes）。</p>
<h3 id="監聽-tcp-連線"><a class="header" href="#監聽-tcp-連線">監聽 TCP 連線</a></h3>
<p>我們的網頁伺服器需要監聽一個 TCP 連線，所以這就是我們要處理的第一個步驟。標準函式庫有提供 <code>std::net</code> 模組能讓我們使用。讓我們如往常一樣建立一個新的專案：</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>現在輸入範例 20-1 的程式碼到 <em>src/main.rs</em>。此程式碼會監聽 <code>127.0.0.1:7878</code> 本地位址（address）傳來的 TCP 流（Stream）。當其收到傳入的資料流時，它就會印出 <code>連線建立！</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;連線建立！&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">範例 20-1：監聽傳入的流並在收到流時顯示訊息</span></p>
<p>透過 <code>TcpListener</code>，我們可以監聽 <code>127.0.0.1:7878</code> 位址上的 TCP 連線。在位址中，分號之前指的是代表你電腦自己的 IP 位址（每部電腦都一樣，這並不只是用於本書作者電腦的例子），然後 <code>7878</code> 是通訊埠（port）。我們選擇此通訊埠的原因有兩個：HTTP 通常不會佔用此通訊埠，所以我們的伺服器不太可能會與你機器上執行的其他網路伺服器衝突，而且在傳統電話的九宮格上輸入 7878 的話就是「rust」。</p>
<p>在此情境中的 <code>bind</code> 函式與常見的 <code>new</code> 函式行為類似，這會回傳一個新的 <code>TcpListener</code> 實例。此函式會叫做 <code>bind</code> 的原因是因為在網際網路中，連接一個通訊埠並監聽就稱為「綁定（bind）通訊埠」。</p>
<p><code>bind</code> 函式會回傳 <code>Result&lt;T, E&gt;</code>，也就是說綁定可能會失敗。舉例來說，連接通訊埠 80 需要管理員權限（非管理員使用者可以連接 1023 以上的通訊埠），所以如果我們不是管理員卻嘗試連接通訊埠 80 的話，綁定就不會成功。另一個例子是，如果執行同個程式碼兩次產生兩個實例，造成這兩個程式同時監聽同個通訊埠的話，綁定也不會成功。由於我們只會寫個用於學習目的的基本伺服器，我們不太需要擔心如何處理這些種類的錯誤。所以我如果遇到錯誤的話，我們採用 <code>unwrap</code> 來停止程式。</p>
<p><code>TcpListener</code> 的 <code>incoming</code> 方法會回傳一個疊代器，給予我們一連串的流（更準確的來說是 <code>TcpStream</code> 型別的流）。一個<strong>流</strong>（Stream）代表的是客戶端與伺服器之間的開啟的連線。而<strong>連線</strong>（connection）指的是整個請求與回應的過程，這之中客戶端會連線至伺服器、伺服器會產生回應，然後伺服器會關閉連線。這樣一來，我們就能讀取 <code>TcpStream</code> 來查看客戶端傳送了什麼，然後將我們的回應寫入流中，將資料傳回給客戶端。整體來說，此 <code>for</code> 迴圈會依序遍歷每個連線，然後產生一系列的流讓我們能夠加以處理。</p>
<p>目前我們處理流的方式包含呼叫 <code>unwrap</code>，這當流有任何錯誤時，就會結束我們的程式。如果沒有任何錯誤的話，程式就會顯示訊息。我們會在下個範例在成功的情況下加入更多功能。當客戶端連接伺服器時，我們可能會從 <code>incoming</code> 方法取得錯誤的原因是因為我們實際上不是在遍歷每個連線。反之，我們是在遍歷<strong>連線嘗試</strong>。連線不成功可能有很多原因，而其中許多都與作業系統有關。舉例來說，許多作業系統都會限制它們能支援的同時連線開啟次數，當新的連線超出此範圍時就會產生錯誤，直到有些連線被關閉為止。</p>
<p>讓我們跑跑看此程式碼吧！在終端機呼叫 <code>cargo run</code> 然後在網頁瀏覽器載入 <em>127.0.0.1:7878</em>。瀏覽器應該會顯示一個像是「Connection reset」之類的錯誤訊息，因為伺服器目前還不會回傳任何資料。但是當你觀察終端機，在瀏覽器連接伺服器時，你應該會看到一些訊息顯示出來！</p>
<pre><code class="language-text">     Running `target/debug/hello`
連線建立！
連線建立！
連線建立！
</code></pre>
<p>有時候你可能從一次瀏覽器請求看到數個訊息顯示出來，原因很可能是因為瀏覽器除了請求頁面內容以外，也嘗試請求其他資源，像是出現在瀏覽器分頁上的 <em>favicon.ico</em> 圖示。</p>
<p>而瀏覽器嘗試多次連線至伺服器的原因還有可能是因為伺服器沒有回傳任何資料。當 <code>stream</code> 離開作用域並在迴圈結尾被釋放時，連線會在 <code>drop</code> 的實作中被關閉。瀏覽器有時處理被關閉的連線的方式是在重試幾次，因為發生的問題可能是暫時的。不管如何，現在最重要的是我們成功取得 TCP 的連線了！</p>
<p>當你執行完特定版本的程式碼後，記得按下 <span class="keystroke">ctrl-c</span> 來停止程式。然後在你變更一些程式碼後重新呼叫 <code>cargo run</code> 來確保你有執行到最新的程式碼。</p>
<h3 id="讀取請求"><a class="header" href="#讀取請求">讀取請求</a></h3>
<p>讓我們來實作讀取瀏覽器請求的功能吧！為了能分開取得連線的方式與處理連線的方式，我們會建立另一個新的函式來處理連線。在此 <code>handle_connection</code> 新的函式中，我們會讀取從 TCP 流取得的資料並顯示出來，讓我們可以觀察瀏覽器傳送的資料。請修改程式碼成範例 20-2。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    println!(&quot;請求：{:#?}&quot;, http_request);
}
</code></pre></pre>
<p><span class="caption">範例 20-2：讀取 <code>TcpStream</code> 並顯示資料</span></p>
<p>我們將 <code>std::io::prelude</code> 和 <code>std::io::BufReader</code> 引入作用域來取得特定的特徵，讓我們可以讀取並寫入流之中。在 <code>main</code> 函式的 <code>for</code> 迴圈中，不同於印出說我們取得連線的訊息，我們現在會呼叫新的 <code>handle_connection</code> 函式並將 <code>stream</code> 傳入。</p>
<p>在 <code>handle_connection</code> 函式中，我們建立 <code>BufReader</code> 的實例並取得 <code>stream</code> 的可變參考。<code>BufReader</code> 提供了緩衝區（buffering），幫助我們管理 <code>std::io::Read</code> 方法的呼叫。</p>
<p>我們建立了一個變數 <code>http_request</code> 來收集瀏覽器傳送到伺服器的每行請求。我們加上 <code>Vec&lt;_&gt;</code> 型別詮釋來指示我們想要將每行收集成向量。</p>
<p><code>BufReader</code> 實作的 <code>std::io::BufRead</code> 特徵有提供個 <code>lines</code> 方法。該方法會回傳個 <code>Result&lt;String, std::io::Error&gt;</code> 的疊代器，這會在每次看到換行（newline）位元組時，將資料流分開。我們用 <code>map </code> 對每個 <code>Result</code> 呼叫 <code>unwrap</code> 來取得 <code>String</code>。如果資料不是有效的 UTF-8 或是讀取流時發生問題的話，<code>Result</code> 可能會產生錯誤。在正式環境的程式應該要適當地處理這些錯誤，但為了簡潔我們在這裡選擇直接在遇到錯誤時就終止程式。</p>
<p>瀏覽器會傳送兩次換行字元來表達 HTTP 的請求結束了，所以要確定我們從流中取得一個請求的話，我們就重複取得行數直到有一行是空字串為止。一但我們將行數收集到向量中，我們就使用好看的除錯格式印出來，讓我們可以觀察瀏覽器傳送了哪些指令給我們的伺服器。</p>
<p>讓我們嘗試看看此程式碼！開啟程式並再次從網頁瀏覽器發送請求。注意到我們仍然會在瀏覽器中取得錯誤頁面，但是我們程式在終端機的輸出應該會類似以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    &quot;GET / HTTP/1.1&quot;,
    &quot;Host: 127.0.0.1:7878&quot;,
    &quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0&quot;,
    &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&quot;,
    &quot;Accept-Language: en-US,en;q=0.5&quot;,
    &quot;Accept-Encoding: gzip, deflate, br&quot;,
    &quot;DNT: 1&quot;,
    &quot;Connection: keep-alive&quot;,
    &quot;Upgrade-Insecure-Requests: 1&quot;,
    &quot;Sec-Fetch-Dest: document&quot;,
    &quot;Sec-Fetch-Mode: navigate&quot;,
    &quot;Sec-Fetch-Site: none&quot;,
    &quot;Sec-Fetch-User: ?1&quot;,
    &quot;Cache-Control: max-age=0&quot;,
]
</code></pre>
<p>依據你的瀏覽器，你可能會看到一些不同的輸出結果。現在我們顯示了請求的資料，我們可以觀察為何瀏覽器會產生多次請求，我們可以看看 <code>Request: GET</code> 之後的路徑。如果重複的連線都在請求 <code>/</code> 的話，我們就能知道瀏覽器在重複嘗試取得 <code>/</code>，因為它沒有從我們的程式取得回應。</p>
<p>讓我們拆開此請求資料來理解瀏覽器在向我們的程式請求什麼。</p>
<h3 id="仔細觀察-http-請求"><a class="header" href="#仔細觀察-http-請求">仔細觀察 HTTP 請求</a></h3>
<p>HTTP 是基於文字的協定，而請求格式如下：</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>第一行是<strong>請求行（request line）<strong>並持有客戶端想請求什麼的資訊。請求行的第一個部分代表著想使用的</strong>方法（method）</strong>，像是 <code>GET</code> 或 <code>POST</code>，這描述了客戶端如何產生此請求。在此例中，我們的客戶端使用的是 <code>GET</code> 請求</p>
<p>請求行的下一個部分是 <code>/</code>，這代表客戶端請求的<strong>統一資源標誌符（Uniform Resource Identifier, URI）</strong>，URI 絕大多數（但不是絕對）就等於<strong>統一資源定位符（Uniform Resource Locator, URL）</strong>。URI 與 URL 的差別對於本章節的學習目的來說並不重要，但是 HTTP 規格使用的術語是 URI，所以我們這裡將 URL 替換為 URI。</p>
<p>最後一個部分是客戶端使用的 HTTP 版本，然後請求行最後以 <strong>CRLF 序列</strong>做結尾，CRLF 指的是<strong>回車（carriage return）與換行（line feed）</strong>，這是打字機時代的術語！CRLF 序列也可以寫成 <code>\r\n</code>，<code>\r</code> 指的是回車，而 <code>\n</code> 指的是換行。CRLF 序列將請求行與剩餘的請求資料區隔開來。注意到當 CRLF 印出時，我們會看到的是新的一行而不是 <code>\r\n</code>。</p>
<p>觀察我們目前從程式中取得的請求行資料，我們看到它使用 <code>GET</code> 方法，<code>/</code>  為請求 URI，然後版本為 <code>HTTP/1.1</code>。</p>
<p>在請求行之後，剩餘從 <code>Host:</code> 開始的行數都是標頭（header）。<code>GET</code> 請求不會有本體（body）。</p>
<p>你可以嘗試看看從不同的瀏覽器或尋問不同的位址，像是 <em>127.0.0.1:7878/test</em>，來看看請求資料有什麼改變。</p>
<p>現在我們知道瀏覽器在請求什麼了，讓我們回傳一些資料吧！</p>
<h3 id="寫入回應"><a class="header" href="#寫入回應">寫入回應</a></h3>
<p>現在我們要實作傳送資料來回應客戶端的請求。回應格式如下：</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>第一行為<strong>狀態行（status line）</strong>，這包含回應使用的 HTTP 版本、用來總結請求結果的狀態碼，以及狀態碼的文字來描述原因。在 CRLF 序列後，會接著任何標頭、另一個 CRLF 序列，然後是回應的本體。</p>
<p>以下是個使用 HTTP 版本 1.1 的回應範例，其狀態碼為 200、文字描述為 OK，沒有標頭與本體：</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>狀態碼 200 是標準的成功回應。這段文字就是小小的 HTTP 成功回應。讓我們將此寫入流中作為我們對成功請求的回應吧！在 <code>handle_connection</code> 函式中，移除原先印出請求資料的 <code>println!</code>，然後換成範例 20-3 的程式碼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-3：寫入一個小小的成功 HTTP 回應至流中</span></p>
<p>新的第一行定義了變數 <code>response</code> 會持有成功訊息的資料。然後我們對我們的 <code>response</code> 呼叫 <code>as_bytes</code> 來將字串轉換成位元組。<code>stream</code> 中的 <code>write_all</code> 方法接收 <code>&amp;[u8]</code> 然後將這些位元組直接傳到連線中。由於 <code>write_all</code> 操作可能會失敗，我們如前面一樣對任何錯誤使用 <code>unwrap</code>。同樣地，在實際的應用程式中你應該要在此加上錯誤處理。</p>
<p>有了這些改變，讓我們執行程式碼然後下達請求。我們不再顯示任何資料到終端機上了，所以我們不會看到任何輸出，只會有 Cargo 執行的訊息。當你在網頁瀏覽器讀取 <em>127.0.0.1:7878</em> 時，你應該會得到一個空白頁面，而不是錯誤了。你剛剛手寫了一個 HTTP 請求與回應！</p>
<h3 id="回傳真正的-html"><a class="header" href="#回傳真正的-html">回傳真正的 HTML</a></h3>
<p>讓我們實作不止是回傳空白頁面的功能。首先在專案根目錄建立一個檔案 <em>hello.html</em>，而不是在 <em>src</em> 目錄內。你可以輸入任何你想要的 HTML，範例 20-4 示範了其中一種可能的範本。</p>
<p><span class="filename">檔案名稱：hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">範例 20-4：用於回應的 HTML 檔案範本</span></p>
<p>這是最小化的 HTML 文件，其附有一個標頭與一些文字。為了要在收到請求後從伺服器回傳此檔案，我們要修改範例 20-5 的 <code>handle_connection</code> 來讀取 HTML 檔案、加進回應本體中然後傳送出去。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// --省略--

<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let http_request: Vec&lt;_&gt; = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    let status_line = &quot;HTTP/1.1 200 OK&quot;;
    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-5：將 <em>hello.html</em> 內容作為回應本體傳送出去</span></p>
<p>我們在 <code>use</code> 新增了 <code>fs</code> 來將標準函式庫中的檔案系統模組引入作用域。讀取檔案內容至字串的程式碼看起來會很熟悉，因為這在第十二章範例 12-4 當我們想在 I/O 專案中讀取檔案內容時就用過了。</p>
<p>接下來，我們使用 <code>format!</code> 來加入檔案內容來作為成功回應的本體。為了確保這是有效的 HTTP 回應，我們加上 <code>Content-Length</code> 標頭並設置為回應本體的大小，在此例中就是 <code>hello.html</code> 的大小。</p>
<p>透過 <code>cargo run</code> 執行此程式碼並在你的瀏覽器讀取 <em>127.0.0.1:7878</em>，你應該就會看到 HTML 的顯示結果了！</p>
<p>目前我們忽略了 <code>http_request</code> 中的請求資料，並毫無條件地回傳 HTML 檔案內容。這意味著如果你嘗試在瀏覽器中請求 <em>127.0.0.1:7878/something-else</em>，你還是會得到相同的 HTML 回應。這樣我們的伺服器是很受限的，而且這也不是大多數網頁伺服器會做的行為。我們想要依據請求自訂我們的回應，並只對格式良好的 <code>/</code> 請求回傳 HTML 檔案。</p>
<h3 id="驗證請求並選擇性地回應"><a class="header" href="#驗證請求並選擇性地回應">驗證請求並選擇性地回應</a></h3>
<p>目前我們的網頁伺服器不管客戶端的請求為何，都會回傳 HTML 檔案。讓我們加個功能來在回傳 HTML 檔案前檢查瀏覽器請求是否為 <code>/</code>，如果瀏覽器請求的是其他的話就回傳錯誤。為此我們得修改 <code>handle_connection</code> 成像是範例 20-6 這樣。此新的程式碼會檢查收到的請求，比較是否符合 <code>/</code> 的前半部分，並增加了 <code>if</code> 與 <code>else</code> 區塊來處理不同請求。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&amp;mut stream);
    let request_line = buf_reader.lines().next().unwrap().unwrap();

    if request_line == &quot;GET / HTTP/1.1&quot; {
        let status_line = &quot;HTTP/1.1 200 OK&quot;;
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    } else {
        // some other request
    }
}
</code></pre></pre>
<p><span class="caption">範例 20-6：分開處理 <code>/</code> 與其他請求</span></p>
<p>我們只會查看 HTTP 請求的第一行，所以與其讀取整個請求到向量中，我們不如呼叫 <code>next</code> 來取得疊代器的第一個項目就好。第一個 <code>unwrap</code> 會處理 <code>Option</code>，如果疊代器沒有任何項目的話程式就會停止。第二個 <code>unwrap</code> 處理的則是 <code>Result</code>，它和範例 20-2 <code>map</code> 裡的 <code>unwrap</code> 有相同的效果。</p>
<p>接著，我們檢查 <code>request_line</code> 是否等同於以 <em>/</em> 路徑形式寫成的 GET 請求。如果是的話，那麼 <code>if</code> 區塊就回傳 HTML 檔案的內容。</p>
<p>如果 <code>request_line</code> <strong>並沒有</strong> 符合在 <em>/</em> 路徑形式下的 GET 請求的話，代表我們收到的是其他請求。我們稍後會在 <code>else</code> 區塊加上回應其他所有請求的程式碼。</p>
<p>執行此程式碼並請求 <em>127.0.0.1:7878</em> 的話，你應該會收到 <em>hello.html</em> 的 HTML。如果你下達其他任何請求，像是 <em>127.0.0.1:7878/something-else</em> 的話，你會和執行範例 20-1 與 20-2 的程式碼時獲得一樣的錯誤。</p>
<p>現在讓我們將範例 20-7 的程式碼加入 <code>else</code> 區塊來回傳狀態碼為 404 的回應，這代表請求的內容無法找到。我們也會回傳一個 HTML 頁面讓瀏覽器能顯示並作為終端使用者的回應。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    if request_line == &quot;GET / HTTP/1.1&quot; {
</span><span class="boring">        let status_line = &quot;HTTP/1.1 200 OK&quot;;
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">        let length = contents.len();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write_all(response.as_bytes()).unwrap();
</span>    // --省略--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();
        let length = contents.len();

        let response = format!(
            &quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;
        );

        stream.write_all(response.as_bytes()).unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 20-7：如果不是 <code>/</code> 的請求就回應狀態碼 404 與一個錯誤頁面</span></p>
<p>我們在此的狀態行有狀態碼 404 與原因描述 <code>NOT FOUND</code>。回應的本體會是 <em>404.html</em> 檔案內的 HTML。你會需要在 <em>hello.html</em> 旁建立一個 <em>404.html</em> 檔案來作為錯誤頁面。同樣地，你可以使用任何你想使用的 HTML 或者使用範例 20-8 的 HTML 範本。</p>
<p><span class="filename">檔案名稱：404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">範例 20-8：回傳任何 404 回應的頁面內容範本</span></p>
<p>有了這些改變後，再次執行你的伺服器。請求 <em>127.0.0.1:7878</em> 的話就應該會回傳 <em>hello.html</em> 的內容，而任何其他請求，像是 <em>127.0.0.1:7878/foo</em> 就應該回傳 <em>404.html</em> 的錯誤頁面。</p>
<h3 id="再做一些重構"><a class="header" href="#再做一些重構">再做一些重構</a></h3>
<p>目前 <code>if</code> 與 <code>else</code> 區塊有很多重複的地方，它們都會讀取檔案並將檔案內容寫入流中。唯一不同的地方在於狀態行與檔案名稱。讓我們將程式碼變得更簡潔，將不同之處分配給 <code>if</code> 與 <code>else</code>，它們會分別將相對應的狀態行與檔案名稱賦值給變數。我們就能使用這些變數無條件地讀取檔案並寫入回應。範例 20-9 顯示了替換大段 <code>if</code> 與 <code>else</code> 區塊後的程式碼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--

fn handle_connection(mut stream: TcpStream) {
    // --省略--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span>
    let (status_line, filename) = if request_line == &quot;GET / HTTP/1.1&quot; {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response =
        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);

    stream.write_all(response.as_bytes()).unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-9：重構 <code>if</code> 與 <code>else</code> 區塊來只包含兩個條件彼此不同的地方</span></p>
<p>現在 <code>if</code> 與 <code>else</code> 區塊只回傳狀態行與檔案名稱的數值至一個元組，我們可以在 <code>let</code> 陳述式使用模式來解構並將分別兩個數值賦值給 <code>status_line</code> 與 <code>filename</code>，如第十八章所提及的。</p>
<p>之前重複的程式碼現在位於 <code>if</code> 與 <code>else</code> 區塊之外並使用變數 <code>status_line</code> 與 <code>filename</code>。這讓我們更容易觀察兩種條件不同的地方，且也意味著如果我們想要變更讀取檔案與寫入回應的行為的話，我們只需要更新其中一段程式碼就好。範例 20-9 與範例 20-8 的程式碼行為一模一樣。</p>
<p>太棒了！我們現在有個用約莫 40 行 Rust 程式碼寫出的簡單網頁瀏覽器，可以對一種請求回應內容頁面，然後對其他所有請求回應 404 錯誤。</p>
<p>目前我們的伺服器只跑在單一執行緒，這意味著它一次只能處理一個請求。讓我們模擬些緩慢的請求來探討這為何會成為問題。然後我們會加以修正讓我們伺服器可以同時處理數個請求。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="將單一執行緒伺服器轉換為多執行緒伺服器"><a class="header" href="#將單一執行緒伺服器轉換為多執行緒伺服器">將單一執行緒伺服器轉換為多執行緒伺服器</a></h2>
<p>現在的伺服器會依序處理請求，代表它處理完第一個連線之前，都無法處理第二個連線。如果伺服器收到越來越多請求，這樣的連續處理方式會變得越來越沒效率。如果伺服器收到一個會花很久時間才能處理完成的請求，之後的請求都得等待這個長時間的請求完成才行，就算新的請求能很快處理完成也是如此。我們需要修正此問題，但首先讓我們先觀察此問題怎麼發生的。</p>
<h3 id="對目前伺服器實作模擬緩慢的請求"><a class="header" href="#對目前伺服器實作模擬緩慢的請求">對目前伺服器實作模擬緩慢的請求</a></h3>
<p>我們來觀察看看處理緩慢的請求如何影響我們目前伺服器實作中的其他請求。範例 20-10 實作了處理 <code>/sleep</code> 的請求，其在回應前讓伺服器沉睡 5 秒鐘來模擬緩慢的回應。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
// --省略--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --省略--

<span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span>    let (status_line, filename) = match &amp;request_line[..] {
        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
            thread::sleep(Duration::from_secs(5));
            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
        }
        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
    };

    // --省略--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">範例 20-10：沉睡 5 秒鐘來模擬緩慢的請求</span></p>
<p>由於我們現在有三種情況了，我們將從 <code>if</code> 改成 <code>match</code>。我們需要用字串字面值數值來配對 <code>request_line</code>。<code>match</code> 不會像相等方法那樣自動參考和解參考。</p>
<p>第一個分支和範例 20-9 的 <code>if</code> 區塊相同。第二個分支配對的請求是 <em>/sleep</em>。當收到請求時，伺服器會在成功顯示 HTML 頁面之前沈睡 5 秒。第三個和範例 20-9 的 <code>else</code> 區塊相同。</p>
<p>你可以看出我們的伺服器有多基本：真實的函式庫會以較不冗長的方式來識別處理數種請求！</p>
<p>使用 <code>cargo run</code> 來啟動伺服器，然後開啟兩個瀏覽器視窗：一個請求 <em>http://127.0.0.1:7878/</em> 然後另一個請求 <em>http://127.0.0.1:7878/sleep</em>。如果你輸入好幾次 <code>/</code> URI 的話，你會如之前一樣迅速地收到回應。但如果你先輸入 <code>/sleep</code> 在讀取 <code>/</code> 的話，你會看到 <code>/</code> 得等待 <code>sleep</code> 沉睡整整 5 秒鐘後才能讀取。</p>
<p>我們有好幾種方式能避免緩慢請求造成的請求堆積。其中一種就是我們要實作的執行緒池（thread pool）。</p>
<h3 id="透過執行緒池改善吞吐量"><a class="header" href="#透過執行緒池改善吞吐量">透過執行緒池改善吞吐量</a></h3>
<p><strong>執行緒池</strong>（thread pool）會產生一群執行緒來等待並隨時準備好處理任務。當程式收到新任務時，它會將此任務分配給執行緒池其中一條執行緒，然後該執行緒就會處理該任務。池中剩餘的執行緒在第一條執行緒處理任務時，仍能隨時處理任何其他來臨的任務。當第一條執行緒處理完成時，他會回到閒置執行緒池之中，等待處理新的任務。執行緒池讓你能並行處理連線，增加伺服器的吞吐量。</p>
<p>我們會限制執行緒池的數量為少量的數量就好，以避免我們造成阻斷服務（Denial of Service,  DOS）攻擊。如果我們的程式每次遇到新的請求時就產生新的執行緒，某個人就可以產生一千萬個請求至我們的伺服器，來破壞並用光我們伺服器的資源，並導致所有請求的處理都被擱置。</p>
<p>所以與其產生無限制的執行緒，我們會有個固定數量的執行緒在池中等待。當有請求來臨時，它們會被送至池中處理。此池會維護一個接收請求的佇列（queue）。每個執行緒會從此佇列彈出一個請求、處理該請求然後再繼續向佇列索取下一個請求。有了此設計，我們就可以同時處理 <code>N</code> 個請求，其中 <code>N</code> 就是執行緒的數量。如果每個執行緒都負責到需要長時間處理的請求，隨後的請求還是會阻塞佇列，但是我們至少增加了能夠同時處理長時間請求的數量。</p>
<p>此技巧只是其中一種改善網頁伺服器吞吐量的方式而已。其他你可能會探索到的選項還有 <strong>fork/join 模型</strong>、<strong>單執行緒非同步模型</strong>或<strong>多執行緒非同步模型</strong>。如果你對此議題有興趣，你可以閱讀其他解決方案，並嘗試實作到 Rust 中。像 Rust 這種低階語言，這些所有選項都是可能的。</p>
<p>在我們開始實作執行緒池之前，讓我們討論一下使用該池會是什麼樣子。當你嘗試設計程式碼時，先寫出使用者的介面能協助引導你的設計。寫出程式碼的 API，使其能以你所期望的方式呼叫，然後在該結構內實作功能，而不是先實作功能再設計公開 API。</p>
<p>類似於第十二章的專案所用到的測試驅動開發（test-driven development），我們會在此使用編譯器驅動開發方式。我們會先寫出呼叫所預期函式的程式碼，然後觀察編譯器的錯誤來決定接下來該改變什麼，才能讓程式碼成功運行。不過在那之前，讓我們先觀察一些我們最後不會使用的方式作為起始點。</p>
<h4 id="對每個請求都產生執行緒"><a class="header" href="#對每個請求都產生執行緒">對每個請求都產生執行緒</a></h4>
<p>首先，讓我們先探討如果我們的程式碼都對每次連線建立新的執行緒會怎樣。如之前提及的，這不會是我們最終的計劃，因為這有可能會產生無限條執行緒的問題，但對於討論多執行緒伺服器來說，這是個很好的起始點。我們接下來會加入執行緒池來改善，然後比較兩者誰比較簡單。範例 20-11 在 <code>main</code> 的 <code>for</code> 迴圈中，對每個流都產生一條新的執行緒。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 20-11：對每個流都產生新的一條執行緒</span></p>
<p>如你在第十六章所學到的，<code>thread::spawn</code> 會建立一條執行緒並在新的執行緒執行閉包的程式碼。如果你執行此程式碼，並在瀏覽器中讀取 <code>/sleep</code>，然後在開兩個瀏覽器分頁來讀取 <code>/</code> 的話，你的確就能看到 <code>/</code> 請求不必等待 <code>/sleep</code> 完成。但如我們所提的，這最終可能會拖累系統，因為你可以無限制地產生新的執行緒。</p>
<h4 id="建立數量有限的執行緒"><a class="header" href="#建立數量有限的執行緒">建立數量有限的執行緒</a></h4>
<p>我們想要我們的執行緒池能以類似的方式運作，這樣從執行緒切換成執行緒池時，使用我們 API 的程式碼就不必作出大量修改。範例 20-12 顯示一個我們想使用的假想 <code>ThreadPool</code> 結構體，而非使用 <code>thread::spawn</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-12：我們理想的 <code>ThreadPool</code> 介面</span></p>
<p>我們使用 <code>ThreadPool::new</code> 來建立新的執行緒池且有個可設置的執行緒數量參數，在此例中設為四。然後在 <code>for</code> 迴圈中，<code>pool.execute</code> 的介面類似於 <code>thread::spawn</code>，其會接收一個執行緒池執行在每個流中的閉包。我們需要實作 <code>pool.execute</code>，使其能接收閉包並傳給池中的執行緒來執行。此程式碼還不能編譯，但是我們接下來能試著讓編譯器引導我們如何修正。</p>
<h4 id="透過編譯器驅動開發建立-threadpool"><a class="header" href="#透過編譯器驅動開發建立-threadpool">透過編譯器驅動開發建立 <code>ThreadPool</code></a></h4>
<p>將範例 20-12 的變更寫入 <em>src/main.rs</em>，然後讓我們從 <code>cargo check</code> 產生的編譯器錯誤來引導我們的開發吧。以下是我們第一個收到的錯誤：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type `ThreadPool`
  --&gt; src/main.rs:11:16
   |
11 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello` due to previous error
</code></pre>
<p>很好！此錯誤告訴我們需要一個 <code>ThreadPool</code> 型別或模組，所以現在就讓我們來建立一個。我們的 <code>ThreadPool</code> 實作會與網頁伺服器相互獨立，所以讓我們將 <code>hello</code> crate 從執行檔 crate 轉換成函式庫 crate 來存放我們的 <code>ThreadPool</code> 實作。這樣在我們切換成函式庫 crate 之後，我們就能夠將分出來的執行緒池函式庫用在其他我們想使用執行緒池的地方，而不僅僅是作為網頁請求所用。</p>
<p>建立一個包含以下內容的 <em>src/lib.rs</em>，這是我們現在所能寫出最簡單的 <code>ThreadPool</code> 結構體定義了：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;
</code></pre>
<p>然後編輯 <em>main.ts</em> 檔案將 <code>ThreadPool</code> 從函式庫 crate 引入作用域，請將以下程式碼寫入 <em>src/main.rs</em> 最上方：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::{
</span><span class="boring">    fs,
</span><span class="boring">    io::{prelude::*, BufReader},
</span><span class="boring">    net::{TcpListener, TcpStream},
</span><span class="boring">    thread,
</span><span class="boring">    time::Duration,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let buf_reader = BufReader::new(&amp;mut stream);
</span><span class="boring">    let request_line = buf_reader.lines().next().unwrap().unwrap();
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = match &amp;request_line[..] {
</span><span class="boring">        &quot;GET / HTTP/1.1&quot; =&gt; (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;),
</span><span class="boring">        &quot;GET /sleep HTTP/1.1&quot; =&gt; {
</span><span class="boring">            thread::sleep(Duration::from_secs(5));
</span><span class="boring">            (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">        }
</span><span class="boring">        _ =&gt; (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">    let length = contents.len();
</span><span class="boring">
</span><span class="boring">    let response =
</span><span class="boring">        format!(&quot;{status_line}\r\nContent-Length: {length}\r\n\r\n{contents}&quot;);
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">}
</span></code></pre>
<p>此程式碼仍然無法執行，讓我們再次檢查並取得下一個要解決的錯誤：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope
  --&gt; src/main.rs:12:28
   |
12 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>此錯誤指示我們需要對 <code>ThreadPool</code> 建立個關聯函式叫做 <code>new</code> 。我們還知道 <code>new</code> 需要有個參數來接受作為引數的 <code>4</code>，並需要回傳 <code>ThreadPool</code> 實例。讓我們來實作擁有這些特性的最簡單 <code>new</code> 函式：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
</code></pre>
<p>我們選擇 <code>usize</code> 作為參數 <code>size</code> 的型別，因為我們知道負數對執行緒數量來說沒有任何意義。我們也知道 4 會作為執行緒集合的元素個數，這正是使用 <code>usize</code> 型別的原因，如同第三章<a href="ch03-02-data-types.html#%E6%95%B4%E6%95%B8%E5%9E%8B%E5%88%A5">「整數型別」</a><!-- ignore -->段落所講的。</p>
<p>讓我們再檢查程式碼一次：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for type `ThreadPool` in the current scope
  --&gt; src/main.rs:17:14
   |
17 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `ThreadPool`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello` due to previous error
</code></pre>
<p>現在錯誤的原因是因為我們的 <code>ThreadPool</code> 沒有 <code>execute</code> 方法。回想一下<a href="ch20-02-multithreaded.html#%E5%BB%BA%E7%AB%8B%E6%95%B8%E9%87%8F%E6%9C%89%E9%99%90%E7%9A%84%E5%9F%B7%E8%A1%8C%E7%B7%92">「建立數量有限的執行緒」</a><!-- ignore -->段落中，我們決定我們的執行緒池要有類似於 <code>thread::spawn</code> 的介面。除此之外，我們會實作 <code>execute</code> 函式使其接收給予的閉包並傳至執行緒池中閒置的執行緒來執行。</p>
<p>我們定義 <code>ThreadPool</code> 的 <code>execute</code> 方法接收一個閉包來作為參數。回憶一下第十三章的<a href="ch13-01-closures.html#fn-%E7%89%B9%E5%BE%B5%E4%BB%A5%E5%8F%8A%E5%B0%87%E7%8D%B2%E5%8F%96%E7%9A%84%E6%95%B8%E5%80%BC%E7%A7%BB%E5%87%BA%E9%96%89%E5%8C%85">「Fn 特徵以及將獲取的數值移出閉包」</a><!-- ignore -->段落中，我們可以透過三種不同的特徵來接受閉包：<code>Fn</code>、<code>FnMut</code> 與 <code>FnOnce</code>。我們需要決定這裡該使用何種閉包。我們知道我們的行為會類似於標準函式庫中 <code>thread::spawn</code> 的實作，所以讓我們看看 <code>thread::spawn</code> 簽名中的參數有哪些界限吧。技術文件會顯示以下結果給我們：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p><code>F</code> 型別參數正是我們所在意的，<code>T</code> 型別則是與回傳型別有關，而我們目前並不在意。我們可以看到 <code>spawn</code> 使用 <code>FnOnce</code> 作為 <code>F</code> 的界限。這大概就是我們也想要的，因為我們最終會將 <code>execute</code> 的引數傳遞給 <code>spawn</code>。我們現在更確信 <code>FnOnce</code> 就是我們想使用的特徵，因為執行請求的執行緒只會執行該請求閉包一次，這正符合 <code>FnOnce</code> 中 <code>Once</code> 的意思。</p>
<p><code>F</code> 型別參數還有個特徵界限 <code>Send</code> 與生命週期界限 <code>'static</code>，這在我們的場合中也很實用，我們需要 <code>Send</code> 來將閉包從一個執行緒轉移到另一個，而會需要 <code>'static</code> 是因為我們不知道執行緒會處理多久。讓我們對 <code>ThreadPool</code> 建立 <code>execute</code> 方法，並採用泛型參數型別 <code>F</code> 與其界限：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --省略--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
</code></pre>
<p>我們在 <code>FnOnce</code> 之後仍然使用 <code>()</code>，因為此 <code>FnOnce</code> 代表閉包沒有任何參數且回傳值為單元型別 <code>()</code>。與函式定義一樣，回傳型別可以在簽名中省略，但是儘管我們沒有任何參數，我們還是得加上括號。</p>
<p>同樣地，這是 <code>execute</code> 方法最簡單的實作，它不會做任何事情，但是我們指示要先讓我們的程式碼能夠編譯通過。讓我們再次檢查：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>編譯通過了！但值得注意的是如果你嘗試 <code>cargo run</code> 並在瀏覽器下請求的話，你會像本章開頭一樣在瀏覽器看到錯誤。我們的函式庫還沒有實際呼叫傳至 <code>execute</code> 的閉包！</p>
<blockquote>
<p>注意：你可能聽過對於像是 Haskell 和 Rust 這種嚴格編譯器的語言，會號稱「如果程式碼能編譯，它就能正確執行。」但這全然是正確的。我們的專案能編譯，但是它沒有做任何事！如果我們在寫的是實際的完整專案，這是個寫單元測試的好時機，這能檢查程式碼能編譯<strong>而且</strong>有我們的預期行為。</p>
</blockquote>
<h4 id="在-new-驗證執行緒數量"><a class="header" href="#在-new-驗證執行緒數量">在 <code>new</code> 驗證執行緒數量</a></h4>
<p>我們對 <code>new</code> 與 <code>execute</code> 的參數沒有做任何事情。讓我們對這些函式本體實作出我們所預期的行為吧。我們先從 <code>new</code> 開始。稍早我們選擇非帶號型別作為 <code>size</code> 的參數，因為負數對於執行緒數量並沒有任何意義。然而，零條執行緒的池一樣也沒有任何意義，但零卻可以是完全合理的 <code>usize</code>。我們要在回傳 <code>ThreadPool</code> 前，加上程式碼來檢查 <code>size</code> 有大於零，並透過 <code>assert!</code> 來判定。如果為零的話就會恐慌，如範例 20-13 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --省略--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 20-13：實作 <code>ThreadPool::new</code> 且如果 <code>size</code> 為零時就會恐慌</span></p>
<p>我們透過技術文件註解來對 <code>ThreadPool</code> 加上技術文件說明。注意到我們有加上一個段落說明何種情況呼叫函式會恐慌，這樣我們就有遵守良好的技術文件典範，如同第十四章所討論過的。嘗試執行 <code>cargo doc --open</code> 然後點擊 <code>ThreadPool</code> 結構體來看看 <code>new</code> 產生出的技術文件長什麼樣子！</p>
<p>除了像我們這樣使用 <code>assert!</code> 巨集之外，我們也可以將 <code>new</code> 改成 <code>build</code> 來回傳 <code>Result</code>，就像範例 12-9 我們對 I/O 專案的 <code>Config::build</code> 所做的一樣。但是我們決定在此情況中，嘗試建立零條執行緒的池應該要是不可回復的錯誤。如果你有信心的話，你可以試著寫出有以下簽名的 <code>build</code> 版本，並比較與 <code>new</code> 函式之間的區別：</p>
<pre><code class="language-rust ignore">pub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4 id="建立執行緒的儲存空間"><a class="header" href="#建立執行緒的儲存空間">建立執行緒的儲存空間</a></h4>
<p>現在我們有一個有效的執行緒數量能儲存至池中，我們可以在回傳實例前，建立這些執行緒並儲存至 <code>ThreadPool</code> 結構體中。但我們要怎麼「儲存」執行緒呢？讓我們再看一次 <code>thread::spawn</code> 的簽名：</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T,
        F: Send + 'static,
        T: Send + 'static,
</code></pre>
<p><code>spawn</code> 函式會回傳 <code>JoinHandle&lt;T&gt;</code>，而 <code>T</code> 為閉包回傳的型別。讓我們也試著使用 <code>JoinHandle</code> 來看看會發生什麼事。在我們的情況中，我們傳遞至執行緒池的閉包會處理連線但不會回傳任何值，所以 <code>T</code> 就會是單元型別 <code>()</code>。</p>
<p>範例 20-14 的程式碼可以編譯，但還不會產生任何執行緒。我們變更了 <code>ThreadPool</code> 的定義來儲存一個有 <code>thread::JoinHandle&lt;()&gt;</code> 實例的向量，用 <code>size</code> 來初始化向量的容量，設置一個會執行些程式碼來建立執行緒的 <code>for</code> 迴圈，然後回傳包含它們的 <code>ThreadPool</code> 實例。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // 就產生些執行緒並儲存至向量
        }

        ThreadPool { threads }
    }

    // --省略--
<span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 20-14：在 <code>ThreadPool</code> 中建立向量來儲存執行緒</span></p>
<p>我們將 <code>std::thread</code> 引入函式庫 crate 中的作用域，因為我們使用 <code>thread::JoinHandle</code> 作為 <code>ThreadPool</code> 中向量的項目型別。</p>
<p>一旦有收到有效大小，<code>ThreadPool</code> 就會建立一個可以儲存 <code>size</code> 個項目的新向量。<code>with_capacity</code> 函式會與 <code>Vec::new</code> 做同樣的事，但是有一個關鍵差別：它會預先分配空間給向量。由於我們知道要儲存 <code>size</code> 個元素至向量中，這樣的分配方式會比 <code>Vec::new</code> 還要些微有效一點，因為後者只會在元素插入時才重新分配自身大小。</p>
<p>當你再次執行 <code>cargo check</code>，這次就能成功編譯。</p>
<h4 id="結構體-worker-負責從-threadpool-傳遞程式碼給一條執行緒"><a class="header" href="#結構體-worker-負責從-threadpool-傳遞程式碼給一條執行緒">結構體 <code>Worker</code> 負責從 <code>ThreadPool</code> 傳遞程式碼給一條執行緒</a></h4>
<p>我們在範例 20-14 的 <code>for</code> 迴圈中留下一個關於建立執行緒的註解。我們在此將看看我們該如何實際建立執行緒。標準函式庫提供 <code>thread::spawn</code> 作為建立執行緒的方式，然後 <code>thread::spawn</code> 預期在執行緒建立時就會獲得一些程式碼讓執行緒能夠執行。但在我們的場合中，我們希望建立執行緒，並讓它們<strong>等待</strong>我們之後會傳送的程式碼。標準函式庫的執行緒實作並不包含這種方式，我們得自己實作。</p>
<p>我們實作此行為的方法是在 <code>ThreadPool</code> 與執行緒間建立一個新的資料結構，這用來管理此新的行為。我們將此資料結構稱為 <code>Worker</code>，這在池實作中是很常見的術語。Worker 拿取要執行的程式碼然後在自己的執行緒跑這段程式碼。想像一下這是有一群人在餐廳廚房內工作：工作者（worker）會等待顧客的訂單，然後他們負責接受這些訂單並完成它們。</p>
<p>所以與其在執行緒池中儲存 <code>JoinHandle&lt;()&gt;</code> 實例的向量，我們可以儲存 <code>Worker</code> 結構體的實例。每個 <code>Worker</code> 會儲存一個 <code>JoinHandle&lt;()&gt;</code> 實例。然後對 <code>Worker</code> 實作一個方法來取得閉包要執行的程式碼，並傳入已經在執行的執行緒來處理。我們也會給每個 <code>Worker</code> 一個 <code>id</code>，好讓我們在紀錄日誌或除錯時，分辨池中不同的工作者。</p>
<p>當我們建立 <code>ThreadPool</code> 時會發生以下事情。我們會用以下方式在設置完 <code>Worker</code> 後，實作將閉包傳遞給執行緒的程式碼：</p>
<ol>
<li>定義 <code>Worker</code> 結構體存有 <code>id</code> 與 <code>JoinHandle&lt;()&gt;</code>。</li>
<li>變更 <code>ThreadPool</code> 改儲存 <code>Worker</code> 實例的向量。</li>
<li>定義 <code>Worker::new</code> 函式來接收 <code>id</code> 數字並回傳一個 <code>Worker</code> 實例，其包含該 <code>id</code> 與一條具有空閉包的執行緒。</li>
<li>在 <code>ThreadPool::new</code> 中，使用 <code>for</code> 迴圈計數來產生 <code>id</code>，以此建立對應 <code>id</code> 的新 <code>Worker</code>，並將其儲存至向量中。</li>
</ol>
<p>如果你想要挑戰看看的話，你可以試著先自己實作這些改變，再來查看範例 20-15 的程式碼。</p>
<p>準備好了嗎？以下是範例 20-15 作出修改的方式。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --省略--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-15：變更 <code>ThreadPool</code> 來儲存 <code>Worker</code> 實例，而非直接儲存執行緒</span></p>
<p>我們將 <code>ThreadPool</code> 中欄位的名稱從 <code>threads</code> 改為 <code>workers</code>，因為它現在啊儲存的是 <code>Worker</code> 實例而非 <code>JoinHandle&lt;()&gt;</code> 實例。我們使用 <code>for</code> 迴圈的計數作為 <code>Worker::new</code> 的引數，然後我們將每個新的  <code>Worker</code> 儲存到名稱為 <code>workers</code> 的向量中。</p>
<p>外部的程式碼（像是我們在 <em>src/main.rs</em> 的伺服器）不需要知道 <code>ThreadPool</code> 內部實作細節已經改為使用 <code>Worker</code> 結構體，所以我們讓 <code>Worker</code> 結構體與其 <code>new</code> 函式維持私有。<code>Worker::new</code> 函式會使用我們給予的 <code>id</code> 並儲存一個 <code>JoinHandle&lt;()&gt;</code> 實例，這是用空閉包產生的新執行緒所建立的。</p>
<blockquote>
<p>注意：如果作業系統因為系統資源不足，而無法建立執行緒的話，<code>thread::spawn</code> 會恐慌。這會使我們的伺服器恐慌，就算有些執行緒能成功建立。基於簡潔原則，這段程式碼還算能接受。但如果是正式環境的執行緒實作，你可能會想使用 <a href="https://doc.rust-lang.org/std/thread/struct.Builder.html"><code>std::thread::Builder</code></a><!-- ignore --> 與其 <a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn"><code>spawn</code></a><!-- ignore --> 方法來回傳 <code>Result</code>。</p>
</blockquote>
<p>此程式碼會編譯通過並透過 <code>ThreadPool::new</code> 的指定引數儲存一定數量的 <code>Worker</code> 實例。但我們<strong>仍然</strong>沒有處理 <code>execute</code>中取得的閉包。讓我們看看接下來怎麼做。</p>
<h4 id="透過通道傳遞請求給執行緒"><a class="header" href="#透過通道傳遞請求給執行緒">透過通道傳遞請求給執行緒</a></h4>
<p>接下來我們要來處理的問題是 <code>thread::spawn</code> 中的閉包不會做任何事情。目前我們透過 <code>execute</code> 取得我們想執行的閉包。但是我們當在 <code>ThreadPool</code> 的生成中建立每個 <code>Worker</code> 時，我會需要給 <code>thread::spawn</code> 一個閉包來執行。</p>
<p>我們想要我們建立的 <code>Worker</code> 結構體能夠從 <code>ThreadPool</code> 中的佇列提取程式碼來執行，並將該程式碼傳至自身的執行緒來執行。</p>
<p>我們在第十六章中學過的<strong>通道</strong>（channels）是個能在兩個執行緒間溝通的好辦法，這對我們的專案來說可說是絕佳解法。我們會用通道來作為任務佇列，然後 <code>execute</code> 來傳送從 <code>ThreadPool</code> 一份任務至 <code>Worker</code> 實例，其就會傳遞該任務給自身的執行緒。以下是我們的計劃：</p>
<ol>
<li><code>ThreadPool</code> 會建立通道並儲存發送者。</li>
<li>每個 <code>Worker</code> 會持有接收者。</li>
<li>我們會建立一個新的結構體 <code>Job</code> 來儲存我們想傳入通道的閉包。</li>
<li><code>execute</code> 方法將會傳送其想執行的 <code>Job</code> 至發送者。</li>
<li>在其執行緒中，<code>Worker</code> 會持續遍歷接收者並執行它所收到的任何任務閉包。</li>
</ol>
<p>讓我們先在 <code>ThreadPool::new</code> 建立通道並讓 <code>ThreadPool</code> 實例儲存發送者，如範例 20-16 所示。現在結構體 <code>Job</code> 還不會儲存任何東西，但是它最終會是我們傳送給通道的型別。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">// --省略--
use std::{sync::mpsc, thread};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --省略--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-16：變更 <code>ThreadPool</code> 來儲存發送者以傳送 <code>Job</code> 實例</span></p>
<p>在 <code>ThreadPool::new</code> 中，我們建立了一個新的通道並讓執行緒池儲存發送者。這能成功編譯，但還是會有些警告。</p>
<p>讓我們嘗試在執行緒池建立通道時，將接收者傳給每個 <code>Worker</code>。我們知道我們想在 <code>Worker</code> 產生的執行緒中使用接收者，所以我們得在閉包中參考 <code>receiver</code> 參數。不過範例 20-17 的程式碼還不能編譯過。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{sync::mpsc, thread};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --省略--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --省略--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-17：傳遞接收者給每個工作者</span></p>
<p>我們做了一些小小卻直觀的改變：我們將接收者傳給 <code>Worker::new</code>，然後我們在閉包中使用它。</p>
<p>當我們檢查此程式碼時，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:26:42
   |
21 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
26 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello` due to previous error
</code></pre>
<p>程式碼嘗試將 <code>receiver</code> 傳給數個 <code>Worker</code> 實例。回憶第十六章的話，你就知道這不會成功：Rust 提供的通道實作是多重<strong>生產者</strong>、單一<strong>消費者</strong>。這意味著我們不能只是克隆接收者來修正此程式碼。我們也不想重複傳送一個訊息給多重消費者，我們想要的是由數個工作者建立的訊息列表，然後每個訊息只會被處理一次。</p>
<p>除此之外，從通道佇列取得任務會需要可變的 <code>receiver</code>，所以執行緒需要有個安全的方式來共享並修改 <code>receiver</code>。不然的話，我們可能會遇到競爭條件（如第十六章所提及的）。</p>
<p>回想一下第十六章討論到的執行緒安全智慧指標：要在多重執行緒共享所有權並允許執行緒改變數值的話，我們需要使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>。<code>Arc</code> 型別能讓數個工作者能擁有接收端，而 <code>Mutex</code> 能確保同時間只有一個工作者能獲取任務。範例 20-18 顯示了我們需要作出的改變：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};
// --省略--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --省略--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --省略--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --省略--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}
</code></pre>
<p><span class="caption">範例 20-18：透過 <code>Arc</code> 與<code>Mutex</code> 來在工作者間共享接收者</span></p>
<p>在 <code>ThreadPool::new</code> 中，我們將接收者放入 <code>Arc</code> 與 <code>Mutex</code> 之中。對於每個新的工作者，我們會克隆 <code>Arc</code> 來增加參考計數，讓工作者可以共享接收者的所有權。</p>
<p>有了這些改變，程式碼就能編譯了！我們就快完成了！</p>
<h4 id="實作-execute-方法"><a class="header" href="#實作-execute-方法">實作 <code>execute</code> 方法</a></h4>
<p>最後讓我們來對 <code>ThreadPool</code> 實作 <code>execute</code> 方法吧。我們還會將 <code>Job</code> 的型別從結構體改為特徵物件的型別別名，這會儲存 <code>execute</code> 收到的閉包型別。如同在第十九章的<a href="ch19-03-advanced-types.html#%E9%80%8F%E9%81%8E%E5%9E%8B%E5%88%A5%E5%88%A5%E5%90%8D%E5%BB%BA%E7%AB%8B%E5%9E%8B%E5%88%A5%E5%90%8C%E7%BE%A9%E8%A9%9E">「透過型別別名建立型別同義詞」</a><!-- ignore -->段落所介紹的，型別別名讓我們能將很長的型別變短一些以便使用，如範例 20-19 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --省略--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --省略--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-19：建立一個對 <code>Box</code> 的型別別名 <code>Job</code>，其存有每個閉包並傳送至通道</span></p>
<p>在使用 <code>execute</code> 收到的閉包來建立新的 <code>Job</code> 實例之後，我們將該任務傳送至發送者。我們對 <code>send</code> 呼叫 <code>unwrap</code> 來處理發送失敗的情況。舉例來說，這可能會發生在當我們停止所有執行緒時，這意味著接收端不再接收新的訊息。不過目前我們還無法讓我們的執行緒停止執行，只要執行緒池還在我們的執行緒就會繼續執行。我們使用 <code>unwrap</code> 的原因是因為我們知道失敗不可能發生，但編譯器並不知情。</p>
<p>不過我們還沒結束呢！在工作者中，傳給 <code>thread::spawn</code> 的閉包仍然只有<strong>參考</strong>接收者。我們需要讓閉包一直循環，向接收者請求任務，並在取得任務時執行它。讓我們對 <code>Worker::new</code> 加上範例 20-20 的程式碼。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --省略--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {id} got a job; executing.&quot;);

            job();
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-20：在工作者的執行緒中接收並執行任務</span></p>
<p>我們在此首先對 <code>receiver</code> 呼叫 <code>lock</code> 以取得互斥鎖，然後我們呼叫 <code>unwrap</code> 讓任何錯誤都會恐慌。如果互斥鎖處於<strong>污染</strong>（poisoned）狀態的話，該鎖可能就會失敗，這在其他執行緒持有鎖時，卻發生恐慌而沒有釋放鎖的話就可能發生。在這種情形，呼叫 <code>unwrap</code> 來讓此執行緒恐慌是正確的選擇。你也可以將 <code>unwrap</code> 改成 <code>expect</code> 來加上一些對你更有幫助的錯誤訊息。</p>
<p>如果我們得到互斥鎖的話，我們呼叫 <code>recv</code> 來從通道中取得 <code>Job</code>。最後的 <code>unwrap</code> 也繞過了任何錯誤，這在持有發送者的執行緒被關閉時就可能發生；就和如果接收端關閉時 <code>send</code> 方法就會回傳 <code>Err</code> 的情況類似。</p>
<p><code>recv</code> 的呼叫會阻擋執行緒，所以如果沒有任何任務的話，當前執行緒對等待直到下一個任務出現為止。<code>Mutex&lt;T&gt;</code> 確保同時間只會有一個 <code>Worker</code> 執行緒嘗試取得任務。</p>
<p>我們的執行緒池終於可以運作了！賞它個 <code>cargo run</code> 然後下達一些請求吧：</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `hello` (lib) generated 3 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>成功了！我們現在有個執行緒池能非同步地處理連線。我們產生的執行緒不超過四條，所以如果伺服器收到大量請求時，我們的系統就不會超載。如果我們下達 <code>/sleep</code> 的請求，伺服器會有其他執行緒來處理其他請求並執行它們。</p>
<blockquote>
<p>注意：如果你在數個瀏覽器視窗同時打開 <code>/sleep</code>，它們可能會彼此間格 5 秒鐘來讀取。這是因為有些網頁瀏覽器會對多個相同請求的實例做快取。這項限制不是網頁伺服器造成的。</p>
</blockquote>
<p>在學習過第十八章的 <code>while let</code> 迴圈後，你可能會好奇為何我們不像範例 20-21 這樣來寫工作者執行緒的程式碼。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --省略--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {id} got a job; executing.&quot;);

                job();
            }
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-21：使用 <code>while let</code> 來實作 <code>Worker::new</code> 的替代方案</span></p>
<p>此程式碼能編譯並執行，但不會是有我們預期的執行緒行為：緩慢的請求仍然會卡住其他請求。發生的原因有點微妙，<code>Mutex</code> 結構體沒有公開的 <code>unlock</code> 方法，這是因為鎖的所有權是依據 <code>lock</code> 方法所回傳的 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> 中 <code>MutexGuard&lt;T&gt;</code> 的生命週期。在編譯時借用檢查器可以以此確保沒有持有鎖的話，我們就無法取得 <code>Mutex</code> 守護的資源。不過沒有仔細思考 <code>MutexGuard&lt;T&gt;</code> 的生命週期的話，此實作可能就會導致持有鎖的時間比預期的更久。</p>
<p>在範例 20-20 程式碼中的 <code>let job = receiver.lock().unwrap().recv().unwrap();</code> 可以這樣寫的原因是因爲用的是 <code>let</code>，等號右方任何表達式中的暫時數值都會在 <code>let</code> 陳述式結束時釋放。然而 <code>while let</code> （還有 <code>if let</code> 和 <code>match</code>）是不會釋放暫時數值的，直到其區塊結束爲止。在範例 20-21 中，在呼叫 <code>job</code> 的這段期間內，鎖都會持續鎖著，代表其他工作者無法取得工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="正常關機與清理"><a class="header" href="#正常關機與清理">正常關機與清理</a></h2>
<p>範例 20-20 的程式碼能如我們所預期地使用執行緒池來同時回應多重請求。我們有看到些警告說 <code>workers</code>、<code>id</code> 與 <code>thread</code> 欄位沒有被直接使用，這提醒我們尚未清理所有內容。當我們使用比較不優雅的 <span class="keystroke">ctrl-c</span> 方式來中斷主執行緒時，所有其他執行緒也會立即停止，不管它們是否正在處理請求。</p>
<p>接著我們要實作 <code>Drop</code> 特徵來對池中的每個執行緒呼叫 <code>join</code>，讓它們能在關閉前把任務處理完畢。然後我們要實作個方式來告訴執行緒它們該停止接收新的請求並關閉。為了觀察此程式碼的實際運作，我們會修改伺服器讓它在正常關機（graceful shutdown）前，只接收兩個請求。</p>
<h3 id="對-threadpool-實作-drop-特徵"><a class="header" href="#對-threadpool-實作-drop-特徵">對 <code>ThreadPool</code> 實作 <code>Drop</code> 特徵</a></h3>
<p>讓我們先對執行緒池實作 <code>Drop</code> 。當池被釋放時，我們的執行緒都該加入（join）回來以確保它們有完成它們的工作。範例 20-22 為實作 <code>Drop</code> 的第一次嘗試，不過此程式碼還無法執行。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-22：在執行緒池離開作用域將每個執行緒加入回來</span></p>
<p>首先，我們遍歷執行緒池中的每個 <code>workers</code>。我們對此使用 <code>&amp;mut</code> 因為 <code>self</code> 是個可變參考，而且我們也需要能夠改變 <code>worker</code>。我們對每個工作者印出訊息來說明此工作者正要關閉，然後我們對工作者的執行緒呼叫 <code>join</code>。如果 <code>join</code> 的呼叫失敗的話，我們使用 <code>unwrap</code> 來讓 Rust 恐慌使其變成較不正常的關機方式。</p>
<p>以下是當我們編譯此程式碼時產生的錯誤：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call
   |             |
   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait
   |
note: this function takes ownership of the receiver `self`, which moves `worker.thread`

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello` due to previous error
</code></pre>
<p>錯誤告訴我們無法呼叫 <code>join</code>，因為我們只有每個 <code>worker</code> 的可變借用，而 <code>join</code> 會取走其引數的所有權。要解決此問題，我們需要將 <code>thread</code> 中的執行緒移出 <code>Worker</code> 實例，讓 <code>join</code> 可以消耗該執行緒。我們在範例 17-15 做過這樣的事，如果 <code>Worker</code> 改持有 <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> 的話，我們可以對 <code>Option</code> 呼叫 <code>take</code> 方法來移動 <code>Some</code> 變體中的數值，並在原處留下 <code>None</code> 變體。換句話說，<code>thread</code> 中有 <code>Some</code> 變體的話就代表 <code>Worker</code> 正在執行，而當我們清理 <code>Worker</code> 時，我們會將 <code>Some</code> 換成 <code>None</code> 來讓 <code>Worker</code> 沒有任何執行緒可以執行。</p>
<p>所以我們想要更新 <code>Worker</code> 的定義如以下所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>現在讓我們再看看編譯器的結果中還有哪些地方需要修改。檢查此程式碼，我們會得到兩個錯誤：</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for enum `Option` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`
   |
note: the method `join` exists on the type `JoinHandle&lt;()&gt;`
help: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`
   |
52 |             worker.thread.expect(&quot;REASON&quot;).join().unwrap();
   |                          +++++++++++++++++

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`
   |
   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`
            found struct `JoinHandle&lt;_&gt;`
help: try wrapping the expression in `Some`
   |
72 |         Worker { id, thread: Some(thread) }
   |                      +++++++++++++      +

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello` due to 2 previous errors
</code></pre>
<p>讓我們來修復第二個錯誤，這指向程式碼中 <code>Worker::new</code> 的結尾。當我們建立新的 <code>Worker</code>，我們需要將 <code>thread</code> 的數值封裝到 <code>Some</code>。請作出以下改變來修正程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --省略--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>而第一個錯誤則位在 <code>Drop</code> 的實作中。我們剛剛有提到我們打算對 <code>Option</code> 呼叫 <code>take</code> 來將 <code>thread</code> 移出 <code>worker</code>。所以以下改變就能修正：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>如同第十七章所討論的，<code>Option</code> 的 <code>take</code> 方法會取走 <code>Some</code> 變體的數值並在原地留下 <code>None</code>。我們使用 <code>if let</code> 來解構 <code>Some</code> 並取得執行緒，然後我們對執行緒呼叫 <code>join</code>。如果工作者的執行緒已經是 <code>None</code>，我們就知道該該工作者已經清理其執行緒了，所以沒有必要再處理。</p>
<h3 id="對執行緒發送停止接收任務的信號"><a class="header" href="#對執行緒發送停止接收任務的信號">對執行緒發送停止接收任務的信號</a></h3>
<p>有了以上的改變，我們的程式碼就能成功編譯且沒有任何警告。但壞消息是此程式碼並沒有如我們所預期地運作。關鍵邏輯位於 <code>Worker</code> 實例中執行緒執行的閉包，現在雖然我們有呼叫 <code>join</code>，但這無法關閉執行緒，因為它們會一直 <code>loop</code> 來尋找任務執行。如果我們嘗試以目前的 <code>drop</code> 實作釋放 <code>ThreadPool</code> 的話，主執行緒會被阻擋，一直等待第一個執行緒處理完成。</p>
<p>要修正此問題，我們要修改 <code>ThreadPool</code> <code>drop</code> 的實作以及 <code>Worker</code> 內的一些程式碼。</p>
<p>首先我們先將 <code>ThreadPool</code> <code>drop</code> 的實作改成在執行緒完成前就顯式釋放 <code>sender</code>。範例 20-23 展示了 <code>ThreadPool</code> 顯式釋放 <code>sender</code>。我們使用處理執行緒時一樣的 <code>Option</code> 與 <code>take</code> 技巧來將 <code>sender</code> 移出 <code>ThreadPool</code>：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore noplayground not_desired_behavior"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}
// --省略--
<span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>impl ThreadPool {
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        // --省略--

<span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span>        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {id} got a job; executing.&quot;);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-23：在工作者執行緒加入回來前顯式釋放 <code>sender</code></span></p>
<p>釋放 <code>sender</code> 會關閉通道，也就代表沒有任何訊息會再被傳送。工作者在無限迴圈呼叫的 <code>recv</code> 會回傳錯誤。在範例 20-24 中，我們改變 <code>Worker</code> 的迴圈來處理該狀況並正常退出迴圈，也就是說 <code>ThreadPool</code> <code>drop</code> 的實作呼叫 <code>join</code> 時，執行緒就會工作完成。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore noplayground"><span class="boring">use std::{
</span><span class="boring">    sync::{mpsc, Arc, Mutex},
</span><span class="boring">    thread,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool {
</span><span class="boring">            workers,
</span><span class="boring">            sender: Some(sender),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.as_ref().unwrap().send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        drop(self.sender.take());
</span><span class="boring">
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">範例 20-24：當 <code>recv</code> 回傳錯誤時就顯式退出迴圈</span></p>
<p>要實際看到此程式碼的運作情形，讓我們修改 <code>main</code> 來在正常關閉伺服器前，只接收兩個請求，如範例 20-25 所示。</p>
<p><span class="filename">檔案名稱：src/bin/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(
</span><span class="boring">        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">        status_line,
</span><span class="boring">        contents.len(),
</span><span class="boring">        contents
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    stream.write_all(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-25：在處理兩個請求後，離開迴圈並關閉伺服器</span></p>
<p>在真實世界中的網頁伺服器當然不會只處理兩個請求就關機。此程式碼只是用來說明正常關機與清理的運作流程。</p>
<p><code>take</code> 方法是由 <code>Iterator</code> 特徵所定義且我們限制該疊代最多只會取得前兩項。<code>ThreadPool</code> 會在 <code>main</code> 結束時離開作用域，然後 <code>drop</code> 的實作就會執行。</p>
<p>使用 <code>cargo run</code> 開啟伺服器，並下達三個請求。第三個請求應該會出現錯誤，而在你的終端機中你應該會看到類似以下的輸出：</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Shutting down.
Shutting down worker 0
Worker 3 got a job; executing.
Worker 1 disconnected; shutting down.
Worker 2 disconnected; shutting down.
Worker 3 disconnected; shutting down.
Worker 0 disconnected; shutting down.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>你可能會看到不同順序的工作者與訊息輸出。我們可以從訊息中看到此程式碼如何執行的，工作者 0 與 3 獲得前兩個請求。在第二個請求之後，伺服器會停止接受連線。然後在工作者 3 開始工作之前，<code>ThreadPool</code> 的 <code>Drop</code> 實作就會執行。釋放 <code>sender</code> 會將所有工作者斷線並告訴它們關閉。每個工作者在斷線時都印出訊息，然後執行緒池會呼叫 <code>join</code> 來等待每個工作者的執行緒完成。</p>
<p>此特定執行方式中有個有趣的地方值得注意：在 <code>ThreadPool</code> 釋放 <code>sender</code> 然後任何工作者收到錯誤之前，我們嘗試將工作者 0 加入回來。工作者 0 尚未從 <code>recv</code> 收到錯誤，所以主執行緒會被擋住並等待工作者 0 完成。同一時間，工作者 3 收到一份工作但所有執行緒都收到錯誤。當工作者 0 完成時，主執行緒會等待剩下的工作者完成任務。屆時，它們都會退出它們的迴圈並能夠關閉。</p>
<p>恭喜！我們的專案完成了，我們有個基礎的網頁瀏覽器，其使用執行緒池來做非同步回應。我們能夠對伺服器正常關機，並清理池中所有的執行緒。</p>
<p>以下是完整的程式碼參考：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(
        &quot;{}\r\nContent-Length: {}\r\n\r\n{}&quot;,
        status_line,
        contents.len(),
        contents
    );

    stream.write_all(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust noplayground">use std::{
    sync::{mpsc, Arc, Mutex},
    thread,
};

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender: Some(sender),
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        drop(self.sender.take());

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) =&gt; {
                    println!(&quot;Worker {id} got a job; executing.&quot;);

                    job();
                }
                Err(_) =&gt; {
                    println!(&quot;Worker {id} disconnected; shutting down.&quot;);
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>我們還可以做更多事！如果你想繼續改善此專案的話，以下是些不錯的點子：</p>
<ul>
<li>對 <code>ThreadPool</code> 與其公開方法加上技術文件。</li>
<li>對函式庫功能加上測試。</li>
<li>將 <code>unwrap</code> 的呼叫改成更完善的錯誤處理。</li>
<li>使用 <code>ThreadPool</code> 來處理其他種類的任務，而不只是網頁請求。</li>
<li>在 <a href="https://crates.io/">crates.io</a> 找到一個執行緒池 crate，並使用該 crate 實作類似的網頁伺服器。然後比較該 crate 與我們實作的執行緒池之間的 API 與穩固程度。</li>
</ul>
<h2 id="總結-19"><a class="header" href="#總結-19">總結</a></h2>
<p>做得好！你已經讀完整本書了！我們由衷感謝你一同加入 Rust 的旅途。現在你已經準備好實作你自己的 Rust 專案並協助其他人的專案。別忘了我們有個友善的社群，其他 Rustaceans 會很樂意幫助你一同面對 Rust 旅途中的任何挑戰。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附錄"><a class="header" href="#附錄">附錄</a></h1>
<p>以下段落包含你可能會在你的 Rust 旅途中覺得有用的參考資源。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-a關鍵字"><a class="header" href="#附錄-a關鍵字">附錄 A：關鍵字</a></h2>
<p>以下列表包含 Rust 目前或未來會使用到而保留起來的關鍵字。這意味著它們不能作為標識符使用（不過等等會提到的「<a href="appendix-01-keywords.html#%E5%8E%9F%E5%A7%8B%E6%A8%99%E8%AD%98%E7%AC%A6">原始標識符</a><!-- ignore -->」除外），標識符包含函式、變數、參數、結構體欄位、模組、crates、常數、巨集、靜態數值、屬性、型別、特徵與生命週期的名稱。</p>
<h3 id="目前有在使用的關鍵字"><a class="header" href="#目前有在使用的關鍵字">目前有在使用的關鍵字</a></h3>
<p>以下為目前的關鍵字列表與其對應的功能描述。</p>
<ul>
<li><code>as</code> - 進行原始型別轉換、消除包含項目的特定特徵之歧異，或重新命名 <code>use</code> 陳述式內的項目</li>
<li><code>async</code> -  回傳 <code>Future</code> 而非阻擋目前執行緒</li>
<li><code>await</code> - 暫停執行直到 <code>Future</code> 的結果已經準備好</li>
<li><code>break</code> - 立即離開迴圈</li>
<li><code>const</code> - 定義常數項目或常數裸指標</li>
<li><code>continue</code> - 繼續進入下一次迴圈疊代</li>
<li><code>crate</code> - 在模組路徑中，指的是 crate 的源頭</li>
<li><code>dyn</code> - 對特徵物件的動態分配</li>
<li><code>else</code> - <code>if</code> 與 <code>if let</code> 控制流結構的例外選項</li>
<li><code>enum</code> - 定義枚舉</li>
<li><code>extern</code> - 連結外部函式或變數</li>
<li><code>false</code> - 布林字面值 false</li>
<li><code>fn</code> - 定義函式或函式指標型別</li>
<li><code>for</code> - 從疊代器遍歷項目、實作特徵，或指定高階生命週期（higher-ranked lifetime）</li>
<li><code>if</code> - 依據條件表達式的分支</li>
<li><code>impl</code> - 實作本身或特徵的功能</li>
<li><code>in</code> - <code>for</code> 迴圈語法的其中一部分</li>
<li><code>let</code> - 綁定變數</li>
<li><code>loop</code> - 無條件的迴圈</li>
<li><code>match</code> - 將數值配對到模式</li>
<li><code>mod</code> - 定義模組</li>
<li><code>move</code> - 讓閉包取得其所有捕獲的所有權</li>
<li><code>mut</code> - 表示參考、裸指標或模式綁定具有可變性</li>
<li><code>pub</code> - 表示結構欄位、<code>impl</code> 區塊或模組對外公開</li>
<li><code>ref</code> - 綁定參考</li>
<li><code>return</code> - 函式的回傳</li>
<li><code>Self</code> - 我們正在定義或實作型別的型別別名</li>
<li><code>self</code> - 方法本體或當前模組</li>
<li><code>static</code> - 全域變數或存在於整個程式執行期間的生命週期</li>
<li><code>struct</code> - 定義結構體</li>
<li><code>super</code> - 當前模組的上層模組</li>
<li><code>trait</code> - 定義特徵</li>
<li><code>true</code> - 布林字面值 true</li>
<li><code>type</code> - 定義型別別名或關聯型別</li>
<li><code>union</code> - 定義聯集 <a href="https://doc.rust-lang.org/reference/items/unions.html">union</a><!-- ignore -->; 只作為宣告聯集時的關鍵字</li>
<li><code>unsafe</code> - 表示不安全的程式碼、函式、特徵或實作</li>
<li><code>use</code> - 將符號引入作用域</li>
<li><code>where</code> - 表示約束該型別用的子句</li>
<li><code>while</code> - 依據表達式結果的條件迴圈</li>
</ul>
<h3 id="未來可能會使用而保留的關鍵字"><a class="header" href="#未來可能會使用而保留的關鍵字">未來可能會使用而保留的關鍵字</a></h3>
<p>以下關鍵字沒有任何功能但是 Rust 可能會在未來使用到所以作為保留：</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3 id="原始標識符"><a class="header" href="#原始標識符">原始標識符</a></h3>
<p>*原始標識（Raw identifiers）*是個能讓你使用正常情況下不允許使用的關鍵字的語法。你能夠過加上 <code>r#</code> 關鍵字前綴來使用原始標識符。</p>
<p>舉例來說，<code>match</code> 是個關鍵字。如果你嘗試編譯以下使用 <code>match</code> 作為名稱的函式的話：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>你會獲得此錯誤：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>錯誤表示你不能使用關鍵字 <code>match</code> 作為函式標識符。要使用 <code>match</code> 作為函式名稱的話，你可以使用原始標識符語法，如以下所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>此程式碼就能夠編譯並沒有任何錯誤。注意到 <code>r#</code> 前綴會用於函式定義的名稱以及在 <code>main</code> 呼叫該函式的地方。</p>
<p>原始標識符能讓你使用任何字作為標識符，就算該字剛好是保留的關鍵字。這給了我們更多選擇標識符名稱的自由，以及讓我們與以這些單詞不是關鍵詞的語言編寫的程式進行整合。除此之外，原始標識符讓你可以使用與你 crate 的 Rust 版號（edition）不相同的函式庫。舉例來說 <code>try</code> 在 2015 版號還不是關鍵字，但到 2018 版號才加入。如果你依賴一個使用 2015 版號的函式庫，且其中有個 <code>try</code> 函式，你就需要使用原始標識符語法。在此例中就是在你 2018 版號的程式碼用 <code>r#try</code> 來呼叫該函式。請查閱<a href="appendix-05-editions.html">附錄 E</a><!-- ignore -->以瞭解關於版號的更多資訊。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-b運算子與符號"><a class="header" href="#附錄-b運算子與符號">附錄 B：運算子與符號</a></h2>
<p>此附錄包含 Rust 語法的詞彙表，包含運算子以及其他符號，這些符號會單獨出現或出現在路徑、泛型、特徵界限、巨集、屬性、註解、元組與大括號中。</p>
<h3 id="運算子"><a class="header" href="#運算子">運算子</a></h3>
<p>表 B-1 包含 Rust 中的運算子、運算子如何出現的範例、簡單解釋以及該運算子是否能超載（overloadable）。如果一個運算子可以超載，用來超載該運算子對應的特徵會列出來。</p>
<p><span class="caption">表 B-1：運算子</span></p>
<div class="table-wrapper"><table><thead><tr><th>運算子</th><th>範例</th><th>解釋</th><th>能否超載？</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>巨集表達式</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>位元運算（Bitwise）或邏輯運算補數（logical complement）</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>expr != expr</code></td><td>不相等比較</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>算數餘數</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>算數餘數並賦值</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>借用</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>借用指標型別</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>位元運算 AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>位元運算 AND 並賦值</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>邏輯運算 AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>算數乘法</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>算數乘法並賦值</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>解參考</td><td><code>Deref</code></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>裸指標</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>複合型別約束</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>算數加法</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>算數加法並賦值</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>引數與元素分隔符</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>算數負數</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>算數減法</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>算數減法並賦值</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>函式與閉包回傳型別</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>成員存取</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>右排除範圍</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>右包含範圍</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>結構體更新語法</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>「與剩餘部分」模式綁定</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>（已棄用，請改用 <code>..=</code>）模式：包含範圍模式</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>算數除法</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>算數除法並賦值</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>約束</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>結構體欄位初始化</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>迴圈標籤</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>陳述式與項目結束符</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>固定大小陣列語法的其中一部分</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>左移</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>左移並賦值</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>小於比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>小於等於比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>賦值／等值</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>等於比較</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>配對分支語法的其中一部分</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>大於比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>大於等於比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>右移</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>右移並賦值</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>模式綁定</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>位元運算互斥（exclusive）OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>位元運算互斥 OR 並賦值</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>模式 OR</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>位元運算 OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>位元運算 OR 並賦值</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>邏輯運算 OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>錯誤傳遞</td><td></td></tr>
</tbody></table>
</div>
<h3 id="非運算子符號"><a class="header" href="#非運算子符號">非運算子符號</a></h3>
<p>以下列表包含所有不作為運算子的符號；也就是說，它們的行為並不像是在呼叫函式或方法。</p>
<p>表 B-2 顯示了出現在各處單獨出現且有效的符號。</p>
<p><span class="caption">表 B-2：獨立語法</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>有名稱的生命週期或迴圈標籤</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>指定型別的數值字面值</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>字串字面值</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>原始字串字面值，不會處理跳脫字元</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>位元組字串字面值，其會組織一個位元組陣列（<code>[u8]</code>）而非字串</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>原始位元組字串字面值，結合原始與位元組字串的字面值</td></tr>
<tr><td><code>'...'</code></td><td>字元字面值</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII 位元組字面值</td></tr>
<tr><td><code>|...| expr</code></td><td>閉包</td></tr>
<tr><td><code>!</code></td><td>發散函式（diverging functions）的永遠為空的型別</td></tr>
<tr><td><code>_</code></td><td>「忽略」模式綁定，也用於整數字面值的可讀性</td></tr>
</tbody></table>
</div>
<p>表 B-3 顯示了出現在模組架構中到一個項目的路徑的符號。</p>
<p><span class="caption">表 B-3：路徑相關語法</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>命名空間路徑</td></tr>
<tr><td><code>::path</code></td><td>與 crate 源頭相對應的路徑（如顯式絕對路徑）</td></tr>
<tr><td><code>self::path</code></td><td>與目前模組相對應的路徑（如顯式相對路徑）</td></tr>
<tr><td><code>super::path</code></td><td>與上層模組相對應的路徑</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>關聯常數、函式與型別</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>無法直接命名的型別的關聯項目（如 <code>&lt;&amp;T&gt;::...</code>、<code>&lt;[T]&gt;::...</code> 等等）</td></tr>
<tr><td><code>trait::method(...)</code></td><td>透過命名其定義的特徵來消除方法呼叫的歧義</td></tr>
<tr><td><code>type::method(...)</code></td><td>透過命名其定義的型別來消除方法呼叫的歧義</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>透過命名特徵與型別來消除方法呼叫的歧義</td></tr>
</tbody></table>
</div>
<p>Table B-4 顯示出現在泛型型別參數的符號。</p>
<p><span class="caption">表 B-4：泛型</span></p>
<div class="table-wrapper"><table><thead><tr><th>型別</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>指定參數給型別中的泛型型別（如 <code>Vec&lt;u8&gt;</code>）</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>指定參數給表達式中的泛型型別、函式或方法，通常被稱之為 turbofish（如 <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>）</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>定義泛型函式</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>定義泛型結構體</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>定義枚舉結構體</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>定義泛型實作</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>高階生命週期界限</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>其一或數個關聯型別有特定賦值的泛型型別（如 <code>Iterator&lt;Item=T&gt;</code>）</td></tr>
</tbody></table>
</div>
<p>表 B-5 顯式出現在透過特徵界限約束泛型型別參數的符號。</p>
<p><span class="caption">表 B-5：特徵界限約束</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>泛型參數 <code>T</code> 約束於實作 <code>U</code> 的型別</td></tr>
<tr><td><code>T: 'a</code></td><td>泛型參數 <code>T</code> 的生命週期必須比 <code>'a</code> 還長（代表該型別無法傳遞包含任何聲明週期短於 <code>'a</code> 的參考）</td></tr>
<tr><td><code>T: 'static</code></td><td>泛型型別 <code>T</code> 不包含 <code>'static</code> 以外的借用參考</td></tr>
<tr><td><code>'b: 'a</code></td><td>泛型生命週期 <code>'b</code> 必須長於 <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>允許泛型型別參數為動態大小型別</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>複合型別約束</td></tr>
</tbody></table>
</div>
<p>表 B-6 顯示出現在呼叫或定義巨集與指定項目屬性的符號。</p>
<p><span class="caption">表 B-6：巨集與屬性</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>外部屬性</td></tr>
<tr><td><code>#![meta]</code></td><td>內部屬性</td></tr>
<tr><td><code>$ident</code></td><td>巨集替代</td></tr>
<tr><td><code>$ident:kind</code></td><td>巨集捕獲</td></tr>
<tr><td><code>$(…)…</code></td><td>巨集重複</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>巨集調用</td></tr>
</tbody></table>
</div>
<p>表 B-7 顯示建立註解的符號。</p>
<p><span class="caption">表 B-7：註解</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>行註解</td></tr>
<tr><td><code>//!</code></td><td>內部行技術文件註解</td></tr>
<tr><td><code>///</code></td><td>外部行技術文件註解</td></tr>
<tr><td><code>/*...*/</code></td><td>區塊註解</td></tr>
<tr><td><code>/*!...*/</code></td><td>內部區塊技術文件註解</td></tr>
<tr><td><code>/**...*/</code></td><td>外部區塊技術文件註解</td></tr>
</tbody></table>
</div>
<p>表 B-8 顯示出現在元組中的符號。</p>
<p><span class="caption">表 B-8：元組</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>空元組（也稱為單元），同時是字面值與型別</td></tr>
<tr><td><code>(expr)</code></td><td>括號表達式</td></tr>
<tr><td><code>(expr,)</code></td><td>單一元素元組表達式</td></tr>
<tr><td><code>(type,)</code></td><td>單一元素元組型別</td></tr>
<tr><td><code>(expr, ...)</code></td><td>元組表達式</td></tr>
<tr><td><code>(type, ...)</code></td><td>元組型別</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>函式呼叫表達式，也用來初始化元組 <code>struct</code> 與元組 <code>enum</code> 變體</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>元組索引</td></tr>
</tbody></table>
</div>
<p>表 B-9 顯示大括號使用到的地方。</p>
<p><span class="caption">表 B-9：大括號</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>區塊表達式</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> 字面值</td></tr>
</tbody></table>
</div>
<p>表 B-10 顯示中括號使用到的地方。</p>
<p><span class="caption">表 B-10：中括號</span></p>
<div class="table-wrapper"><table><thead><tr><th>符號</th><th>解釋</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>陣列字面值</td></tr>
<tr><td><code>[expr; len]</code></td><td>包含 <code>len</code> 個 <code>expr</code> 的陣列字面值</td></tr>
<tr><td><code>[type; len]</code></td><td>包含 <code>len</code> 個 <code>type</code> 的陣列字面值</td></tr>
<tr><td><code>expr[expr]</code></td><td>集合索引，可超載（<code>Index</code>、<code>IndexMut</code>）</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>使用 <code>Range</code>、<code>RangeFrom</code>、<code>RangeTo</code> 或 <code>RangeFull</code> 作為「索引」來替代集合 slice 的集合索引</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-c可推導的特徵"><a class="header" href="#附錄-c可推導的特徵">附錄 C：可推導的特徵</a></h2>
<p>在本書中的許多地方方，我們都有遇到 <code>derive</code> 屬性，這能用在結構體或枚舉定義中。<code>derive</code> 屬性會透過 <code>derive</code> 語法來對被標記的型別產生對應的預設特徵實作。</p>
<p>在此附錄中，我們提供了所有在標準函式庫中你可以透過 <code>derive</code> 來使用的特徵。每個段落會包含：</p>
<ul>
<li>該特徵會推導出哪些運算子與方法</li>
<li><code>derive</code> 提供的特徵實作會做什麼事情</li>
<li>該特徵實作對型別有何影響</li>
<li>你能夠或不能夠實作特徵的條件</li>
<li>需要特徵來做運算的範例</li>
</ul>
<p>如果你想要不同於 <code>derive</code> 屬性提供的行為，請查閱每個特徵的<a href="https://doc.rust-lang.org/std/index.html">標準函式庫技術文件</a><!-- ignore -->來瞭解如何手動實作它們。</p>
<p>以下列出的是唯一能在標準函式庫中使用 <code>derive</code> 來對你的型別實作的特徵。其他在標準函式庫的特徵不太常有理想的預設行為，所以會由你來決定最合理的方式來實作它們。</p>
<p>其中一個無法推導的特徵範例就是 <code>Display</code>，這用來顯示格式化資訊給終端使用者。這應該永遠由你來決定顯示型別給終端使用者的最佳方式。型別的哪些部分應該給使用者看到？哪些部分他們會覺得是有關聯的？什麼樣的資料格式對他們最相關？Rust 編譯器並不具這樣的眼光能判斷，所以它無法為你提供適合的預設行為。</p>
<p>此附錄提供的可推導的特徵列表並不是就是所有能用的特徵：函式庫也可以為他們自己的特徵實作 <code>derive</code>，所以你可以使用 <code>derive</code> 的特徵是沒有極限的。實作 <code>derive</code> 會需要用到過程式巨集（procedural macro），這在第十九章的<a href="ch19-05-macros.html#%E5%B7%A8%E9%9B%86">「巨集」</a><!-- ignore -->段落有提到。</p>
<h3 id="用於開發時輸出的-debug"><a class="header" href="#用於開發時輸出的-debug">用於開發時輸出的 <code>Debug</code></a></h3>
<p><code>Debug</code> 特徵用於啟用除錯格式資訊的格式化字串，讓你可以在 <code>{}</code> 佔位符加上 <code>:?</code> 來顯示。</p>
<p><code>Debug</code> 特徵讓你可以印出型別實例的除錯資訊，好讓你以及其他程式設計師在使用你的型別時，能在程式執行的特定時間點觀察實例。</p>
<p>舉例來說，要使用 <code>assert_eq!</code> 巨集的話就必須要有 <code>Debug</code> 特徵。如果相等判定失敗的話，此巨集會印出作為引數的實例數值，讓程式設計師可以看到為何兩個實例不相等。</p>
<h3 id="用於比較相等的-partialeq-與-eq"><a class="header" href="#用於比較相等的-partialeq-與-eq">用於比較相等的 <code>PartialEq</code> 與 <code>Eq</code></a></h3>
<p><code>PartialEq</code> 特徵讓你可以比較型別實例來檢查是否相等，並可因此使用 <code>==</code> 與 <code>!=</code> 運算子。</p>
<p>推導 <code>PartialEq</code> 會實作 <code>eq</code> 方法。當推導結構體的 <code>PartialEq</code> 時，兩個實例之間必須<strong>所有</strong>欄位都相等才算相等，所以要是有任意欄位不相等實例就不算相等。而在枚舉推導時，每個變體會與自己相等，且與其他變體不相等。</p>
<p>舉例來說，使用 <code>assert_eq!</code> 巨集的話就必須要有 <code>PartialEq</code> 特徵，因為這要用來比較兩個型別實例是否相等。</p>
<p><code>Eq</code> 特徵沒有任何方法，它用來表示指定型別的每個數值都與自己本身相等。<code>Eq</code> 只能用於也有實作 <code>PartialEq</code> 的型別，然而並非所有實作 <code>PartialEq</code> 的型別都能實作 <code>Eq</code>。其中一個例子就是浮點數型別，浮點數的實作就指明兩個非數（not-a-number, <code>NaN</code>）實例數值彼此並不相等。</p>
<p>而 <code>Eq</code> 會用到的地方則有像是 <code>HashMap&lt;K, V&gt;</code> 中的鍵，這樣 <code>HashMap&lt;K, V&gt;</code> 才能知道兩個鍵之間是否相等。</p>
<h3 id="用於比較順序的-partialord-與-ord"><a class="header" href="#用於比較順序的-partialord-與-ord">用於比較順序的 <code>PartialOrd</code> 與 <code>Ord</code></a></h3>
<p><code>PartialOrd</code> 特徵讓你比較型別實例排序的順序。有實作 <code>PartialOrd</code> 的型別能夠使用 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 與 <code>&gt;=</code> 運算子。你只能在有實作 <code>PartialEq</code> 的型別實作 <code>PartialOrd</code> 特徵。</p>
<p>推導 <code>PartialOrd</code> 會實作 <code>partial_cmp</code> 方法，這會回傳一個 <code>Option&lt;Ordering&gt;</code>，當給予的數值無法產生任何順序的話就會是 <code>None</code>。其中一個儘管該型別大多數數值都能比較時，但仍有機會無法產生順序的範例就是非數（not-a-number, <code>NaN</code>）浮點數數值。對任意浮點數與 <code>NaN</code> 浮點數數值呼叫 <code>partial_cmp</code> 的話就會回傳 <code>None</code>。</p>
<p>當在結構體推導時，<code>PartialOrd</code> compare 會比較兩個實例，並從結構體定義的欄位順序來依序比較每個欄位的數值。而在枚舉推導時，在枚舉定義中較早宣告的枚舉變體會比之後的變體還小。</p>
<p>舉例來說，<code>rand</code> crate 中的 <code>gen_range</code> 方法就必須要有 <code>PartialOrd</code> 特徵，該方法會在指定的範圍內產生隨機數值。</p>
<p><code>Ord</code> 特徵能讓你知道指定型別的任意兩個數值存在著順序。<code>Ord</code> 特徵實作了 <code>cmp</code> 方法，這會回傳 <code>Ordering</code> 而不只是 <code>Option&lt;Ordering&gt;</code>，因為其永遠會有有效的順序。你只能在有實作 <code>PartialOrd</code> 與 <code>Eq</code>（而 <code>Eq</code> 需要 <code>PartialEq</code>）的特徵實作 <code>Ord</code> 特徵。在結構體與枚舉推導時，<code>cmp</code> 的行為會與 <code>PartialOrd</code> 推導的 <code>partial_cmp</code> 行為一致。</p>
<p>其中一個需要 <code>Ord</code> 的範例就是當 <code>BTreeSet&lt;T&gt;</code> 要儲存數值的時候，這是一個依據數值排序順序儲存資料的資料結構。</p>
<h3 id="用於複製數值的-clone-與-copy"><a class="header" href="#用於複製數值的-clone-與-copy">用於複製數值的 <code>Clone</code> 與 <code>Copy</code></a></h3>
<p><code>Clone</code> 特徵讓你能顯式建立一個數值的深拷貝，而且在複製的過程中可能會包含執行其他程式碼並拷貝堆積的資料。你可以在第四章的<a href="ch04-01-what-is-ownership.html#%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%87%E6%96%99%E4%BA%92%E5%8B%95%E7%9A%84%E6%96%B9%E5%BC%8F%E5%85%8B%E9%9A%86clone">「變數與資料互動的方式：克隆（Clone）」</a><!-- ignore -->段落瞭解更多關於 <code>Clone</code> 的資訊。</p>
<p>推導 <code>Clone</code> 會實作 <code>clone</code> 方法，這在整個型別實作時，會呼叫每個型別部分的 <code>clone</code>。這意味著該型別的所有欄位或數值都必須有實作 <code>Clone</code> 才能推導 <code>Clone</code>。</p>
<p>會需要用到 <code>Clone</code> 的其中一個例子是對 slice 呼叫 <code>to_vec</code> 方法。Slice 不擁有其所包含的型別實例，但是 <code>to_vec</code> 回傳的向量會需要擁有其實例，所以 <code>to_vec</code> 會對每個項目呼叫 <code>clone</code>。因此，儲存在 slice 內的型別必須實作 <code>Clone</code>。</p>
<p><code>Copy</code> 特徵讓你能只拷貝堆疊上的資料來複製數值，而且不需要額外的程式碼。你可以在第四章的<a href="ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E5%A0%86%E7%96%8A%E4%B8%8A%E7%9A%84%E8%B3%87%E6%96%99%E6%8B%B7%E8%B2%9Dcopy">「只在堆疊上的資料：拷貝（Copy）」</a><!-- ignore -->段落瞭解更多關於 <code>Copy</code> 的資訊。</p>
<p><code>Copy</code> 特徵沒有定義任何方法，以避免開發者超載這些方法並違反不執行任何程式碼的假設。這樣所有的程式設計師才都能預定拷貝數值是很迅速的。</p>
<p>你可以對任何內部所有部分有實作 <code>Copy</code> 的型別推導 <code>Copy</code>。實作 <code>Copy</code> 的型別必須也實作 <code>Clone</code>，因為其所做的事會與 <code>Copy</code> 一樣。</p>
<p><code>Copy</code> 通常不是必要的，實作 <code>Copy</code> 的型別會能進行優化，代表你不需要呼叫 <code>clone</code> 並讓程式碼更簡潔。</p>
<p>所有 <code>Copy</code> 能辦到的事你也能用 <code>Clone</code> 來達成，但是程式碼會變得比較慢或是需要使用 <code>clone</code>。</p>
<h3 id="用於映射數值至固定大小數值的-hash"><a class="header" href="#用於映射數值至固定大小數值的-hash">用於映射數值至固定大小數值的 <code>Hash</code></a></h3>
<p><code>Hash</code> 特徵讓你能取得任意大小的型別實例，並使用在雜湊函式映射（map）到固定大小的數值實例。推導 <code>Hash</code> 會實作 <code>hash</code> 方法。推導出的 <code>hash</code> 方法實作會組合該型別每個部分的 <code>hash</code> 呼叫結果，這代表所有的欄位或數值也必須實作 <code>Hash</code> 才能推導 <code>Hash</code>。</p>
<p>會需要 <code>Hash</code> 的其中一個範例是在 <code>HashMap&lt;K, V&gt;</code> 儲存鍵，這樣才能有效率地儲存資料。</p>
<h3 id="用於預設數值的-default"><a class="header" href="#用於預設數值的-default">用於預設數值的 <code>Default</code></a></h3>
<p><code>Default</code> 特徵讓你能建立一個型別的預設數值。推導 <code>Default</code> 會實作 <code>default</code> 函式。推導出的 <code>default</code> 函式實作會呼叫該型別每個部分的 <code>default</code> 函式，這代表該型別的所有欄位或數值都得實作 <code>Default</code> 才能推導 <code>Default</code>。</p>
<p><code>Default::default</code> 函式常用於結合結構體更新語法，如果我們在第五章的<a href="ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%B5%90%E6%A7%8B%E9%AB%94%E6%9B%B4%E6%96%B0%E8%AA%9E%E6%B3%95%E5%BE%9E%E5%85%B6%E4%BB%96%E7%B5%90%E6%A7%8B%E9%AB%94%E5%BB%BA%E7%AB%8B%E5%AF%A6%E4%BE%8B">「使用結構體更新語法從其他結構體建立實例」</a><!-- ignore -->段落所提及的。你可以自訂結構體中的一些欄位，然後使用 <code>..Default::default()</code> 將剩餘的欄位設為預設數值。</p>
<p>舉例來說，當你在 <code>Option&lt;T&gt;</code> 實例中使用 <code>unwrap_or_default</code> 方法就會需要 <code>Default</code> 特徵。如果 <code>Option&lt;T&gt;</code> 為 <code>None</code>，<code>unwrap_or_default</code> 方法就會回傳儲存在 <code>Option&lt;T&gt;</code> 的 <code>T</code> 的 <code>Default::default</code> 結果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-d---實用開發工具"><a class="header" href="#附錄-d---實用開發工具">附錄 D - 實用開發工具</a></h2>
<p>在此附錄中，我們會討論些 Rust 專案提供的實用開發工具。我們會介紹自動格式化工具、修正警告最快速的方式、linter 以及 IDE 的整合工具。</p>
<h3 id="透過-rustfmt-自動格式化"><a class="header" href="#透過-rustfmt-自動格式化">透過 <code>rustfmt</code> 自動格式化</a></h3>
<p><code>rustfmt</code> 工具會依據社群程式碼風格來重新格式化你的程式碼。許多協作專案都會使用 <code>rustfmt</code> 來避免 Rust 風格的歧義，每個人都能用此工具格式化他們的程式碼。</p>
<p>欲安裝 <code>rustfmt</code>，請輸入以下命令：</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>此命令會給你 <code>rustfmt</code> 與 <code>cargo-fmt</code>，就像 Rust 會提供你 <code>rustc</code> 與 <code>cargo</code> 一樣。要格式化任何 Cargo 專案的話，請輸入：</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>執行此命令會重新格式化目前 crate 中所有的 Rust 程式碼。不過這只會變更程式碼風格，並不會影響程式碼語義。想瞭解更多 <code>rustfmt</code> 的資訊，歡迎查閱<a href="https://github.com/rust-lang/rustfmt">它的技術文件</a>。</p>
<h3 id="透過-rustfix-修正你的程式碼"><a class="header" href="#透過-rustfix-修正你的程式碼">透過 <code>rustfix</code> 修正你的程式碼</a></h3>
<p>rustfix 工具包含在 Rust 的安裝中，它可以自動修復編譯器警告，這可能是你想要糾正問題的明確方法。你以前可能看過編譯器警告。舉例來說，請參考以下程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>我們在此呼叫 <code>do_something</code> 函式 100 次，但是我們在 <code>for</code> 迴圈中完全沒用到變數 <code>i</code>。Rust 會警告我們：</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 0..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>警告訊息建議我們改使用 <code>_i</code> 來作為名稱，底線指的是我們認定此變數不會被使用。我們可以透過執行 <code>cargo fix</code> 來使用 <code>rustfix</code> 工具以自動採用這些建議：</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>當我們再次檢查 <em>src/main.rs</em>，我們會看到 <code>cargo fix</code> 已經將程式碼修正了：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p><code>for</code> 迴圈變數現在改名為 <code>_i</code>，而警告也不再出現了。</p>
<p>你也可以使用 <code>cargo fix</code> 命令來在不同的 Rust 版號之間做轉換程式碼。版號會在附錄 E 做介紹。</p>
<h3 id="透過-clippy-運用更多功能"><a class="header" href="#透過-clippy-運用更多功能">透過 Clippy 運用更多功能</a></h3>
<p>Clippy 工具是一系列的 lint 集合，用來分析程式碼以獲取常見錯誤並改善你的 Rust 程式碼。</p>
<p>要安裝 Clippy 的話，輸入以下命令：</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>要在任何 Cargo 專案執行 Clippy，輸入以下命令：</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>舉例來說，假設你在寫程式時使用到如 pi 這種數學常數的近似值，如以下所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>對此專案執行 <code>cargo clippy</code> 會顯示以下錯誤：</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>此錯誤告訴你 Rust 已經有個更精準的 <code>PI</code> 常數定義，如果改使用此定義的話，你的程式會更準確。你可以將你的程式碼改使用 <code>PI</code> 常數。以下程式碼就不會透過 Clippy 獲得任何錯誤或警告：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>關於更多 Clippy 的資訊，請查閱<a href="https://github.com/rust-lang/rust-clippy">它的技術文件</a>。</p>
<h3 id="使用-rust-analyzer-整合-ide"><a class="header" href="#使用-rust-analyzer-整合-ide">使用 <code>rust-analyzer</code> 整合 IDE</a></h3>
<p>為了協助 IDE 的整合，Rust 社群推薦使用 <a href="https://rust-analyzer.github.io"><code>rust-analyzer</code></a><!-- ignore -->。此工具會與 <a href="http://langserver.org/">Language Server Protocol</a> 溝通，來提供許多與編譯器相關的協助，這是 IDE 與程式語言彼此溝通的協定規格。<code>rust-analyzer</code> 可用於各種不同的客戶端，像是 <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Visual Studio Code 的 Rust analyzer 外掛</a>。</p>
<p>前往 <code>rust-analyzer</code> 專案的<a href="https://rust-analyzer.github.io">首頁</a><!-- ignore -->可以了解更多安裝方法，讓你所使用的 IDE 也能獲得 Language Server 的支援。這樣你的 IDE 就能獲得許多功能像是：自動補全、跳至定義與顯示錯誤等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-e---版號"><a class="header" href="#附錄-e---版號">附錄 E - 版號</a></h2>
<p>在第一章中，你會看到 <code>cargo new</code> 會在 <em>Cargo.toml</em> 檔案中加上一些關於版號（edition）的詮釋資料。此附錄會講解其意義！</p>
<p>Rust 語言與編譯器有一個為其六週的發佈循環，這意味著使用者可能定期獲得一些新功能。其他程式設計語言可能會發佈較大的更新但就會比較不頻繁。Rust 傾向於較頻繁地發佈小更新。過一段時間後，這些所有變更會漸漸累積起來。不過隨著一次次的發佈，回過頭來看可能會發覺「哇！Rust 1.10 與 Rust 1.31 之間的變化真大！」</p>
<p>所以每個兩到三年，Rust 團隊會產生新的 Rust <strong>版號（edition）</strong>。每個版本會整合已推出的功能成一整個附有完整技術文件更新與工具的套件。然後新的版號就會包含在每六週循環過程的發佈之中。</p>
<p>版號對不同客群提供不同功能：</p>
<ul>
<li>對於活躍的 Rust 使用者來說，新的版號將累積的變更整合成容易理解的單一套件。</li>
<li>對非使用者來說，新的版號意味著有一些新的重大進展，讓 Rust 可能值得再看一次。</li>
<li>對於開發 Rust 的人來說，新的版號提供整個專案的一個集結點。</li>
</ul>
<p>在本書撰寫時，Rust 已經有三個版號：Rust 2015、Rust 2018 與 Rust 2021。本書使用的是 Rust 2021 版號的慣用寫法。</p>
<p><em>Cargo.toml</em> 中的 <code>edition</code> 指的是編譯器該對你的程式碼使用何種版號。如果沒有指定的話，Rust 會以向下相容作為考量而是使用 <code>2015</code>。</p>
<p>每個專案都能選擇一種版號而不只是使用預設的 2015 版號。版號會包含無法相容的變更，像是包含新的關鍵字使得程式碼中的標識符衝突。然而，除非你親自改變版號，不然就算你更新 Rust 編譯器的版本，你的程式碼依然能夠編譯通過。</p>
<p>所有的 Rust 編譯器版本會支援在其編譯器發佈之前的任何版號，而且可以連結任何支援版號的 crate。版號變更只會影響編譯器初始解析程式碼的方式而已。因此，如果你使用 Rust 2015 但你其中一個依賴使用 Rust 2018 的話，你的專案仍然能編譯並使用該依賴函式庫。相對地，當你的專案使用 Rust 2018 而有依賴使用 Rust 2015 的話依然是如此。</p>
<p>這裡要澄清一點：大多數功能在所有版號中都能使用。開發者使用任何 Rust 版號都能繼續獲得新的穩定版本帶來的改善。然而有些情況下，主要是增加新的關鍵字的時候，有一些新功能可能就只有後期的版號才能使用。你想使用利用新功能的話，就得切換版號。</p>
<p>想瞭解更多資訊的話，請查閱 <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition Guide</em></a>，這是本涵蓋所有版號之間不同的書籍，並會解釋如何使用 <code>cargo fix</code> 來自動升級你的程式碼至新的版號。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-f本書的翻譯本"><a class="header" href="#附錄-f本書的翻譯本">附錄 F：本書的翻譯本</a></h2>
<p>對於英文以外的語言資源，大部分都還在翻譯中，請查看 <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Translations label</a> 來幫助或讓我們知道有哪些新的翻譯！</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/rust-tw/book-tw">正體中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/Ciro-Fusco/book_it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/venkatarun95/rust-book-hindi">हिंदी</a></li>
<li><a href="https://github.com/rust-lang-th/book-th">ไทย</a></li>
<li><a href="https://github.com/DanKHansen/book-dk">Danske</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="附錄-g---rust-的開發流程與每夜版-rust"><a class="header" href="#附錄-g---rust-的開發流程與每夜版-rust">附錄 G - Rust 的開發流程與「每夜版 Rust」</a></h2>
<p>本附錄會介紹 Rust 是如何開發的，以及這對身為 Rust 開發者的你會有何影響。</p>
<h3 id="無停滯穩定"><a class="header" href="#無停滯穩定">無停滯穩定</a></h3>
<p>身為一門語言，Rust <strong>十分</strong>注重程式碼穩定性。我們希望 Rust 成為你在開發中的穩固基石，如果經常在更新的話，這樣的願望就很難達成了。同時，如果我們不能實驗新功能的話，直到它們發佈之前，我們可能就無法找出重大瑕疵，而且發佈後我們就很難再加以更改了。</p>
<p>我們對此問題的解決方案為「無停滯穩定（stability without stagnation）」，而我們的指導原則為：你永遠不該害怕升級最新的 Rust 穩定版。每次都該是無痛升級，但同時也該提供新功能、修正錯誤並加快編譯時間。</p>
<h3 id="嘟嘟火車出發發佈通道與時刻表"><a class="header" href="#嘟嘟火車出發發佈通道與時刻表">嘟嘟火車出發！發佈通道與時刻表</a></h3>
<p>Rust 開發團隊有個<strong>發佈時刻表（train schedule）</strong>。而所有的開發工作都在 Rust repository 的 <code>master</code> 分支上。發佈採用軟體發佈火車模型（software release train model），這也被用於 Cisco IOS 與其他的軟體專案。Rust 有三個<strong>發佈通道（release channels）</strong>：</p>
<ul>
<li>每夜版（Nightly）</li>
<li>測試版（Beta）</li>
<li>穩定版（Stable）</li>
</ul>
<p>大多數的 Rust 開發者主要都使用穩定版的通道，但是想要實驗新功能的人可以嘗試使用每夜版或測試版。</p>
<p>以下是開發與發佈過程是如何進行的範例：讓我們假設 Rust 團隊正在準備發佈 Rust 1.5。這版本在 2015 年十二月就發佈，做此假設只是為我們提供較真實的版本數字。其中有一個新功能會加入 Rust 並在 <code>master</code> 分支新增一個 commit。每個晚上 Rust 都會產生新的每夜版版本，然後每到天亮就會發佈，而這些發佈均由發佈基礎設施自動產生。所以隨著時間過去，我們每晚都會有一個發佈像這樣進行：</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>接著每隔六週就是時候發佈新的發佈版本了！Rust repository 的 <code>beta</code> 分支會從每夜版使用的 <code>master</code> 分支產生。現在我們就有了兩種發佈：</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>大多數的 Rust 使用者並不會直接使用測試版發佈，而會用他們的 CI 系統來檢查測試版來幫助 Rust 發現可能的迴歸錯誤（regressions）。同時，每夜版仍然會每晚產生新的發佈：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>假設有迴歸錯誤被發現了，那這對我們來說就是個好消息。因為在錯誤潛入穩定版發佈之前，我們還有些時間能檢測測試版的發佈！修正會加到 <code>master</code>，所以每夜版就能被修正。然後該修正也會合併到 <code>beta</code>，所以新的測試版發佈就會跟著產生：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>再經過第一個測試版產生的六週後，就是時候發佈穩定版了！<code>stable</code> 分支會從 <code>beta</code> 分支中產生：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>太好了！Rust 1.5 終於釋出了！不過我們不能忘記一件事，由於六週過去了，我們也必須為<strong>下一個</strong> Rust 1.6 版本準備新的測試版。所以在 <code>stable</code> 從 <code>beta</code> 產生後，下個版本的 <code>beta</code> 分支會再次從 <code>nightly</code> 產生：</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>這就叫「火車模型（train model）」，因為每隔六週就會有個發佈「駛離車站」，但其仍需要穿梭過測試版通道，才能抵達穩定版發佈。</p>
<p>Rust 會像發條裝置一樣每隔六週定時發佈。如果你已經知道一個 Rust 發佈的日期，你就能知道下一個的發佈日期，也就是六週之後。這樣每隔六週發佈的時程表有個好處是下一輛火車很快也會接著抵達。如果某個特定版本遺漏某項功能的話，不用擔心，因為下一版很快就會來臨了！這能降低發佈截止日期前，不得不偷偷釋出尚未完善的功能的壓力。</p>
<p>幸虧有此流程，你永遠都可以看到 Rust 的下一個版本並驗證你是否能輕鬆升級。如果測試版不如你所預期，你可以回報給團隊並在穩定版發佈前修正完成！在測試版出現重大缺陷是很少見的，但 <code>rustc</code> 本身仍是個軟體，總避免不了些錯誤發生。</p>
<h3 id="不穩定功能"><a class="header" href="#不穩定功能">不穩定功能</a></h3>
<p>此發佈模型還有一項重點，那就是不穩定（unstable）功能。Rust 使用一個叫做「功能標記（feature flags）」的技術來決定一個發佈能啟用哪些功能。如果有個新功能正在積極開發中，它可以加進 <code>master</code> 因而出現在每夜版中，但是會有個<strong>功能標記</strong>。如果身為使用者的你想要嘗試看看仍在開發中的功能的話，你是可以使用的。但是你必須透過 Rust 每夜版並在你的程式碼指明對應的功能標記才行。</p>
<p>如果你使用的是測試版或穩定版 Rust，你就無法使用任何功能標記。這是讓我們在宣佈新功能已經永遠穩定前，能夠確實測試它們的關鍵。這滿足了想使用前沿技術的人，同時也確保維持在穩定版的人有穩固的基石，不會讓他們的程式碼被破壞。這就是所謂的無停滯穩定。</p>
<p>本書只涵蓋了穩定版的功能資訊，因為開發中的功能可能隨時會改變。當其納入穩定版時肯定會與此書撰寫的時候而有所不同。你可以在線上找到每夜版功能的技術文件。</p>
<h3 id="rustup-與-rust-每夜版的職責"><a class="header" href="#rustup-與-rust-每夜版的職責">Rustup 與 Rust 每夜版的職責</a></h3>
<p>Rustup 能夠輕鬆切換不同的 Rust 發佈通道，在全域或是每個專案的範圍都行。而預設情況下，你會安裝穩定版 Rust。要安裝每夜版的話，請輸入以下命令：</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>你還可以看到你透過 <code>rustup</code> 安裝的所有<strong>工具鏈（toolchains）</strong>（Rust 的發佈與相關元件）。以下是本書其中一位作者 Windows 電腦中的範例：</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>如你所見，穩定版工具鏈是預設選項。大多數 Rust 使用者在大部分時間都會使用穩定版。你可以平時在大部分時間使用穩定版，並在需要使用前沿技術功能的特定專案下使用每夜版。為此，你可以在該專案目錄下使用 <code>rustup override</code> 來設置 <code>rustup</code> 在該目錄下需要使用每夜版工具鏈：</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>現在你每次在 <em>~/projects/needs-nightly</em> 底下呼叫 <code>rustc</code> 或 <code>cargo</code> 的話，<code>rustup</code> 會確保你使用的是每夜版 Rust，而不是預設的穩定版 Rust。這在當你有一堆 Rust 專案時會非常好用！</p>
<h3 id="rfc-流程與團隊"><a class="header" href="#rfc-流程與團隊">RFC 流程與團隊</a></h3>
<p>所以你該怎麼學習這些新功能呢？Rust 的開發模型遵循的是<strong>請求意見稿（Request For Comments, RFC）流程</strong>。如果你想要改善 Rust，你可以寫篇 RFC 提案。</p>
<p>任何人都可以寫篇 RFC 來改善 Rust，然後該提案會經由 Rust 團隊審核並討論，而團隊有許多子主題團隊所組成。<a href="https://www.rust-lang.org/governance">在 Rust 官網上</a>有完整的團隊列表，包含每個專案領域的團隊，像是語言設計、編譯器實作、基礎設施、技術文件以及更多等等。相對應的團隊會閱讀提案並留言、寫些他們的想法，並在最後達成共識，決定要接受或拒絕該功能。</p>
<p>如果功能被接受了，Rust repository 便會開啟對應 issue，然後每個人就都能嘗試實作它。實作該功能的人很可能與當初提案的人不相同！當實作準備好後，它便會加入 <code>master</code> 分支並有個功能標記，如同我們在<a href="appendix-07-nightly-rust.html#unstable-features">「不穩定功能」</a><!-- ignore -->段落所提及的。</p>
<p>經過一段時間後，一旦使用每夜版發佈的 Rust 開發者嘗試過新功能後，團隊成員會討論此功能，其在每夜版運行的如何，並決定它是否該加到穩定版。如果決定進一步加入的話，功能標記就會被移除，然後該功能就會是穩定功能了！它就像搭乘火車班抵達最新的 Rust 穩定版發佈。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="中英術語對照表"><a class="header" href="#中英術語對照表">中英術語對照表</a></h1>
<p>以下為本書所使用到的常用術語：</p>
<div class="table-wrapper"><table><thead><tr><th>English 英文</th><th>Traditional Chinese 正體中文</th><th>Note 備註</th></tr></thead><tbody>
<tr><td>Abstract Syntax Tree</td><td>抽象語法樹</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">維基百科</a></td></tr>
<tr><td>ahead-of-time compiled</td><td>預先編譯</td><td></td></tr>
<tr><td>annotations</td><td>詮釋</td><td></td></tr>
<tr><td>argument</td><td>引數</td><td></td></tr>
<tr><td>arity</td><td>元數</td><td>所需運算元的數量。參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%85%83%E6%95%B0">維基百科</a></td></tr>
<tr><td>array</td><td>陣列</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B0%E7%BB%84">維基百科</a></td></tr>
<tr><td>assignment</td><td>賦值</td><td></td></tr>
<tr><td>associated function</td><td>關聯函式</td><td></td></tr>
<tr><td>benchmarking</td><td>基準化分析法</td><td></td></tr>
<tr><td>best-practice</td><td>最佳做法</td><td></td></tr>
<tr><td>bit</td><td>位元</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BD%8D%E5%85%83">維基百科</a></td></tr>
<tr><td>block</td><td>區塊</td><td></td></tr>
<tr><td>boolean</td><td>布林</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E7%88%BE_(%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B)">維基百科</a></td></tr>
<tr><td>bounds-check</td><td>邊界檢查</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">維基百科</a></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>borrow checker</td><td>借用檢查器</td><td></td></tr>
<tr><td>bug</td><td>程式錯誤</td><td></td></tr>
<tr><td>Builder Pattern</td><td>生成器模式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">維基百科</a></td></tr>
<tr><td>byte</td><td>位元組</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E8%8A%82">維基百科</a></td></tr>
<tr><td>camel case</td><td>駝峰式大小寫</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">維基百科</a></td></tr>
<tr><td>clone</td><td>克隆</td><td></td></tr>
<tr><td>closures</td><td>閉包</td><td></td></tr>
<tr><td>coerce</td><td>強制</td><td></td></tr>
<tr><td>collection</td><td>集合</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>command line</td><td>命令列</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">維基百科</a></td></tr>
<tr><td>commit</td><td>提交</td><td></td></tr>
<tr><td>concurrency</td><td>並行</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97">維基百科</a></td></tr>
<tr><td>conditional</td><td>條件運算</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A2%9D%E4%BB%B6%E9%81%8B%E7%AE%97%E5%BC%8F">維基百科</a></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constant</td><td>常數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B8%B8%E6%95%B0">維基百科</a></td></tr>
<tr><td>constructor</td><td>建構子</td><td></td></tr>
<tr><td>copy</td><td>拷貝</td><td></td></tr>
<tr><td>crash</td><td>崩潰</td><td>亦譯作「當機」，為了避免混淆使用「崩潰」統一指稱，參考：<a href="https://terms.naer.edu.tw/search/?query_term=crash&amp;query_field=title&amp;query_op=&amp;match_type=phrase&amp;filter_bool=and&amp;filter_term=%27%E9%9B%BB%E5%AD%90%E8%A8%88%E7%AE%97%E6%A9%9F%E5%90%8D%E8%A9%9E%27&amp;filter_field=subcategory_1.raw&amp;filter_op=term&amp;tabaction=browse">樂詞網</a></td></tr>
<tr><td>dangling pointer</td><td>迷途指標</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">維基百科</a></td></tr>
<tr><td>data race</td><td>資料競爭</td><td></td></tr>
<tr><td>declaration statements</td><td>宣告陳述式</td><td></td></tr>
<tr><td>dependencies</td><td>依賴</td><td></td></tr>
<tr><td>deque</td><td>雙向佇列</td><td>Double-ended queue</td></tr>
<tr><td>dereference</td><td>取值</td><td>即 <code>*</code> 運算子</td></tr>
<tr><td>dispatch</td><td>分派</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%88%86%E6%B4%BE">維基百科</a></td></tr>
<tr><td>diverging functions</td><td>發散函式</td><td>不回傳值的函式</td></tr>
<tr><td>edition</td><td>版號</td><td></td></tr>
<tr><td>enumerate</td><td>枚舉</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%9E%9A%E4%B8%BE">維基百科</a></td></tr>
<tr><td>equality</td><td>等式</td><td></td></tr>
<tr><td>ergonomics</td><td>人因工程</td><td>參考：<a href="https://github.com/rust-tw/rfcs-tw/pull/19#discussion_r888110986">RFC 0198 PR</a></td></tr>
<tr><td>executable</td><td>執行檔</td><td></td></tr>
<tr><td>expression</td><td>表達式</td><td></td></tr>
<tr><td>expression-oriented</td><td>表達式導向</td><td></td></tr>
<tr><td>expression statements</td><td>表達陳述式</td><td></td></tr>
<tr><td>filename extension</td><td>副檔名</td><td></td></tr>
<tr><td>handle</td><td>控制代碼</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%A5%E6%9F%84">維基百科</a>、<a href="https://msdn.microsoft.com/zh-tw/library/yk97tc08.aspx">MSDN</a></td></tr>
<tr><td>heap</td><td>堆積</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">維基百科</a></td></tr>
<tr><td>fault</td><td>錯誤</td><td></td></tr>
<tr><td>formalization</td><td>正規化</td><td></td></tr>
<tr><td>function</td><td>函式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%90%E7%A8%8B%E5%BA%8F">維基百科</a></td></tr>
<tr><td>generics</td><td>泛型</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%B3%9B%E5%9E%8B">維基百科</a></td></tr>
<tr><td>hash</td><td>雜湊</td><td></td></tr>
<tr><td>hash map</td><td>雜湊映射</td><td></td></tr>
<tr><td>identifier</td><td>標識符</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AD%98%E7%AC%A6">維基百科</a></td></tr>
<tr><td>import</td><td>匯入</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%B4%A2%E5%BC%95">維基百科</a></td></tr>
<tr><td>instance</td><td>實體</td><td></td></tr>
<tr><td>iterative</td><td>疊代</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3">維基百科</a></td></tr>
<tr><td>iterator</td><td>疊代器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3%E5%99%A8">維基百科</a></td></tr>
<tr><td>immutable</td><td>不可變</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>inheritance</td><td>繼承</td><td></td></tr>
<tr><td>join</td><td>會合</td><td>意旨 threads 的會合，參考：<a href="https://github.com/rust-tw/rfcs-tw/pull/23#issuecomment-1177922394">RFC 3151 PR</a></td></tr>
<tr><td>keyword</td><td>關鍵字</td><td></td></tr>
<tr><td>language feature</td><td>語言特徵</td><td>參考：<a href="http://www.iicm.org.tw/term/termb_L.htm">中華民國資訊學會</a></td></tr>
<tr><td>library</td><td>函式庫</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%87%BD%E5%BC%8F%E5%BA%AB">維基百科</a></td></tr>
<tr><td>lifetimes</td><td>生命週期</td><td></td></tr>
<tr><td>linker</td><td>連結器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%93%BE%E6%8E%A5%E5%99%A8">維基百科</a></td></tr>
<tr><td>literal</td><td>字面值</td><td></td></tr>
<tr><td>loop</td><td>迴圈、循環</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B#.E8.BF.B4.E5.9C.88">維基百科</a></td></tr>
<tr><td>macro</td><td>巨集</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A8%E9%9B%86">維基百科</a></td></tr>
<tr><td>main function</td><td>主函式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%BB%E5%87%BD%E5%BC%8F">維基百科</a></td></tr>
<tr><td>metadata</td><td>詮釋資料</td><td></td></tr>
<tr><td>metaprogramming</td><td>超程式設計</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%85%83%E7%BC%96%E7%A8%8B">維基百科</a></td></tr>
<tr><td>method</td><td>方法</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>module</td><td>模組</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E7%B5%84_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">維基百科</a></td></tr>
<tr><td>monomorphism</td><td>單型</td><td></td></tr>
<tr><td>mutable</td><td>可變</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>mutability</td><td>可變性</td><td></td></tr>
<tr><td>mutation</td><td>可變數</td><td></td></tr>
<tr><td>namespace</td><td>命名空間</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">維基百科</a></td></tr>
<tr><td>nested</td><td>巢狀</td><td></td></tr>
<tr><td>Nightly</td><td>每夜版</td><td></td></tr>
<tr><td>operators</td><td>運算子</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90">維基百科</a></td></tr>
<tr><td>overloading</td><td>重載</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">維基百科</a></td></tr>
<tr><td>ownership</td><td>所有權</td><td></td></tr>
<tr><td>package</td><td>套件</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BD%AF%E4%BB%B6%E5%8C%85">維基百科</a></td></tr>
<tr><td>panic</td><td>恐慌</td><td></td></tr>
<tr><td>parse</td><td>分析、分析語法</td><td></td></tr>
<tr><td>parser</td><td>語法分析器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">維基百科</a></td></tr>
<tr><td>pattern</td><td>模式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">維基百科</a></td></tr>
<tr><td>pattern matching</td><td>模式配對</td><td>參考：<a href="http://www.iicm.org.tw/term/termb_P.htm">中華民國資訊學會</a></td></tr>
<tr><td>placeholder</td><td>佔位符</td><td></td></tr>
<tr><td>plugins</td><td>外掛</td><td></td></tr>
<tr><td>pointer</td><td>指標</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>polymorphism</td><td>多型</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>primitive type</td><td>基本型別</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5">維基百科</a></td></tr>
<tr><td>profile</td><td>設定檔</td><td></td></tr>
<tr><td>reference</td><td>參照、參考</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%83%E7%85%A7">維基百科</a></td></tr>
<tr><td>regression</td><td>迴歸錯誤</td><td></td></tr>
<tr><td>round bracket</td><td>圓括號</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8B%AC%E5%8F%B7">維基百科</a></td></tr>
<tr><td>runtime</td><td>執行時</td><td></td></tr>
<tr><td>scalar</td><td>純量</td><td></td></tr>
<tr><td>scope</td><td>有效範圍</td><td></td></tr>
<tr><td>section</td><td>段落</td><td></td></tr>
<tr><td>semantics</td><td>語意</td><td></td></tr>
<tr><td>segment</td><td>區段</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%88%86%E6%AE%B5">維基百科</a></td></tr>
<tr><td>segmentation fault</td><td>記憶體區段錯誤</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">維基百科</a></td></tr>
<tr><td>shadowing</td><td>遮蔽</td><td></td></tr>
<tr><td>sibling</td><td>同輩</td><td></td></tr>
<tr><td>signed integer</td><td>帶號整數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>slices</td><td>切片</td><td>其他資料結構的參考</td></tr>
<tr><td>square bracket</td><td>方括號</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8B%AC%E5%8F%B7">維基百科</a></td></tr>
<tr><td>stack</td><td>堆疊</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86%E6%A0%88">維基百科</a></td></tr>
<tr><td>statements</td><td>陳述式</td><td></td></tr>
<tr><td>string</td><td>字串</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E7%AC%A6%E4%B8%B2">維基百科</a></td></tr>
<tr><td>string interpolation</td><td>字串插值</td><td>參考：<a href="https://msdn.microsoft.com/zh-tw/library/dn961160.aspx">MSDN</a></td></tr>
<tr><td>struct</td><td>結構體</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/C%2B%2B%E7%B1%BB">維基百科</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%BB%93%E6%9E%84%E4%BD%93_(C%E8%AF%AD%E8%A8%80)">維基百科</a></td></tr>
<tr><td>subscript</td><td>下標</td><td>指的是 <code>a[1]</code> 中的 <code>[1]</code></td></tr>
<tr><td>symbols</td><td>符號</td><td></td></tr>
<tr><td>syntax</td><td>語法</td><td></td></tr>
<tr><td>tabs</td><td>分頁</td><td></td></tr>
<tr><td>thread</td><td>執行緒</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%BA%BF%E7%A8%8B">維基百科</a></td></tr>
<tr><td>trait</td><td>特徵</td><td>參考：<a href="https://zh.wikipedia.org/wiki/Traits_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">維基百科</a></td></tr>
<tr><td>tuple</td><td>元組</td><td></td></tr>
<tr><td>two’s complement</td><td>二補數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BA%8C%E8%A3%9C%E6%95%B8">維基百科</a></td></tr>
<tr><td>type</td><td>型別</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B">維基百科</a></td></tr>
<tr><td>type inference</td><td>型別推斷</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA">維基百科</a></td></tr>
<tr><td>unsigned integer</td><td>非帶號整數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>values</td><td>值、數值</td><td></td></tr>
<tr><td>variables</td><td>變數</td><td></td></tr>
<tr><td>variant</td><td>變體</td><td></td></tr>
<tr><td>vector</td><td>向量</td><td></td></tr>
<tr><td>view</td><td>視圖</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A7%86%E5%9B%BE">維基百科</a></td></tr>
<tr><td>wildcard</td><td>萬用字元</td><td></td></tr>
<tr><td>workspaces</td><td>工作空間</td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>無成本抽象化</td><td></td></tr>
</tbody></table>
</div>
<h2 id="未翻譯"><a class="header" href="#未翻譯">未翻譯</a></h2>
<div class="table-wrapper"><table><thead><tr><th>English 英文</th><th>Traditional Chinese 正體中文</th><th>Note 備註</th></tr></thead><tbody>
<tr><td>backtrace</td><td></td><td></td></tr>
<tr><td>build</td><td></td><td>名詞，例：create a &quot;build&quot;</td></tr>
<tr><td>crates</td><td></td><td></td></tr>
<tr><td>map</td><td></td><td></td></tr>
<tr><td>master</td><td></td><td>git branch</td></tr>
<tr><td>prelude</td><td></td><td>預先載入的函式庫</td></tr>
<tr><td>repository</td><td></td><td></td></tr>
<tr><td>Rustaceans</td><td></td><td>Rust 開發者稱呼自己的常用稱號</td></tr>
<tr><td>shell</td><td></td><td></td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
