<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>模式語法 - Rust 程式設計語言</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust 程式設計語言</a></li><li class="chapter-item expanded affix "><a href="foreword.html">前言</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">介紹</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 開始入門</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安裝教學</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 設計猜謎遊戲程式</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 常見程式設計概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 變數與可變性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 資料型別</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函式</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 註解</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流程</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 理解所有權</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什麼是所有權？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 引用與借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 切片型別</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 透過結構體組織相關資料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定義與實例化結構體</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 使用結構體的程式範例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 枚舉與模式配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定義枚舉</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流運算子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 透過 if let 簡化控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 透過套件、Crate 與模組管理成長中的專案</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 套件與 Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 定義模組來控制作用域與隱私權</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 引用模組項目的路徑</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> 透過 use 關鍵字引入路徑</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 將模組拆成不同檔案</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 常見集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 透過向量儲存列表</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 透過字串儲存 UTF-8 編碼的文字</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 透過雜湊映射儲存鍵值配對</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 與無法復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 與可復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 要 panic! 還是不要 panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型型別、特徵與生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型資料型別</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 特徵：定義共同行為</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 透過生命週期驗證引用</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 編寫自動化測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 如何寫測試</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 控制程式如何執行</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 測試組織架構</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 專案：建立一個命令列程式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 接受命令列引數</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 讀取檔案</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 透過重構來改善模組性與錯誤處理</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 透過測試驅動開發完善函式庫功能</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 處理環境變數</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 將錯誤訊息寫入標準錯誤而非標準輸出</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 函式語言功能：疊代器與閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 閉包：能獲取其環境的匿名函式</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用疊代器來處理一系列的項目</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改善我們的 I/O 專案</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 比較效能：迴圈 vs. 疊代器</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多關於 Cargo 與 Crates.io 的內容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 透過發佈設定檔自訂建構</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 發佈 Crate 到 Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空間</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 透過 cargo install 從 Crates.io 安裝二進制執行檔</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 透過自訂命命來擴展 Cargo 的功能</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智慧指標</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 使用 Box&lt;T&gt; 指向堆積上的資料</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 透過 Deref 特徵將智慧指標視為一般引用</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 透過 Drop 特徵執行清除程式碼</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt; 引用計數智慧指標</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; 與內部可變性模式</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 引用循環會導致記憶體泄漏</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 無懼並行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 使用執行緒同時執行程式碼</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 使用訊息傳遞在執行緒間傳送資料</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享狀態並行</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 透過 Sync 與 Send 特徵擴展並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的物件導向程式設計特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 物件導向語言的特色</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 允許不同型別數值的特徵物件</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 實作物件導向設計模式</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式與配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有能使用模式的地方</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 可反駁性：何時模式可能會配對失敗</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html" class="active"><strong aria-hidden="true">18.3.</strong> 模式語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 進階特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 進階特徵</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 進階型別</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 進階函式與閉包</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 巨集</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最終專案：建立多執行緒網頁伺服器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 建立單一執行緒的網頁伺服器</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 將單一執行緒伺服器轉換為多執行緒伺服器</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常關機與清理</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 附錄</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 關鍵字</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 運算子與符號</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可推導的特徵</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 實用開發工具</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 版號</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 本書的翻譯本</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust 的開發流程與「夜版 Rust」</a></li><li class="chapter-item expanded "><a href="appendix-08-terminology.html"><strong aria-hidden="true">21.8.</strong> H - 中英術語對照表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 程式設計語言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tw/book-tw" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="模式語法"><a class="header" href="#模式語法">模式語法</a></h2>
<p>在整本書中，我們已經看過許多種類的模式範例了。在此段落中，我們會收集所有模式中的有效語法，並討論你會怎麼使用它們。</p>
<h3 id="配對字面值"><a class="header" href="#配對字面值">配對字面值</a></h3>
<p>如同你在第六章所見的，你可以直接使用字面值來配對模式，以下程式碼展示了一些範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;一&quot;),
        2 =&gt; println!(&quot;二&quot;),
        3 =&gt; println!(&quot;三&quot;),
        _ =&gt; println!(&quot;任意數字&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會顯示「一」因為 x 的數值為 1。此語法適用於當你想要程式碼取得一個特定數值時，就馬上採取行動的情況。</p>
<h3 id="配對變數名稱"><a class="header" href="#配對變數名稱">配對變數名稱</a></h3>
<p>變數名稱是能配對任何數值的不可反駁模式，而且我們在本書中已經使用非常多次。不過當你在 <code>match</code> 表達式中使用變數名稱時會複雜一點。因為 <code>match</code> 會初始一個新的作用域，作為 <code>match</code> 表達式部分模式的宣告變數會遮蔽 <code>match</code> 結構外同名的變數，和所有變數一樣。在範例 18-11 中，我宣告了一個變數叫做 <code>x</code> 其有數值 <code>Some(5)</code> 和一個變數 <code>y</code> 其有數值 <code>10</code>。然後我們建立一個數值 <code>x</code> 的 <code>match</code> 表達式。檢查配對分之中的模式並在最後用 <code>println!</code> 顯示出來，並嘗試在程式碼執行或進一步閱讀之前推測其會顯示的結果會為何。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;取得 50&quot;),
        Some(y) =&gt; println!(&quot;配對成功，y = {:?}&quot;, y),
        _ =&gt; println!(&quot;預設情形，x = {:?}&quot;, x),
    }

    println!(&quot;最後結果：x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-11：<code>match</code> 表達式其中一個分支宣告了遮蔽的變數 <code>y</code></span></p>
<p>讓我們跑一遍看看當 <code>match</code> 執行時發生了什麼事。第一個配對分支並不符合 <code>x</code> 定義的數值，所以程式繼續執行下去。</p>
<p>第二個配對分支宣告了一個新的變數叫做 <code>y</code> 來配對 <code>Some</code> 內的任何數值。因為我們位於 <code>match</code> 表達式內的新作用域，此新的 <code>y</code> 變數並不是我們一開始宣告有數值 10 的 <code>y</code>。這個新的 <code>y</code> 會配對 <code>Some</code> 內的任何數值，也就是 <code>x</code> 擁有的數值。因此，這個新的 <code>y</code> 會綁定 <code>x</code> 中 <code>Some</code> 的內部數值。該數值是 <code>5</code>，所以該分支的表達式就會執行並印出 <code>配對成功，y = 5</code>。</p>
<p>如果 <code>x</code> 是 <code>None</code> 數值而非 <code>Some(5)</code> 的話，前兩個分支的模式都不會配對到，所以數值會配對到底線的分支。我們沒有在底線分支的模式中宣告 <code>x</code> 變數，所以表達式中的 <code>x</code> 仍然是外部沒有被遮蔽的 <code>x</code> 。在這樣的假設狀況下，<code>match</code> 會印出 <code>預設情形，x = None</code>。</p>
<p>當 <code>match</code> 完成時，其作用域就會結束，所以作用域內的內部 <code>y</code> 也會結束。最後一個 <code>println!</code> 會顯示 <code>最後結果：x = Some(5), y = 10</code>。</p>
<p>要建立個能對外部 <code>x</code> 與 <code>y</code> 數值做比較的 <code>match</code> 表達式而非遮蔽變數的話，我們需要改用條件配對守護。我們會在之後的<a href="#%E6%8F%90%E4%BE%9B%E9%A1%8D%E5%A4%96%E6%A2%9D%E4%BB%B6%E7%9A%84%E9%85%8D%E5%B0%8D%E5%AE%88%E8%AD%B7">「提供額外條件的配對守護」</a><!-- ignore -->段落討論配對守護。</p>
<h3 id="多重模式"><a class="header" href="#多重模式">多重模式</a></h3>
<p>在 <code>match</code> 表達式中，你可以使用 <code>|</code> 語法來配對數個模式，其代表 <strong>OR（或）</strong> 的意思。舉例來說，以下程式碼會配對 <code>x</code> 的數值到配對分支，第一個分支有個 <em>OR</em> 的選項，代表如果 <code>x</code> 的數值配對的到分支中任一數值的話，該分支的程式碼就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;一或二&quot;),
        3 =&gt; println!(&quot;三&quot;),
        _ =&gt; println!(&quot;任意數字&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出 <code>一或二</code>。</p>
<h3 id="透過--配對數值範圍"><a class="header" href="#透過--配對數值範圍">透過 <code>..=</code> 配對數值範圍</a></h3>
<p><code>..=</code> 語法讓我們可以配對一個範圍內包含的數值。在以下程式碼中，當模式配對的到範圍內的任何數值時，該分支就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;一到五&quot;),
        _ =&gt; println!(&quot;其他&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5 的話，第一個分支就能配對到。此語法比使用 <code>|</code> 運算子來表達相同概念還輕鬆得多。如果我們使用 <code>|</code> 的話，就得指明 <code>1 | 2 | 3 | 4 | 5</code> 而非 <code>1..=5</code>。指定範圍相對就簡短許多，尤其是如果我們得配對像是數字 1 到 1,000 的話！</p>
<p>範圍只允許使用數字或 <code>char</code> 數值，因為編譯器會在編譯時檢查範圍是否為空。<code>char</code> 與數字數值是 Rust 中唯一能判斷範圍是否為空的型別。</p>
<p>以下是使用 <code>char</code> 數值作為範圍的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;前半部 ASCII 字母&quot;),
        'k'..='z' =&gt; println!(&quot;後半部 ASCII 字母&quot;),
        _ =&gt; println!(&quot;其他&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust 可以知道 <code>c</code> 有包含在第一個模式的範圍內，所以印出 <code>前半部 ASCII 字母</code>。</p>
<h3 id="解構拆開數值"><a class="header" href="#解構拆開數值">解構拆開數值</a></h3>
<p>我們可以使用模式來解構結構體、枚舉、元組與引用，以便使用這些數值的不同部分。讓我們依序來看看。</p>
<h4 id="解構結構體"><a class="header" href="#解構結構體">解構結構體</a></h4>
<p>範例 18-12 有個結構體 <code>Point</code> 其有兩個欄位 <code>x</code> 與 <code>y</code>，我們可以在 <code>let</code> 陳述式使用模式來拆開它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">範例 18-12：解構結構體欄位成獨立的變數</span></p>
<p>此程式碼建立了變數 <code>a</code> 與 <code>b</code> 來配對 <code>p</code> 結構體中 <code>x</code> 與 <code>y</code> 的欄位。此範例顯示出模式中的變數名稱不必與結構體中的欄位名稱一樣。不過通常還是建議變數名稱與欄位名稱一樣，以便記得哪些變數來自於哪個欄位。</p>
<p>因為用變數名稱來配對欄位是十分常見的，而且因為 <code>let Point { x: x, y: y } = p;</code> 會包含許多重複部分，所以配對結構體欄位的模式有另一種簡寫方式，你只需要列出結構體欄位的名稱，這樣從結構體建立的變數名稱就會有相同名稱。範例 18-13 顯示的程式碼行為與範例 18-12 一樣，但是在 <code>let</code> 模式建立的變數是 <code>x</code> 與 <code>y</code> 而非 <code>a</code> 與 <code>b</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">範例 18-13：使用結構體欄位簡寫來解構結構體欄位</span></p>
<p>此程式碼建立了變數 <code>x</code> 與 <code>y</code> 並配對到變數 <code>p</code> 的 <code>x</code> 與 <code>y</code> 欄位。結果就是變數 <code>x</code> 與 <code>y</code> 會包含 <code>p</code> 結構體中的數值。</p>
<p>我們也可以將字面值數值作為結構體模式中的一部分，而不用建立所有欄位的變數。這樣做我們可以在解構一些欄位成變數時，測試其他欄位是否有特定數值。</p>
<p>範例 18-14 的 <code>match</code> 表達式將 <code>Point</code> 的數值分成三種情況：位於 <code>x</code> 軸的點（也就是 <code>y = 0</code>）、位於 <code>y</code> 軸的點（<code>x = 0</code>） 或不在任何軸的點。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;位於 x 軸的 {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;位於 y 軸的 {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;不在任一軸：({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-14：解構並配對模式中的字面值數值</span></p>
<p>第一個分支透過指定 <code>y</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>x</code> 軸上的點。此模式仍然會建立變數 <code>x</code> 能讓我們在此分支的程式碼中使用。</p>
<p>同樣地，第二個分支透過指定 <code>x</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>y</code> 軸上的點，並建立擁有 <code>y</code> 欄位數值的變數 <code>y</code>。 第三個分支沒有指定任何字面值，所以它能配對任何其他 <code>Point</code> 並建立 <code>x</code> 與 <code>y</code> 欄位對應的變數。</p>
<p>在此例中，數值 <code>p</code> 會配對到第二個分支，因為其 <code>x</code> 為 0，所以此程式碼會印出 <code>位於 y 軸的 7</code>。</p>
<h4 id="解構枚舉"><a class="header" href="#解構枚舉">解構枚舉</a></h4>
<p>我們已經在本書中之前的章節就解構過枚舉。舉例來說，第六章的範例 6-5 我們就解構了 <code>Option&lt;i32&gt;</code>。其中一個我們還沒談到的細節是解構枚舉的模式必須與枚舉定義中其所儲存的資料相符。作為示範，我們在範例 18-15 中使用範例 6-2 的 <code>Message</code> 枚舉並寫一個 <code>match</code> 來提供會解構每個內部數值的模式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;Quit 變體沒有資料能解構。&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move 往 x 的方向為 {} 且往 y 的方向為 {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;文字訊息：{}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;變更顏色為紅色 {}、綠色 {} 與藍色 {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-15：解構持有不同種數值的枚舉變體</span></p>
<p>此程式碼會印出 <code>變更顏色為紅色 0、綠色 160 與藍色 255</code>。請嘗試變更 <code>msg</code> 的數值來看看其他分支的程式碼會執行出什麼。</p>
<p>對於像是 <code>Message::Quit</code> 這種沒有任何資料的枚舉，我們無法進一步解構出任何資料。我們只能配對其本身的數值 <code>Message::Quit</code>，所以在該模式中沒有任何變數。</p>
<p>對於像是 <code>Message::Move</code> 這種類結構體枚舉變體，我們可以使用類似於指定配對結構體的模式。在變體名稱之後，我們加上大括號以及列出欄位名稱作為變數，讓我們能拆成不同部分並在此分支的程式碼中使用。我們在此使用範例 18-13 一樣的簡寫形式。</p>
<p>對於像是 <code>Message::Write</code> 這種持有一個元素，以及 <code>Message::ChangeColor</code> 這種持有三個元素的類元組枚舉變體，我們可以使用類似於配對元組的模式。模式中的變數數量必須與我們要配對的變體中元素個數相符。</p>
<h4 id="解構巢狀結構體與枚舉"><a class="header" href="#解構巢狀結構體與枚舉">解構巢狀結構體與枚舉</a></h4>
<p>到目前為止，我們所有的結構體或枚舉配對範例的深度都只有一層。配對也可以用於巢狀項目中！</p>
<p>舉例來說，我們可以重構範例 18-15 的程式碼，在 <code>ChangeColor</code> 中支援 RGB 與 HSV 顏色，如範例 18-16 所示。</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;變更顏色為紅色 {}、綠色 {} 與藍色 {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;變更顏色為色相 {}、飽和度 {} 與明度 {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-16：配對巢狀枚舉</span></p>
<p><code>match</code> 表達式的第一個分支模式會配對包含 <code>Color::Rgb</code> 變體的 <code>Message::ChangeColor</code> 枚舉變體，然後該模式會綁定內部三個 <code>i32</code> 數值。第二個分支也是配對到 <code>Message::ChangeColor</code> 枚舉變體，但是內部枚舉會改配對 <code>Color::Hsv</code>。我們可以在一個 <code>match</code> 表達式指定這些複雜條件，即使有兩個枚舉參與其中。</p>
<h4 id="解構結構體與元組"><a class="header" href="#解構結構體與元組">解構結構體與元組</a></h4>
<p>我們甚至可以用更複雜的方式來混合、配對並巢狀解構模式。以下範例展示了一個複雜的結構模式，其將一個結構體與一個元組置於另一個元組中，並將所有的原始數值全部解構出來：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼讓我們將複雜的型別拆成部分元件，讓我們可以分別使用我們有興趣的數值。</p>
<p>解構模式是個能方便使用部分數值的方式，比如結構體每個欄位分別獨立的數值。</p>
<h3 id="忽略模式中的數值"><a class="header" href="#忽略模式中的數值">忽略模式中的數值</a></h3>
<p>你已經看過有時候在模式中忽略數值是很實用的，像是在 <code>match</code> 中的最後一個分支能捕獲所有剩餘用不到的可能數值。模式有一些方式可以忽略所有或部分數值：使用（你已經看過的） <code>_</code> 模式、在其他模式使用 <code>_</code> 模式、在名稱前加上底線，或是使用 <code>..</code> 來忽略剩餘部分的數值。讓我們來探討如何與為何要使用這些模式吧。</p>
<h4 id="透過-_-忽略整個數值"><a class="header" href="#透過-_-忽略整個數值">透過 <code>_</code> 忽略整個數值</a></h4>
<p>我們使用底線在（<code>_</code>）來作為通配符（wildcard）模式，這會配對任何數值，但不會綁定其值。雖然底線 <code>_</code> 模式特別適合作為 <code>match</code> 表達式最後一個分支，但我們可以將它用在任何模式中，包含函式參數，如範例 18-17 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;此程式碼只使用了參數 y：{}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">範例 18-17：在函式簽名中使用 <code>_</code></span></p>
<p>此程式碼會完全忽略第一個引數傳入的數值 <code>3</code>，並會印出 <code>此程式碼只使用了參數 y：4</code>。</p>
<p>在大多數情況中如果當你不再需要特定函式參數的話，你會直接變更簽名讓它不會包含沒有使用到的參數。但忽略函式參數在某些場合會很有用。舉例來說，當你實作的特徵有個特定的型別簽名，但是你實作的函式本體不需要其中某個參數。這樣編譯器就不會警告沒有使用到的函式參數，會當做你有使用參數名稱一樣。</p>
<h4 id="透過巢狀-_-忽略部分數值"><a class="header" href="#透過巢狀-_-忽略部分數值">透過巢狀 <code>_</code> 忽略部分數值</a></h4>
<p>我們也可以在其他模式中使用 <code>_</code> 來忽略部分數值。舉例來說，當我們只想測試部分數值，但不會用到執行的程式碼中其他部分數值的情況。範例 18-18 的程式碼負責管理設定值的數值。業務要求使用者不能覆寫已經存在的自訂數訂值，但可以取消設定值，也可以在目前未設定時提供數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;無法覆寫已經存在的自訂數值&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;設定為 {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-18：當我們不需要使用 <code>Some</code> 內部數值時，在模式中使用底線來配對 <code>Some</code> 變體</span></p>
<p>此程式碼會印出 <code>無法覆寫已經存在的自訂數值</code> 接著印出 <code>設定為 Some(5)</code>。在第一個配對分支中，我們不需要去配對或使用任一 <code>Some</code> 變體內的數值，但我們的確需要檢測  <code>setting_value</code> 與 <code>new_setting_value</code> 是否都為 <code>Some</code> 變體的情況。在此情況下，我們印出為何不能變更 <code>setting_value</code>，且不讓它被改變。</p>
<p>在其他所有情況下（無論是 <code>setting_value</code> 還是 <code>new_setting_value</code> 為 <code>None</code>），我們用第二個分支的 <code>_</code> 模式來配對，我們讓 <code>new_setting_value</code> 變成 <code>setting_value</code>。</p>
<p>我們也可以在同個模式中的多重位置使用底線來忽略特定數值。範例 18-19 忽略了有五個元素的元組中第二個與第四個數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;一些數字{}、{}、{}&quot;, first, third, fifth)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-19：忽略元組中數個位置</span></p>
<p>此程式碼會印出 <code>一些數字2、8、32</code>，然後數值 4 與 16 會被忽略。</p>
<h4 id="在名稱前加上-_-來忽略未使用的變數"><a class="header" href="#在名稱前加上-_-來忽略未使用的變數">在名稱前加上 <code>_</code> 來忽略未使用的變數</a></h4>
<p>如果你建立了一個變數但沒有在任何地方使用到它，Rust 通常會提出警告，因為這可能是個錯誤。但有時候先建立個你還沒有使用的變數是很有用的，像是你還在寫原型或是才剛開個專案而已。在這種場合，你可以在尚未使用的變數名稱前加上底線，來告訴 Rust 不用提出警告。在範例 18-20 中，我們建立了兩個未使用的變數，但當我們編譯此程式碼時，我們應該會只收到其中一個的警告而已。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">範例 18-20：在變數名稱前加上底線來避免未使用變數的警告</span></p>
<p>我們在此收到沒有使用變數 <code>y</code> 的警告，但是我們沒有收到警告說未使用以底線開頭的變數。</p>
<p>注意到只使用 <code>_</code> 與在名稱前加上底線之間是有些差別的。<code>_x</code> 仍會綁定數值到變數中，但 <code>_</code> 不會做任何綁定。為了展示這樣的區別是有差的，我們用範例 18-21 來展示一個錯誤。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;哈囉！&quot;));

    if let Some(_s) = s {
        println!(&quot;發現字串&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-21：以底線開頭的未使用變數仍會綁定數值，因而造成數值所有權被移動</span></p>
<p>我們會收到錯誤，因為 <code>s</code> 的數值仍會被移至 <code>_s</code>，讓我們無法再使用 <code>s</code>。不過只使用底線的話就不會綁定數值。範例 18-22 就能夠編譯不會產生任何錯誤，因為 <code>s</code> 沒有移至 <code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;哈囉！&quot;));

    if let Some(_) = s {
        println!(&quot;發現字串&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-22：使用底線不會綁定數值</span></p>
<p>此程式碼就能執行，因為我們沒有將 <code>s</code> 綁定給誰，它沒被移動。</p>
<h4 id="透過--忽略剩餘部分數值"><a class="header" href="#透過--忽略剩餘部分數值">透過 <code>..</code> 忽略剩餘部分數值</a></h4>
<p>對於有許多部分的數值，我們可以用 <code>..</code> 語法來只使用一些部分，然後忽略剩餘部分，來避免需要對每個要忽略的數值都得加上底線。<code>..</code> 模式會忽略模式中剩餘尚未配對的任何部分數值。在範例 18-23 中，我們有個 <code>Point</code> 結構體存有三維空間中的座標。而在 <code>match</code> 表達式中，我們想要只處理 <code>x</code> 座標並忽略 <code>y</code> 與 <code>z</code> 欄位的數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x 為 {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-23：透過使用 <code>..</code> 來忽略 <code>Point</code> 中除了 <code>x</code> 以外的所有數值</span></p>
<p>我們列出 <code>x</code> 數值接著只包含 <code>..</code> 模式。這比需要列出 <code>y: _</code> 和 <code>z: _</code> 還要快，尤其是當我們要處理有許多欄位的結構體，但只需要用到一或兩個欄位的狀況下。</p>
<p><code>..</code> 語法會擴展其所有所需得數值。範例 18-24 展示如何在元組使用 <code>..</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;一些數字：{}、{}&quot;, first, last);
        }
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-24：只配對元組中的第一個與最後一個數值，並忽略其他所有數值</span></p>
<p>在此程式碼中，第一個與最後一個數值會配對到 <code>first</code> 與 <code>last</code>。<code>..</code> 會配對並忽略中間所有數值。</p>
<p>然而，使用 <code>..</code> 必須是明確的。如果 Rust 無法確定是哪些數值要配對，而哪些是要忽略的話，它會回傳錯誤給我們。範例 18-25 含糊地使用了 <code>..</code>，所以它無法編譯。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;一些數字：{}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">範例 18-25：嘗試含糊地使用 <code>..</code></span></p>
<p>當我們編譯此範例時，我們會得到此錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 不可能會知道在配對 <code>second</code> 之前要忽略多少元組中的數值，以及在之後得再忽略多少數值此程式碼可以代表我們想要忽略 <code>2</code>、綁定 <code>second</code> 到 <code>4</code> 然後忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或者我們想要忽略 <code>2</code> 和 <code>4</code>、綁定 <code>second</code> 到 <code>8</code> 然後忽略 <code>16</code> 和 <code>32</code>，以及更多可能。變數名稱 <code>second</code> 對 Rust 沒有任何特別意義，所以我們得到編譯錯誤，因為像這樣在兩個地方使用 <code>..</code> 是含糊不清的。</p>
<h3 id="提供額外條件的配對守護"><a class="header" href="#提供額外條件的配對守護">提供額外條件的配對守護</a></h3>
<p><strong>配對守護</strong>（match guard）是個在 <code>match</code> 分支之後額外指定的 <code>if</code> 條件，除了原本的模式配對，此條件也必須配對才能選擇該分支。配對守護適用於比單獨模式所能表達的還複雜的情況。</p>
<p>該條件能使用配對建立的變數。範例 18-26 展示 <code>match</code> 的第一個分支有個模式 <code>Some(x)</code> 並使用配對守護 <code>if x &lt; 5</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&quot;比五還小：{}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-26：對模式加上配對守護</span></p>
<p>此範例會印出 <code>比五還小：4</code>。當 <code>num</code> 與第一個分支做比較時，它會配對到，因為 <code>Some(4)</code> 能與 <code>Some(x)</code> 做配對。然後配對守護會檢查數值 <code>x</code> 是否小於 <code>5</code>，然後因為的確如此，所以就選擇了第一個分支。</p>
<p>如果 <code>num</code> 為 <code>Some(10)</code> 的話，第一個分支的配對守護則會是否，因為 10 並不小於 5。Rust 就會接著檢查第二條分支，然後因為第二條分支沒有任何配對守護所以能配對到任何 <code>Some</code> 變體。</p>
<p>在模式中沒有任何方式能夠表達 <code>if x &lt; 5</code>，所以配對守護讓我們能夠有能力表達此邏輯。</p>
<p>在範例 18-11 中，我們提到我們可以使用模式配對來解決我們的模式遮蔽問題。回想一下 <code>match</code> 表達式中使用的是模式內建立的新變數，而不是使用 <code>match</code> 外部的變數。該新變數會讓我們無法測試外部變數的數值。範例 18-27 展示我們如何使用配對守護來修正此問題。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;取得 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;配對成功，n = {}&quot;, n),
        _ =&gt; println!(&quot;預設情形，x = {:?}&quot;, x),
    }

    println!(&quot;最後結果：x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">範例 18-27：使用配對守護來測試與外部變數是否相等</span></p>
<p>此程式碼現在會印出 <code>預設情形，x = Some(5)</code>。第二個模式中沒有宣告新的變數 <code>y</code> 來遮蔽外部的 <code>y</code>，意味著我們可以在配對守護中使用外部的 <code>y</code>。我們不再指定模式為 <code>Some(y)</code>，因為這樣會遮蔽外部的 <code>y</code>，我們改指定成 <code>Some(n)</code>。這樣建立了一個新的變數 <code>n</code> 且不會遮蔽任何事物，因為 <code>match</code> 外部沒有任何變數 <code>n</code>。</p>
<p>配對守護 <code>if n == y</code> 不屬於模式，因此不會宣告任何新變數。此 <code>y</code> <strong>就是</strong>外部的 <code>y</code> 而非新遮蔽的 <code>y</code>，而且我們可以透過將 <code>n</code> 與 <code>y</code> 做比較來檢查數值是否與外部 <code>y</code> 的數值相等。</p>
<p>你也可以在配對守護中使用 <em>OR</em> 運算子 <code>|</code> 來指定多重模式，配對守護的條件會套用在所有的模式中。範例 18-28 顯示了結合配對守護與使用 <code>|</code> 模式之間的優先層級（precedence）。此例中的重點部分在於 <code>if y</code> 配對守護能套用在 <code>4</code>、<code>5</code> <strong>與</strong> <code>6</code>，而不是只有 <code>6</code> 會用到 <code>if y</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;是&quot;),
        _ =&gt; println!(&quot;否&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-28：結合數個模式與配對守護</span></p>
<p>此配對條件表示該分支只有在數值 <code>x</code> 等於 <code>4</code>、<code>5</code> 或 <code>6</code>，<strong>以及</strong>如果 <code>y</code> 為 <code>true</code> 時才算配對到。當此程式碼執行時，第一個分支的模式有配對到，因為 <code>x</code> 為 <code>4</code>，但是配對守護 <code>if y</code> 為否，所以不會選擇第一個分支。程式碼會移動到第二個分支，然後程式會配對到並印出 <code>no</code>。原因在於 <code>if</code> 條件會套用到整個模式 <code>4 | 5 | 6</code>，而不是只有最後一個數值 <code>6</code>。換句話說，配對守護與模式之間的優先層級會像是這樣：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是這樣：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>在執行此程式碼之後，優先層級的行為就很明顯了，如果配對守護只會用在由 <code>|</code> 運算子指定數值列表中最後一個數值的話，該分支應該要能配對到並讓程式印出 <code>是</code>。</p>
<h3 id="-綁定"><a class="header" href="#-綁定"><code>@</code> 綁定</a></h3>
<p><em>At</em> 運算子（<code>@</code>）能讓我們在測試某個數值是否配對的到一個模式的同時，建立出一個變數來持有該數值。範例 18-29 展示我們想要測試 <code>Message::Hello</code> 的 <code>id</code> 欄位是否位於 <code>3..=7</code> 的範圍中。但我們也想要將該數值綁定到變數 <code>id_variable</code> 之中，讓我們可以在該分支對應的程式碼中使用它。我們可以將此變數命名為與欄位同名的 <code>id</code>，但在此例中我們會使用不同名稱。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;id 在此範圍中：{}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;id 在其他範圍中&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;找到其他 id：{}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-29：使用 <code>@</code> 來在測試時綁定模式中的數值</span></p>
<p>此範例會印出 <code>id 在此範圍中：5</code>。透過在範圍 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我們能獲取要配對到範圍的數值，並同時測試該數值是否有配對到範圍模式。</p>
<p>在第二個分支中，我們只有在模式中指定範圍，該分支對應的程式碼就沒有變數能包含 <code>id</code> 欄位的實際數值。<code>id</code> 欄位數值可能是 10、11 或 12，但此模式的程式碼不會知道其值為何。該模式程式碼無法使用 <code>id</code> 欄位的數值，因為我們沒有將 <code>id</code> 數值存為變數。</p>
<p>在最後一個分支中，我們指定沒有限制範圍的變數，我們有能在分支程式碼中使用的有效變數 <code>id</code>。原因是因為我們使用了結構體欄位簡寫語法。不過我們在此分支沒有向前兩個條分支進行任何對 <code>id</code> 欄位的測試，任何數值都會配對到此模式。</p>
<p>使用 <code>@</code> 讓我們能在一個模式中測試數值並將其儲存至變數。</p>
<h2 id="總結"><a class="header" href="#總結">總結</a></h2>
<p>Rust 的模式對於幫助分辨不同種資料來說非常實用。當在 <code>match</code> 表達式中使用時，Rust 確保你的模式有涵蓋所有可能數值，不然你的程式就不會編譯通過。在 <code>let</code> 陳述式與函式參數中的模式使它們的結構更實用，在能夠解構數值成更小部分的同時賦值給變數。我們能夠建立簡單或複雜的模式來滿足我們的需求。</p>
<p>接下來，在本書的倒數第二章中，我們要來看 Rust 眾多特色中的一些進階部分。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-refutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-00-advanced-features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-refutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-00-advanced-features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
